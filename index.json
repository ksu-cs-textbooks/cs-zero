




	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		
[
  {
    "content": " Resources Slides Video Script In this module, we’re going to learn about algorithms. But before we can discuss algorithms, let’s take a look at something that you might be very familiar with and see how it actually relates to the idea of an algorithm. For example, we can ask ourselves, how do you shuffle cards? It’s something that is really hard to describe. But once you see it, and you can observe other people doing it, it’s pretty easy to understand what’s going on. But to really know how to shuffle cards, we have to ask ourselves, what items do we need? What tools do we need? Do we need any skills and do any prior knowledge for example, we need to know what a deck of cards is, we need to know what shuffling means we need to know how to manipulate the cards in such a way that they will become shuffled. And of course, even then, the terminology we use is still very difficult. In years past, when I’ve asked students how to shuffle cards, they’ll usually tell me something like cut the deck and then hold them up like this and then ruffle the cards together and it will work. But of course, if you don’t know that cutting the deck means separating the top half from the bottom half and not taking a pair of scissors and cutting them in half. That might be really hard to understand.\nAnd so in this module, we’re going to talk about algorithms and specifically, why it’s very important when you’re writing an algorithm for a computer to be very specific and very explicit about the steps you want it to take. Otherwise, it will not do exactly what you want it to do. So first, we can talk about where the word algorithm comes from. And the word algorithm comes from the name Al - Khwarizmi, which is a shorter version of the name of Abu Abdallah Muhammad ibn Musa al-Khwarizmi . He was a mathematician in the 9th century A.D in Persia. And one of the things he did is he wrote a lot of books on contemporary mathematics. And one of his books was very unique because it included a set of steps to solve some common mathematical problems. And those steps form the basis of what we now call an algorithm for solving those problems. And so in the next video after this, we’re going to see a little bit more about The history of Al-Khwarizmi and why he is so important and so interesting in the field of computer science.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/06-algorithms/01-introduction/"
  },
  {
    "content": " Notes About This Selection This video outlines how the Antikythera Mechanism was found and some of the research that has been done on the mechanism. Getting its name from the island by which it was found, the Antikythera Mechanism had been hidden in the ocean for over 20 centuries. This is a textbook example of how humans have been automating processes for thousands of years. This video offers an insightful juxtaposition of using modern computers to analyze ancient computers.\nReference Antikythera - Anticythère - Αντικύθηρα - 安提凯希拉. “The Antikythera Mechanism - 2D”. June 25, 2011. YouTube. Available: https://www.youtube.com/watch?v=UpLcnAIpVRA.\n",
    "description": "",
    "tags": null,
    "title": "The Antikythera Mechanism - 2D",
    "uri": "/i-concepts/02-early-computing-machines/01-the-antikythera-mech/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Computer Graphics",
    "uri": "/iii-topics/22-graphics-and-video-games/01-computer-graphics/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Hans Rosling's 200 Countries, 200 Years, 4 Minutes - The Joy of Stats - BBC Four",
    "uri": "/iii-topics/20-big-data/01-200-years/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’re going to take a look at one of the most important applications of computer science and modern technology- the field of cryptography. Cryptography is the study of ways to communicate securely and privately in the presence of third parties. If you think about it, cryptography is very important today with the rise of the Internet and modern technology. Any data that’s transmitted over the internet can be intercepted by just about anyone from your internet service provider all the way to the website that you’re communicating with, and anybody in between. Remember, the internet is built upon open standards, and so anybody can understand the packet formats and deconstruct them very quickly. So we need a way that we can encrypt and secure the data inside of those packets. So they can only be opened by the intended recipients, and that’s where the field of cryptography comes in. There were lots of historical Computer Science professionals interested in cryptography. Charles Babbage was very fascinated by it. Alan Turing was especially involved in cryptography, and Claude Shannon, were all involved in the field of cryptography. Also, surprisingly, the author Edgar Allan Poe was one of the people that was really excited about cryptography outside of computer scientists, and in fact, helped popularize cryptography as a word game that you might see in your newspaper.\nSo let’s take a look at an example of what cryptography might look like. When I used to teach this in a classroom, I would usually start by having strips of paper with this particular message printed out and laid all over the tables, and I would encourage students to see if they could decrypt this particular message. So on the slide here, you see the same text that I have written on the strip of paper, but it can be kind of hard to decrypt this message. So take a look at it and see if you can come up with what this message should say. I’ll give you a hint. If you have a marker nearby, or something that’s about this big and round kind of dowel shaped, that might help. Still need a hint? Well, what happens if I take this piece of paper, and I wrap it around the marker like so. Take it and wrap it. Just like that. So now I’ve taken this message, and I’ve wrapped it around the marker. And you’ll notice that when you do this, the text kind of starts to line up, you can see that there are characters that start to line up. That’s what this is. This message is actually an example of one of the earliest forms of cryptography called a Scytale. A Scytale was round dowel rod, kind of like this marker that you could use to encrypt and send messages. And it was used all the way back in ancient Roman and Greek times. For example, if you wanted to send a message to somebody, you could take a strip of leather and wrap it around the Scytale, and then you would impress the characters of the message across the strip of leather on the Scytale. Then you would unwrap it, and you’d end up with a string of random characters that look something like this on the paper, and you could send that piece of leather out into the field. And of course, the only way to decrypt it would be to know how to decrypt it, and to have a Scytale that was the same size as the one that was used to encode that message. And so if you were very careful, you can use Scytale of different sizes to encode different messages using the same technique. So if we start with this message in the class, you realize that a Scytale is really just an iterative cipher, where we start with about every six letters. So we have this is a Scytale example. That’s what that message would say. Now, of course, you’ll notice I’ve added the letter Q in there a couple of times. And that’s actually very commonly done in the field of cryptography. As long as the message is understandable to the person receiving it when they decrypt it, you can add some random characters in there that don’t make any sense once you have decrypted the message, but it can really help foul up people trying to decrypt the message and use every single character in the message. It’s a neat little trick to make your encryption just that much more unbreakable.\nThere are lots of examples of early ciphers that have been used throughout history, we looked at one called the Scytale. There are also things such as substitution ciphers. A substitution cipher is where you take the letters in your text and you simply replace them one for the other. For example, all B’s become Q’s. All K’s become G’s, and so on and so forth. If you read the newspaper or do puzzle books, you might have seen a puzzle called a crypto quip. That is actually an example of a substitution cipher, and it’s one that was made popular by Edgar Allan Poe. Of course, putting your crypto equipment in newspaper might lead you to think that it’s easily breakable, and it totally is. One of the best ways that you can break things that are substitution ciphers is by frequency analysis. You look for the most frequent characters, and then you assume that those would be probably the most frequent characters in the English language. For example, in English were helped out a lot by the game show Wheel of Fortune. We know that the letters R S T L N E are some of the most frequently used characters in the English language. So if we find the most frequent substituted letters in our substitution cipher, we can try those characters and see what works. Also things such as short words, two letter words, things like that really helped break a crypto crypt very, very easily.\nSo then you get to more advanced ciphers called polyalphabetic ciphers. And these are like substitution ciphers, but much, much more advanced. For example, you would substitute letters not only based on the previous letter, but the position and all sorts of other things. Polyalphabetic ciphers were first described all the way back in the ninth century AD by the Islamic mathematician al-Kindi, but they were later explained in a lot more detail by French mathematician Leon Battista Alberti in 1467. So of course, once again, polyalphabetic ciphers can seem very complicated. But once you really discover how many different substitution ciphers there are in a polyalphabetic cipher, then it reduces the problem to simply breaking each of those individual substitution ciphers one at a time. So while they’re still powerful, they’re not nearly unbreakable, like we might think today.\nAnother example of an early cipher would be the tabula recta. A tabula recta, like you see here is all of the letters of the alphabet are arranged in a grid. And you can see that each grid shifts by one letter. Then with a table such as this, there are a lot of different algorithms you can use to encrypt data. For example, you could use the previous letter in the data to encrypt the next letter that you want to encrypt. So if we want to encrypt the word HELLO, we would start by using H to encrypt H. So we get H, but then the next letter E would be encrypted using the H line and it becomes L, then we use the next L to encrypt L. So we would encrypt L, which would be W, then we use W to encrypt another L, which becomes H. And then we use H to encrypt O, which becomes V. And so by following that process through, we can use the tabula recta to create a very, very hard to break cipher just by following an algorithm. And of course, you can do all sorts of different things with this and it creates a pretty powerful cipher, not one that is completely undecipherable. But it’s a very powerful way to do something using a very simple table such as this. And this is actually the same basis of things like the decoder rings that you might have heard about that were sold in cereal boxes years ago, they use the same basic idea. If you have the table or the decoder ring or whatever the ciphers key is, then it becomes very easy to break but without the key, you have to discover the key in order to break it easily.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/iii-topics/16-cryptography/01-intro/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’re going to discuss a lot of topics related to cyber security. Cyber Security is another important research area in computer science, and it’s one that directly impacts a lot of computer users in their daily lives. So in cybersecurity, we really are asking ourselves one big question, how do we keep our data secure, and that’s really all it comes down to. We’re trying to secure data both on our computers, but also as we transmitted across the Internet, and any other communication technologies we might be using. And so we’re going to talk about some different ways that we can keep our data secure on our computers.\nBefore we get into that, a word of warning, I’m encouraging each of you to put your white hat on when we talk about this. So in computer science, we talk about different types of hackers. And typically, you have the black hat hackers, which are the ones that do so maliciously. But you can also have white hat hackers, which are hackers that use their skills for benevolent means– to help companies find security holes in their infrastructures and hopefully patch those holes and become a little bit safer. And so some of the things we’re going to talk about today, if used maliciously, could be very illegal, they could be felonies, they’re very, very dangerous things for you to use maliciously. But as a computer scientist, it’s important for you to understand those topics so that you can defend against them and know what they are in case they get used against you. And so I’m encouraging us all to put our white hats on at this point, and come at this topic from the view of doing this for the good of everybody else and trying to help them secure and protect their data. Okay, let’s get started.\nFirst, we need to talk about authentication. Authentication is a very, very important part of anything in cyber security. And authentication mainly deals with a few things, it’s determining if the person is who they say they are. So when you sit down to a computer, and you type in your password, that is a form of authentication. You’re letting your computer authenticate the fact that you are who you say you are. Now, typically, authentication requires three different factors. There are ownership factors, which is something the user has. For example, an ownership factor could be a physical key to a building, it could be a USB drive that has a token on it, or it could be some other symbol or some other device that the user has to authenticate that they are who they say they are. A police badge, for example, is a form of authentication that authenticates who that person is. The second one we can talk about is knowledge factors. A knowledge factor is something the user knows that authenticates themselves. Typically, we think of this as passwords and pin numbers or anything else the user has memorized. But it could be even other facts such as birth dates, and mother’s maiden names, and social security numbers, things that the user would know very quickly. Those are what makes up a knowledge factor. And for most computer systems, we use knowledge factors as the primary form of authentication. The third form of authentication is an inherent factor. And an inherent factor is something the user inherently is. An inherent factor would be things such as a retinal scan, or a fingerprint scan, or DNA test, something that these are really can’t change about themselves.\nAnd so to authenticate a user in a computer system, we typically use one of these factors at a minimum to authenticate them. There is also something called multi factor authentication or two factor authentication, which you’ve probably come across, especially if you do online banking or play certain video games. And that is pretty much exactly what you think it is, it is two different factors of authentication combined to provide greater security. And typically, they combine something the user knows, such as a password or a pin number ,with something the user has, such as a credit card, or in a lot of cases, it’s access to a mobile phone or an email account. And that is something the user has or possesses as the second factor of authentication. So think about some places that you run into two factor authentication, video games, online banking. At K-State, a lot of faculty and staff now use two factor authentication whenever they authenticate at K-State. But a big question to ask yourself is, would you as a student like to have two factor authentication on your K-State account? Why or why not? Do you think it’s worth the extra security to really protect all of your important academic records? Or is it just an extra hassle if you have to get your phone out every single time you want to log in? Currently, for faculty and staff, we log in with our phones, but then we can have it remember our device for up to 10 days before we have to do that two factor authentication again. So it’s a little bit extra hassle, but it’s not super inconvenient if we’re using the same computer day after day. But I could see if you’re using lab computers and have to authenticate every single time, that might be a little extra hassle for you. So it’s something to think about.\nSo in this lecture, we’re going to hone in on one of the most common authentication factors, which is the use of a password. A password is a very traditional system used to authenticate users on computer systems, on websites, just about anywhere. But I think there’s a lot of misconceptions about how to make secure passwords and how secure passwords really are. And so we’re going to rely on some information to really look at passwords and how they can be made more secure and some of the ways that they may be are less secure than we thought. So this is a comic from XKCD. It’s one of the great comics that he does. And here, he’s talking about how we make a particular password. And we’re going to come back to this comic. But here he shows a pretty common password, we start with an uncommon, but non jibberish word, then we add like a number and a punctuation because almost every website, you need to have at least a number and a punctuation. And we do some common substitutions from leet speak so zeros for O’s and fours for A’s. Usually we have caps and 99% of the time, if you’re going to capitalize the letter, it’s going to be the first letter of your password. So what we have is we have a password here that has a few different bits of entropy. And in fact, if you calculate it out, there’s just about 16 bits of entropy in this box. So that means that there are roughly 65,535 different ways that you could build a password. Based on these rules. You choose a word, you add some numbers, and punctuations, and substitutions and things. And so 16 bits of entropy, that sounds pretty powerful.\nBut how would we go about cracking this password? What would that look like? So let’s look at some different ways you could possibly crack this password. Obviously, the first thing you could do is you could try brute force. You start with aaaaaa, that didn’t work aaaaab, that didn’t work, and so on. And so brute force hacking does work in certain scenarios, especially for things like combination locks. If you’ve ever done a an escape room, one thing you might realize is they give you those combination locks with four dials on it. And hopefully, you’re smart enough to realize that if you only get three of the four dials, and you can’t quite figure out the fourth one, you could brute force it in about 10 seconds. So you really don’t have to get all of the dials, you can just brute force a little bit. And so with combination locks and things, sometimes it’s very, very easy to brute force them. And in fact was simple passwords like old websites that required your passwords to be eight characters or less, you could actually brute force a password very quickly. For example, here is a six character password, there would be about 308 million different six character all lowercase passwords. It seems like a lot, but if we try it about 1000 a second, which is pretty, pretty common. I mean, even on a bad website, you could try 1000 passwords a second, it would only take us about three and a half days to crack that password. And in the grand scheme of things, three and a half days is not that long.\nSo let’s look at another way. How about things like rainbow tables. For example, this slide shows the 25 most common passwords used on the internet, according to some research done by Gizmodo a few years ago. And looking at this list, it is pretty disappointing. You’ll see passwords such as 123456, or 123456789. But you’ll see things like sunshine, qwerty, iloveyou, admin, abc123, certain profanity words. And so these passwords are really not all that great. And in fact, it’s really easy to go online and find some of the most common passwords that are available. Another thing that we can look at is what’s called rainbow tables. And so a rainbow table is actually a password lookup table that is calculated all of the protected versions of these passwords. For example, on older versions of Windows, when you set your windows password would actually be stored in the Windows registry using a hash. And so a hash, if you remember from our previous module is an algorithm that takes a piece of text and converts it to a number using a one way algorithm. And so the theory is if you type in the same password and go through the same hash algorithm, if you get the same output, you know, they put in the right password. But of course, what you could do is put in all possible passwords and store all of the possible hashes and create a table that matches them up. And so that’s what a rainbow table is, it basically creates a rainbow of all the different possible password combinations and the hashes that those create. And so if you have a Windows computer, an older Windows computer and can get the password hash out of the registry, you can go online to these websites that have rainbow tables and just put in that hash, and they will look up the password for you or at least a password that creates that hash. And so for a lot of really bad algorithms such as the early windows algorithm, there are some algorithms such as MD5 that rainbow tables are created for, you could just go out and look up a password based on a hash.\nSo between brute forcing common passwords and rainbow tables, there are a lot of different ways that you can crack really easy passwords. So let’s go back and look at that password example we saw earlier and talk about entropy. So he calculates that there would be about 28 bits of entropy in a common password there and 2 the 28 to get about three days at 1000 guesses a second. It’s really similar to what we saw with brute forcing, even though it’s a much longer more complex password, but it’s actually pretty easy to break a password like that. Now, here’s the hard part. Can you remember what that password was on that slide a few minutes ago? Don’t Look, don’t rewind the video and look, but see if you can write down that password that we saw earlier. Did you get it? Now you can go look and see if you got it. And so it turns out that we’re creating passwords that are really easy to actually crack if we understand the structure of the password. But it’s very hard for us to remember is it’s troubadour with an \u0026 and a three, but I don’t remember exactly what order so it’s hard to remember.\nAnd so what he’s arguing here is we’re creating passwords that are basically easy to crack and hard to remember, what we really should focus on is creating passwords that are hard to crack, but easy to remember. How do you suppose we would do that? It turns out that to make more complex passwords, there is exactly one rule that you need to follow. And that is make them longer. That’s it. No special characters, no capitalization, punctuation, lowercase, uppercase, numbers, symbols, foreign words, does not matter. The only thing that matters to make your password more secure, is making it longer. So here we have four random common words, you start with 1000 common words in the English language. So that means you have about 10, or 11 bits of entropy per word. And you pick four of them correct horse battery staple. purple monkey umbrella dishwasher. very, very simple. All you have to remember is those four words, and I can even go out there and say, here’s a list of 1000 words. And my password is four words separated by spaces. And that right there would have 44 bits of entropy. So even if I gave you the list of words and told you exactly how my password was set up, it could take you 550 years to try all possible combinations of that password at 1000 guesses a second. That is much, much harder to do. But it’s very easy to remember, you probably already remember that password correct horse battery staple. It’s very easy to remember.\nAnd so the whole idea behind making secure passwords, we see a lot of websites today that tell you you have to have a number and a symbol and special characters and whatnot, doesn’t matter. The only thing they should do is set a minimum password requirement of 20 or 30 characters and just tell you to make a long password. That right there will make your password more secure with a big asterisk on it. Understand that when we talk about security here, we’re only talking about security based on cracking the password using some sort of brute force method or some sort of dictionary based method. We are not saying that that password is secure against all attacks, for example, correct horse battery staple, if you write that down on a post it note and stick it under your keyboard, it would only take somebody about two seconds to read that password off of the post a note and remember it instantly. There’s nothing special about it. And so just because it’s easy for you to remember doesn’t mean that wouldn’t also be easy for someone else to remember. Likewise, if you don’t pick four random words, if you pick four words like your four grandparents or something like that, like their names, that could be much easier for people to crack. And so while it’s uncrackable from a computer standpoint, there are other parts of cybersecurity that we’ll get into a little bit later that make this password maybe less secure than what you want.\n",
    "description": "",
    "tags": null,
    "title": "Passwords",
    "uri": "/iii-topics/17-cybersecurity/01-passwords/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re going to be taking a look at information retrieval. But before we get to that point, we need to start talking about databases and how data is actually stored. So for this example, we’re going to be working on our own social network called K-Stater. Specifically, we’ve been asked to help design a way to keep track of all the data on a site, like a social network, like K-Stater should have. So if you take a few minutes and brainstorm what kind of data or imagine what kind of information we may need, for example, of course, we’ll need to have some sort of way to track our users like maybe your eID, name, birthday, major, and maybe even just your phone number. And, you know, of course, we’ll need a lot of other information to make a full website like this work. But we can start off with the basics right, just keeping track of our users. But since we want to keep track of all that information, we need some way to actually store it. And so there’s tons of different ways that we could actually store that on our computers, right, of how our computer systems are designed to store information in that way.\nBut thankfully, there was a huge change in how the data on our computers are actually stored, or at least how we even look at data stored on our computer. And that’s mostly thanks to this man here, Edgar F. Codd. While working for IBM in the late 1960s and early 70s, Codd began working on the ideas of relating to the storage and arrangement of data in computer systems. And in 1970, he published a paper called a relational model of data for large shared data banks that laid out this grand idea for a better way of storing data. That idea led to the creation of what we call a relational database. This is a form of database that is by far the most common in the world today. And if you’ve ever used things like Microsoft Access, or MySQL, or something like that, Microsoft Access is a simple type of relational database. That is pretty easy to use for most people just like what you would open up and use with Microsoft Word or even Excel, and Excel to some extent, depending on how you have your sheet set up is like a relational database, or at least relational data in some sense.\nThe idea behind a relational database revolves around three different terms, a relation, a tuple, and an attribute. A row in a table is called a tuple. It represents a single item that is stored in the database. In a simple example each person stored in our database could be a just a single tuple. Right, or if we are storing addresses for our users, so that address itself would be one tuple, or one row in our database. Each row or tuple has many attributes represented by columns in the table. An attribute could be something like a name, address, or like a street, zip code, phone number, one single piece of information that is associated with that one particular row or record in. The table itself is called a relation because it relates different attributes together uniquely, in order to describe objects as tuples. So our relation as a whole, right, a relational database. So each attribute strung together in a single tuple is like information related information, right? So we have we have a user, our user may have a name, a username, an email, and all sorts of different types of information. Each of those attributes are related to each other, or in an ideal situation of how we design our database. But relating those different attributes together is really kind of what we are, what we benefit, or what we get out of something like relational database, because it makes our data much easier to store because we store like information with like information, right, so all of those records that have similar information, like all of the user information, and it makes it a lot easier to store and search. Especially in a modern age where we have such large amounts of information, having this highly structured data makes it significantly easier to work with and use as you utilize apps like Facebook and Twitter.\nBut let’s do some hands on work with a relational database. So since we’re creating a social networking site, probably one of the first relations we’ll need to create is for the user. Right, because a social network is pretty much useless without some people to actually use it. So here’s one potential way that we could set that up. The data here is all nicely arranged into rows and columns, and in theory, right should be easy to look things up. Maybe not. Right? At least the way that I have it currently. So what if you wanted to find all of the students here in our in our user database, or our user relation here that are majoring in computer science? How would I go about doing that? Take a moment here to pause the video and take a look at a table here and see if you can find all of the users or come up with a way to find all of the users who majored in computer science. Hopefully you found all of the users there’s that do did majored in computer science is pretty straightforward, right? But for us humans, and for the small number of users, but for a computer to search our table here to find all of the computer science majors, it becomes a little bit more complicated. Obvious, my name is in there, Josh, first row there. My major is comp. sci, which is short for computer science. And we don’t need the information science or Information Systems majors there.\nBut we have another computer science major there, gameguy down there, his major is computersci, all one word. And so while both of those users are computer science majors, the listing or how can the computer science major is actually listed as entirely different. That makes the solution for a computer much more difficult to actually write because now we have to take into account in this situation, all of the different spellings and arrangements of the computer science major. So this particular relational table or this particular relation, we would refer to as not normalized so the data isn’t normalized, the data isn’t uniform. And so why do we want to normalize the data? Well, big obvious reason that we just experienced is normalized data makes it a lot easier to actually work with. So those data anomalies, right, the differentiation between compsci, CS, computersci, computer science, all of those differentiations, they’ll mean the same thing. But it becomes a lot harder and more difficult to use, and it makes it more prone to error as well. It also makes redesigning your information a lot easier. More often than not, when you’re actually working with an application or designing an application that’s working with a database, you’ll end up finding that your use cases change over time. And so more often than not, you have to go back in and redesign your database or redesign your tables in order to add new columns or attributes or entirely new relationships.\nAnd so having normalized data to begin with makes that task significantly easier because you don’t have any data anomalies in an ideal world that can throw a wrench into your plan. But one of the other things that normalizing our data can actually accomplish is mirroring real world concepts. So we don’t want to store information into our relation in a random computerized way. Because that’s not the real goal that we’re trying to accomplish with these databases. The goal here is to store information that is significantly easier not just for the computer to actually search through, but also humans as well. And so we want to be able to store our relations in a way that mimic what we would normally store that information in real life. For example, addresses and things like that we don’t have need to come up with these crazy elaborate ways to actually store an address. But we want to make sure that it’s stored in a way that makes sense. Of course, and lastly, this also simplifies the search queries that we actually do on our relations or our data. So those that question that I asked of find all the users that majored in computer science is a lot easier if all of the computer science majors have the exact same spelling of the computer science major. And so having normalized information and normalized data also makes our search tasks significantly easier. So let’s take a look at a way that we can actually start to fix our unnormalized relation.\nSo first off, let’s take a look at the major column because that’s what we encountered first, and that’s what we tried to search first. So what can we do to make sure that the data in that column is easy to search through or easy to query? Now, if you pause to kind of think of a few ideas here, one potential way that I have listed here is to add an ID for each major. And so essentially, what we end up having here is a second relation. So we split the major off into a second table or a second relation, that acts as a lookup table. Okay, so if you imagine using your basic form online, when you’re signing up for stuff, a lot of times you’ll encounter drop down boxes, right? Those act like simple lookup tables, right, you are given a specific set of things to choose from, instead of typing in free text. Free text, when we’re talking about storing things inside of a table, if we want that free text to be uniform, we can’t rely on our users to enter that for us, we have to suggest and complete that and give them the options to actually select from. But since we have a separate table, here, we need something that’s called a primary key that identifies each record uniquely so we can include it in the other table. It also makes it easier to search.\nEach relation in your relational database should have a primary key. And that primary key uniquely identifies each record. So each record in a table or an in relation should be able to be uniquely identified by any number of attributes. So a primary key does not have to be one single attribute. But it can be multiple attributes combined together that are unique. And without that uniqueness, there’s no possible way for us to uniquely retrieve any single record from our database. So that particular part is extremely important as far as relational database goes. What we have here in our new table is our major ID. And you can actually use that to look up the actual abbreviation or the actual major itself. So major ID in this table, this is our major table now. This column is going to be the primary key. And over here, we can just assume that our user ID is our primary key, because everyone at K-State has a unique eID. So we can safely assume that that is our primary key that uniquely identifies each user. But instead of having the major column here in our user table, we now have major ID. And so when a user actually selects their major, you can imagine they would be selecting this through a drop down box. But that is replaced not with the actual major, but the ID of that major.\nSo if we wanted to see what major John was, we take the major ID 3, look that up in our major table. And that tells us that John is an Information Systems major. And that information systems major has an abbreviation of IS. But this makes it significantly easier for us to look up all of the computer science majors because all we need to do is look up find computer science in our major table, what is that ID and then search that ID in our user table. And so that process is made significantly easier now. But let’s also talk about the birthday column, if we can think of different ideas to how to represent that. Because if you look over here, on our birthday column, we have a whole bunch of different variety of ways that we have for our birthday. So June 13th, June 1, February 2nd, Dec 26, Dec. 18th with a period 18th. So we have abbreviations for the months, days, with the th, nd. So there’s lots of different variations here, we and we don’t even have just the pure numbers yet, which you assume that people would add as well. So there is no uniform way of representing the birthday now. But what we could do is add that to our interface, right, we don’t have to necessarily purely rely on our database, although we could enforce a specific format for our column on the database side. But we can also enforce that when the date is actually entered. So we can have like a little calendar picker or something like that, or an algorithm actually checks the text before it’s actually saved. So just something to watch out for when you’re working with information.\nIt is a very good practice to keep our data normalized, to keep everything not just unique but evenly distributed or even format street same format for everything because if a human’s going through here and reading this, of course, we could also we can all see what the birthday is and understand what each of these mean. But when we’re querying our database or if our algorithm or computers looking at these records, it becomes significantly more difficult to actually understand. But let’s look at another example. What happens if we try to add a phone number to our user table? Now I’ve stripped off some of the other columns here just to make this example a little bit easier to see and fit onto one slide.\nBut let’s try to add our phone number. So but how many phone numbers does the typical person have these days? Well, landlines really aren’t that that common anymore, but people still have them. I have one in my office. But I also have, you know, my cell phone, I have a digital telephone number as well, and a couple others, right. So someone might have multiple, just even multiple wireless or cell phone numbers without even considering a landline. And so adding multiple phone numbers for a particular user can become a little bit difficult to actually do. And so if we try to just simply add, say, phone number one, phone number two, things get complicated really quickly, because if someone has more than one phone number, we had to add another column for their second one and another one for their third and so on. And so that doesn’t really become a very good practice. Because, in reality, we don’t want to have to add another call to our database or to our table every time we need to add a an extra phone number for a particular user. So like what we did before, let’s try to put that into a another table, its own table. So one of the ways that we could do this is just have a phone number table. and in this situation, Our phone number is going to be the unique or primary key. And then we have the users that connect the relationships together. So we have a we have many users, right to one phone number.\nAnd this works, but still really doesn’t solve our problems, does it? We still have the same issue before, instead of having having to add multiple phone numbers, multiple phone columns, we now have to add multiple user columns, because right, what if an entire family signs up for our social network? That family might share a phone number, so each person in that family is going to have the same phone number. So every time another person from that family signs up, we’re going to have to add another user to that phone number. So we end up with pretty much the same problem that we did before. So if we flipped it again, right, we can still have our phone number table. But let’s flip that. What if we use the user ID for the primary key in both situations, so primary key over here is our user, right? But we’re going to connect that to a user in our phone table. But now instead of just having only the user ID as our primary key, we have the user ID and the phone number as our primary key.\nSo if we use both of those to uniquely identify a phone record, that becomes a little bit more easier to do, because we don’t duplicate any information here. Although, of course, we do duplicate the user ID down here, which is perfectly fine. But this makes it more easy to search, right. So this is a one to many type relationship, where we have one user too many phone numbers. So we have one user here, but many phone numbers here. And so that describes the relationship between these two tables. And so we can see it over here. Since the user ID and the phone number are unique together, we can have the same phone number for multiple users. So we have phone number 5134. So gameguy has two phone numbers, but Sharpie also shares the same number as gameguy here. Now this is just a simple example of how we might store a large amount of information or related information into a database that is easily retrievable by a computer.\n",
    "description": "",
    "tags": null,
    "title": "Relational Data",
    "uri": "/iii-topics/19-search-info/01-relational/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Creepy Line",
    "uri": "/iii-topics/21-ethics/01-creepy-line/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Rise of Artificial Intelligence | Off Book | PBS Digital Studios",
    "uri": "/iii-topics/18-ai/01-rise-ai/"
  },
  {
    "content": " Resources Slides Video Script In this module, we will spend a lot of time talking about compression and error checking in our computers. We’ve already talked about compression a little bit in the data encoding module earlier this semester. But now we’re going to spend an entire module talking about just these two topics. First, we’re going to talk about in compression. What do you think compression is and why do you think it’s useful? As you might recall, compression is reducing the amount of space a particular piece of data needs to be stored on a computer. And if we think about that, that may not even really make sense, how can we take the piece of data and store it in fewer Bits and Bytes than what it originally was? It turns out, there are a lot of different ways to do that. We can do all sorts of different things by replacing repeated chunks of data or re-encoding the data in such a way that we can interpret it differently in our computer systems. And we’ll take a look at that in this module.\nWhy do you think we would do that? Well, computer resources are very expensive. For example, think about the storage space in your computer. While you might have a couple of terabytes. If you’ve ever played video games, or downloaded a lot of videos, you’ll find that that space gets eaten up very, very quickly by those large files. And so we can use compression to reduce the amount of space that those files take up and store them in fewer hard drives than it would take to store the raw files. Likewise, we can think about transmission bandwidth across the internet. If we need to send a large file across the internet. If our internet connection is very slow, it might be better to compress the file before we send it and then allow the other user on the other end to decompress that file when they receive it. However, of course, this does create a trade off, we’re spending computation time to compress and decompress the data in hopes of saving transmission time in storage space when we actually store or transmit the file. And so depending on the amount of computational power we have, and the amount of transmission or storage space we have available, it may or may not make sense to compress data. But in general, compression is usually a good thing and helps us save more data in a smaller amount of space, and transmit lots of data very quickly across the internet.\nSo let’s take a look at one example of compression called run length encoding. In run length encoding, we’re looking for runs or repeated sequences in our data. And then we’re going to going to replace them with a shorter version of that data in our actual store data itself. Usually that shorter version would be the sequence that we’re repeating, and account of how many times it gets repeated. So let’s take a look. Here’s an example of data that we could send via run length encoding, we’re using characters and recall of course, the characters can be stored as binary values using ASCII the American Standard Code for Information Interchange. So while we’re representing this data as text, it would actually be stored and transmitted as binary on our computers.\nSo in run length encoding, we would look for repeated characters and try and replace them with shorter versions of themselves. For example, if we look at these W’s at the top, we can see that they’re an awful lot of them. So let’s count them, we have 1 2 3 4 5 6 7 8 9 10 11 12, there are 12 W’s. So in our in our data, we would say that we have 12 W, then we have one B, so we just write one B, then we have 12 more W’s. So if you count those out, there will be 12, W’s, and so on. And so with run length encoding, we would be able to count the number of each characters and put a number followed by the character that shows up. So if we encode all of this data with run length encoding, we would get 12 W, 1 B, 12 W, 3 B, 24 W, 1 B, 15 W.\nAs we talked about earlier, the characters W and B can also be stored as binary. And of course, these numbers can be stored as binary. So it should be pretty easy to figure out how we can convert this particular string of data into a binary string that we would send along with our data.\nBut there might be a problem. If we think about all of that being one long string of binary numbers, how could we tell which parts of it are the numbers and which parts of it are text. And remember, the text itself is just numbers as well. So maybe we need to come up with some sort of a scheme that allows us to structure that data so that we know where the numbers are and where the text is. So let’s take a look at that.\nHere’s that same example again, but how do you think we could write it so that we can easily tell which ones are the text and which ones are the numbers? Take a minute to think about that before you move on. A better way to think about this would be to use escape sequences. So in escape coding, what we would do is we would have a double character representing an escape sequence. For example WW; the WW being a repeated character would reduce down to just a single W. But then afterwards, we would have a number. And so looking at this bottom, we see WW followed by 12. The ww is our escape sequence saying we are going to repeat the letter W. And the next bit of binary data is going to be the number of times we repeat that character. So we see WW 12. Then we see just one B. And because B is not repeated, we just assume that that is text.\nNext, we have WW again. And since that’s a repeated character, that will tell us that we’re going to repeat W and the next bit of data is going to be binary, that is the number of times we repeat that character. So then we have WW 12. Now we have three B’s, so we have BB 3. Then we have WW 24, a single B, then WW 15. So if you look at this, that is a little bit longer than the example we saw earlier, because we have to double some of the characters. But this example is much easier to read for our computer. We know that every character is text, except if we see the same character twice. And then we will know that the eight bits after that represent a number that we could use to repeat that character that many times. So now that we’ve seen an example of run length encoding, we’re going to let you give it a try in the next quiz.\n",
    "description": "",
    "tags": null,
    "title": "Compression - Run Length Encoding",
    "uri": "/iii-topics/15-compression-error-checking/01-rle/"
  },
  {
    "content": " Resources Beocat Video Script Hey folks, today I’d like to talk to you a little bit about supercomputing. I’m Dr. Dan Andresen. I’m the director of our K-State Supercomputing center, also a professor in computer science. So if you want to see me come by my office or set up a Zoom meeting, happy to talk about this sort of thing. So supercomputing is about two things. It’s about size. And it’s about speed. And compared to your average laptop, the laptop is the teeny mouse, so it’s about two big things. And it’s about size, because many problems just can’t fit into a standard laptop or standard desktop. And see if this issue of Okay, my problem is too big for that, what do I do? You take it to a supercomputer. Or similarly, if you’ve got a big problem that just takes way too long, or you got a little problem, and you get lots and lots of them, then it’s really useful to have something that isn’t likely to go ahead and say, Oh, yeah, by the way, I’m going to restart it every couple weeks, because Microsoft pushed out a patch, or something like that. And so these are the types of problems that we do on a supercomputer because with a supercomputer, we bring the size, we bring the speed so that if you’ve got really big problems, they’re actually manageable.\nWe had one of our users, for instance, that came to me a year or two ago, and said, I’ve got a problem that’s taking too long to run. Sure. How long have you taking, like calculate is going to take 436 years? Ah, we can handle that. So anyway, we talked about it, set some students on it, we ran it on Beocat, we ran it in parallel, and we knocked down a one week problem down to 36 seconds, which is about an 81 million times speed up. And that’s the sort of thing that a) is a lot of fun. And b) it’s something that we get to do in supercomputing because we have the tools that can really take this on. So supercomputers are awesome for doing the really big problems. We use it for things like simulations and data mining and visualization. The idea is we take really big amounts of data. An average wheat genome is one and a half terabytes, for instance, a little more than your average PC can handle. Especially if you’re doing a denovo genome assembly, where you need all that in memory. Otherwise, it takes forever. So what we do is we take the big data, and we look at it and we say, hey, how can we analyze this? How can we compute with it, and come up with some really life changing stuff?\nSo for instance, tornadoes: fact of life here in Kansas. And so what happened was years ago, we couldn’t really do things at a high resolution, that’s the kind of this general idea that will maybe there might be a problem somewhere in the area. And on TV, they’d have this thing, look out everybody in this massive cone of space. Now it’s more like, Okay, if you’re in this area move. And if you’re in this area, you’re probably gonna be relatively safe. Because we’ve got more and more powerful computers, we’ve got better and better models. And because we’ve got the supercomputers that can handle it, we can start saying, hey, look, it’s worth spending $20 million on the machine, because we got to avoid evacuating Houston, which would cost billions or evacuating most of Florida, which would also cost billions. And so because we have bigger computers, and we have faster computers, we can actually do some really cool stuff.\nSo we do simulation, because a lot of times it’s either impossible, or really hard to do things in real life. You know, it’s the like the old joke about defining the universe give two examples. What do I do? I can’t. So you can either use simulation to say, Okay, let’s simulate what a universe would be like if you know, various laws were tweaked. Or there are times where it’s just too expensive. We had a professor, for instance, that was doing air purification systems. And every time she built a sample, micro engineering product, it cost about $10,000. Well, what you would do is you’d use a supercomputer to analyze electronically 10s of thousands of these possibilities, then for the ones that looked really, really promising, you’d have a sample made. Saved her millions of bucks. So the idea behind simulation on supercomputers, we can do things that otherwise we just can’t do, whether it’s for ethical reasons, or for economic reasons. Both are very, very valid. The other thing is supercomputing isn’t just something we do for science. It’s also something that really has a big impact on industry. Airlines, for instance, use supercomputers to figure out how can we optimize logistics saving about 100 million bucks a year, automotive design, again, about a billion dollars per company per year in terms of not having to do all the testing and being able to pull together and do CAD CAM, structural integrity, all this analysis that we don’t have to do physically. But it becomes something we can do digitally in a simulation, and it saves a ton of money despite being kind of expensive. I mean, to get a supercomputer it’s anything over about a million bucks or so up into the possibly hundred million dollars. If you’re a government system that really needs a big system. Semiconductor industry, same sort of things saving about a billion bucks a year. Energy, about building about two new power plants for you and those suckers are expensive, you know, 300 million up to about a billion dollars each.\nIf you go to work, for instance, for Cerner. They have the equivalent of a supercomputer they use to do virtual drugs studies, Hey, what is this impact on this drug with this drug for male patients in their late 80s, or something like that they do enough, they have enough data, they can do this analysis and say, here, here’s the impact. And it works. And it’s really has a big impact on their bottom line. And on the fact that they didn’t have to go out and do drug testing on a bunch of 80 plus year old men, because like my dad, he’s not in good, good shape for setting up a bunch of drug tests might actually hurt him. So really an important thing, both in the real world, real world, and in academia and in science. So why do we bother? Well, the big news is, you can do bigger and more exciting science. And that’s really one of the drivers today for scientific supercomputing is the fact that you can do things at a massive scale, whether it’s simulating the universe, simulating weather and hurricanes, or simulating genomes and looking for things that oh, you know, might be causing the COVID virus to be so nasty. And so you get very, very useful information out of some very, very big powerful tools. Similarly, if you’re familiar with HPC, or supercomputing, then you know, where normal computing is going.\nSo 20 years ago, Google was barely a gleam in Sergey’s eye. But on the other hand, for those of us that were in supercomputing at the time, what they were doing is like, Oh, yeah, we understand that. And so you can get ahead of the curve, and know where normal computing is going to be. And that can be a really strategic advantage. If you’re trying to figure out where am I going to go in my job, and what’s my career going to look like? So in the future, the general idea is, particularly if you start combining things like 5G networking, and the cloud and software, you can license pretty easily and the Internet of Things. And you started seeing My computer is really well, I need this sensed I need this computed on. And I need this visualized, and I need to plug in this AI algorithm to do an analysis on it for me. And then I want the output displayed in my virtual reality goggles. That’s what it looked like, we could have a great, here’s my credit card. Well, I still have it all on file already. Here’s my credit card. Here’s my budget. And let’s go ahead and rent the sort of thing. So you won’t necessarily say hey, I need to buy a $5 million computer, although you might, but you might rent one for the time that you need it and then let other people use it when they don’t just like you do today in the cloud.\nSo it’s collaborative, you work with other people. It’s dynamic, and it is really, really cool. So that’s kind of what we’re looking at for the future in terms of supercomputing, but it’s all at massive scales. So a couple of resources. A lot of these slides I get from Henry Newman, Globus Open Science grid and other things are available. Thanks for the people that let us use your graphics. And I hope this helps. If you have any questions want to talk about it. As you can tell, I like to talk about it. Get in touch\n",
    "description": "",
    "tags": null,
    "title": "Introduction to HPC",
    "uri": "/iii-topics/14-hpc/01-introduction/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "History of the Internet",
    "uri": "/ii-internet/11-internethistory/01-history-of-internet/"
  },
  {
    "content": " Resources Slides Video Script In this module, we will discuss how we can store data in our computers using various types of encoding. Recall, the computers only operate on binary values, which we’ll talk about a lot today in this lecture. And so how do we take things such as images and text and graphics and videos, and make all of those things accessible to our computer? Before we continue, let’s take a look at a few of the things we’ve covered in this class. So far, we’ve covered the work of Leibniz and his creation of the Leibniz wheel, which led to mechanical computers. We’ve covered George Boole and his approach to logic that we call Boolean logic which we use today in our modern computers. We’ve talked about Charles Babbage, the father of the modern computer and his invention of mechanical computation devices. And we’ve also talked about Claude Shannon, whose master’s thesis of using electrical circuits to simulate logic using Boolean logic is foundational to the creation of the electronic computers that we use today.\nBut there’s one more person that we need to talk about to set the stage for today, and that is George Stibitz. George Stibitz was an inventor and one of the things he was working on was the creation of a true electronic calculator. And so in 1937, he sat down and he created what he called the model K, which is named after his kitchen table. And it was a device that was capable of performing addition using two binary numbers. And this is very important because at this time, a lot of the mechanical computers of the day, we’re still using decimal or base 10 numbers like we use today. George Stibitz was really interested in performing that same mathematics using binary numbers, because he saw the value of an electronic signal with one and zero on and off being represented in binary.\nSo a little bit later, he was able to create his complex numerical calculator in 1940. And it was very unique because it could perform all of the calculations on very complex numbers using electronics, and it could also be operated remotely. And so during one of his demonstrations, he actually was in New York City and was demonstrating the device which was located at Dartmouth College in New Hampshire. And so he was talking to it via a phone line. And so not only is this really the first example of any sort of electronic machine doing large scale calculations like this, but this is also an example of one of the first remotely access computer systems. So let’s take a look at a video of the complex numerical calculator and see how it worked.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/07-encoding/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script In previous videos, we’ve talked about computers such as the ENIAC and the mark one, which were electromechanical computers and electronic computers that had hundreds of components and thousands of individually solder joints. While those machines were very powerful, a failure of any one of those components or joints could cause problems for several hours as engineers tried to solve it.\nThis problem was really best summed up by Jack Morton, the Vice President of Bell Labs. In 1957. He wrote a paper celebrating the 10th anniversary of the invention of the transistor and said the following. For some time now, electronic man has known how in principle to extend greatly his visual tactile and mental abilities through the digital transmission and processing of all kinds of information. However, all of these functions suffer from what has been called the tyranny of numbers. Such systems because of their complex digital nature, require hundreds, thousands and sometimes 10s have thousands of electronic devices.\nAll of that changed about a year later due to the work of Jack Kilby. Jack Kilby, he was born in Jefferson City, Missouri, but actually grew up in Great Bend Kansas and was trained as an electrical engineer. In 1958, he was hired by Texas Instruments to try and work on solving this tyranny of numbers problem. Based on his work, he came up with the idea of printing components directly on a circuit board that was made of some sort of semiconductor material. In that way, the joints and the components were all solidly connected together, so that you didn’t have to worry about each individual component or joint failing on the chip. This became known as the integrated circuit. Let’s take a look at another video showing Jack Kilby’s integrated circuit and what it did.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/08-architecture/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video we’re gonna be talking about software engineering. Now you should remember this particular machine the ENIAC, which was the first electronic computer in the United States. Programming the ENIAC was a really slow and laborious process though. To load a program, ENIAC’s programmers Pictured here is Gloria Ruth Gordon, and, well, later Bolotsky, and Esther Gordon would physically rewire the hardware and a new configuration corresponding to the calculations indicated by the programmers. And so you can see them here moving actually the wires from different plug boards for the computer to actually make different calculations and operations work. So the task was made even more difficult by the secrecy involved with the machine. Initially, programmers weren’t even able to see the schematics of the machine and had to pass their wiring instructions belong to the technicians. So the programmers didn’t weren’t even instructed on how the actual machine was built or how it worked. And they couldn’t even actually run their program themselves. So you could imagine that that would be a really difficult task to actually accomplish writing successful programs for a computer that you didn’t even know how it worked.\nBut this was very similar to Alan Turing’s original conception of the his famous Turing machine. And this machine had carried out hardwired instructions on data encoded as zeros and ones on an infinitely long paper tape. Turing had an epiphany with this machine, realizing that by making this machine read instructions on specific sequences of zeros and ones, as his machine booted, he could encode the program directly on the infinite tape with the data it was actually operating on. Now, this is a huge leap, because before right with this, we had a tyranny of numbers problem where the We’re just getting so complex, that it became nearly impossible to make anything substantial in today’s terms of software.\nBut now that we can actually store the actual software alongside with the data actually being used the started to simplify the process. These ideas were incorporated into electronic computers by several computer scientists, including J. Presper Eckert and John Mauchly, inventors of the ENIAC computer, as well as John Von Neumann, who was the first to publish such an article about this architecture in this paper, the first draft of a report on The Ed vac. For this reason, a computer architecture allowing for stored programs is referred to as the Von Neumann architecture, and is the basis for modern digital computers. Stored programs also allowed us to develop bootstrap code or libraries of common procedures that can be reused for future programs. And we’re loaded into the computer as it was warmed up. This is an important predecessor to modern programming libraries and operating systems. So as you can imagine a lot of these early computers, you ended up having to actually program basic operations anytime you actually wanted to work with something. So a lot of the software, a lot of things were done by hand, a lot of the things that we take for granted like user input, a lot of the mathematical operations that we use in modern programming languages, all of these libraries that we utilize to make our software a lot easier to write, and which allows them to be extremely functional and easy to read. And these weren’t existing or at least didn’t exist in a lot of the earlier software that was actually being developed. So our ability to store programs along with data and store programs, along with the actual system itself. Made a lot to future programs a lot easier and faster to write.\nBut the next major invention in software design was the development of programming languages and the associated technologies of compilers and interpreters that allowed programmers to write programs and a higher level programming language that would then later be translated into machine language for a stored program computer. Pictured here is Grace Hopper, the creator of the first higher order programming language flow Matic and influential co creator of COBOL. A very popular or was very popular business programming language. The development of programming languages is especially important in that it allowed us to develop abstractions for simplifying development of software and allowing us to express significantly more complex ideas in computer code without a significant amount of more lines of information and code that had to be made with the software.\nBut as programming languages diverse From their mathematical roots, and became more expressive, new challenges arose in making sure that programs were clear and easy to understand. This is further complicated by increasingly sophisticated nature of software that sought to accomplish more than earlier programs had ever had. Furthermore, the growing industry demand for software developers had led to often incompletely trained programmers entering the field. And so if you could even code a little bit, you probably could land a programming job. This is a pretty important turning point in the industry here because we had a rapid growth of actual technology. So not too long after world war two ended, electronic computers started to become smaller and more popular and they all of a sudden didn’t take entire rooms to actually build right they weren’t the size of school buses anymore, especially as we approached the personal computer era.\nWe needed a lot more people to actually program there was a significantly higher demand for software and the demand for that software was even greater yet as far as the functionality would actually go for that particular software. So, as a result of all this sloppy programming, poorly understood designs and really the lack of systematic planning and execution, with these poorly trained programmers led to an era of our field being labeled as the software crisis. This spurred the development of a lot of different new technologies and approaches and approaches for developing software.\nSome of the key projects from this period include the IBM O’s 360 project that ran drastically over budget while employing over 1000 programmers, and famously the fair act 25 radiation machines which would regularly display an error to their operators. So as a nurse would come in, and try to to administer a dose of radiation to let’s say, a cancer patient, they would then try redoing the treatment because there was an error on the machine on on the screen or whatever. And they wouldn’t realize that the machine had already delivered a dose of radiation, which led to a lot of patients actually dying or being crippled.\nThroughout the software crisis, a lot of important computer scientists made a lot of developments in contributions to software engineering, and one of the more important computer scientists of the day, like Edgar Dykstra and Nicolas Wirth sought to address these challenges through language design and better education for fledging budgeting computer scientists. This 1968 letter to the editor of the ACM journal by Dykstra underscores his concerns with the goto statement, which allowed for a very disjointed style of programming that would make programs difficult to debug and understand as the go to statement would allow you to jump back and forth between steps in your program without any concern for anything else. This and readability of and usability concerns as well as efficiency issues became one of the driving forces behind the evolution of programming languages. Where most currently use programming languages don’t even have a go to statement like Python, and many of the many of the other popular languages that we use today. Other improvements included the addition of modules and information hiding, introduced by David Parnas concepts that eventually involve evolved into what we refer to now as the object oriented programming languages.\nIn the same year, Margaret Hamilton, one of the NASA engineers responsible for simulating the Apollo missions on a computer. One of the most involved computer simulations attempted to that time, coined the term software engineering to describe the role she had played The stack of documents Next to her is actually one of the simulation results from that effort, which helps underscore just how large software projects were growing at that time.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/09-software-engineering/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’ll discuss the field of human computer interaction or HCI, sometimes referred to as computer human interaction, or CHI. It is the study of how computers and humans interact and how we design computers to better support humans in that efforts. HCI is one of the fields that we’re going to look at it throughout the semester, we’ll do this several times.\nThe field of HCI has a few goals that are very important for us to keep in mind. First and foremost, HCI aims to try and make the world a better place through the use of easily accessible technology. It allows us to work to understand data that is being presented to us, and it helps people interact and communicate with one another using modern technology. But Finally, and most importantly, the major goal of HCI is to give people better control over the tools, computers or machines that we’re using in our daily lives.\nSo how do we do this? Important part of the field of HCI is studying and designing and applying all the things we learn about interactions between people in computers. Sometimes we study how people interact with computers. And sometimes we have to study how people interact with other people, and how we can bring those ideas to the computer. And so to do this, we end up using results from a lot of different fields, not just computer science, but the fields of cognitive and behavioral psychology, design, Media Studies, graphics, art, music, all of these things can go into the field of human computer interaction.\nOne of the pioneers of the field of HCI is Douglas Engelbart. In 1950, Douglas Engelbart had graduated college, but really had no idea what he wanted to do with his life. And so he set out to try and determine how he could have a greater impact in the world and came up with this really interesting idea that we’ll look at in just a second. But his ideas really lead to the field of human computer interaction as we know it today. And he’s responsible for it. Large part of how we use computers, I think you’ll find it really interesting to see the things that he came up with during his time. So as we talked about Douglas Engelbart was a student in the 1950s, and was really struggling to figure out what he wanted to do with his life. And so eventually he came up with this idea for a motivation to help him work in computer interaction. So first and foremost, Douglas Engelbart decided that he wanted to make the world a better place. That’s all well and good, but you really have to understand how to make that happen. And he realized that to make the world a better place, it required a large amount of organized effort. It wasn’t anything that one person could do on their own. So how do we get that organized effort, but we have to bring together the collective intellect of all the people in the world working to solve these really big problems. That is really the key. And so Douglas Engelbart realized if that process was somehow made easier, he could effectively boost the work of every person working on all of these large Scale world problems. And that is what led Douglas Engelbart to the field of computer science and HCI. He realized that if he could make modern computers more effective, more efficient and easier to use, that that would, in effect, boost the effort or everyone working on these problems, because it would allow them to come together and harness their collective intellect to put forth organized effort to make the world a better place. So as we said, computers are really the key here and that’s what Douglas Engelbart realized.\nOne of the greatest creations of Douglas Engelbart work is the computer mouse shown here. It’s the first example of a interaction device built specifically for a computer that really revolutionized how we interact with computers. He developed the computer mouse in 1967, while he was working on the design of a computer system called the online system or in Is that we’ll look at in just a second. And he originally patented it as an X Y position indicator for a display system in a video that will take Look at he actually jokes a bit about why it’s actually called a mouse today.\nBut as we said the mouse is just a small part of what Douglas Engelbart was working on. His true work revolved around the online system or in NLS computer system that he developed. The NLS was really the world’s first modern operating system to include features such as a mouse hypertext links that you could click on a raster scan video monitor that actually gave live feedback to the user, the ability to do screen windowing, where you could have multiple things on the screen at the same time, he was able to use that system to build presentation programs that are very similar to what we do with PowerPoint today. It allowed him to organize information in radically new ways that had never been seen before on a computer system. And it even allowed for collaborative editing and messaging, very similar to the tools that we use today on the internet.\nAnd the amazing thing about this system was it was demonstrated in 1968 in what has been called the mother of all demos. Douglas Engelbart demonstrated all of the features of the online system during a single live demonstration in December of 1968. He assembled over 1000 computer professionals in an auditorium. And with double Douglas Engelbart sitting at the front at a computer console. He seamlessly demonstrated the power of his NLS system, showing new idea after new idea to these people. And he left his audience completely spellbound. And to this day, it still stands as one of the most important and most unique computer demos of all time. Oh, and by the way, he was actually using it to control a computer that was over 30 miles away. So it was done remotely. And to put this in context, remember that December 1968, is several months before we landed on the moon in July of 1969. So even though we were sending people to the moon, we’re in spacecraft that had less power than a graphing calculator. Douglas Engelbart was setting the stage for a computer lead to revolution in how people use computers today.\nThe best part about the mother of all demos is that a recording of it exists so that we can watch the whole thing even today. As we mentioned, he combined some real cool state of the art technology in this single demo. He used live video projection, he used teleconferencing and video conferencing. And for a lot of people in the audience, it was the first time they had even seen a live computer display something that we take for granted today. So on the next page, we’re going to take a look at a few short clips out of this mother of all demos, and we’ll have some short discussions about what exactly he’s showing on these clips.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/10-hci/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’re going to dive a little bit deeper into the technologies that allow the internet and the World Wide Web to work today. As we discussed in a previous video, early computer networks relied on circuit switching, where each computer had to have a direct connection to each other computer it needed to talk to. This was very cumbersome and very prone to error. And so we needed to come up with a better system for doing this.\nSo a circuit switch network works a lot like a telephone network. If you want to call somebody in New York and you’re in Los Angeles, there has to be solid wire connection between New York and Los Angeles from phone to phone to really enable that connection to work. But of course, with computers there is one major difference between how two computers communicate and how two humans communicate. Think about a phone call. When humans are on the phone, there’s almost no downtime, either one person is speaking or the other person is speaking. With a computer network, however, the communication is much more interrupted computer will send a command. And it will have to wait for some time before it receives any data back. And likewise, the sending and receiving can be much, much faster. And so with packet switched networks, instead of needing a solid connection all the time, can we just take those little bursts of data and somehow transmit them as needed, leaving the other spaces open for other bits of data to come in as well.\nThat’s really what led to the idea of packet switch networks. And this is one of the big reasons that computers and phones really need different network architectures. And it was something we realized in the 1960s. So the work of building packet switching actually lies in the work of Paul Baran. Paul Baran was a researcher at the RAND Corporation in 1959. And he worked on building computer networks or any any type of network really, that would be reliable in the case of a nuclear attack. So for example, if we want to send a message across the United States and there’s a nuclear attack somewhere in the middle, could we make sure that that message could get around the attack and still be received everywhere that it needed to be? Or more precisely, if networks went down? How could you actually get a communication across a network that was broken? So let’s take a look at a video looking at the work of Paul Moran and his creation of packet switched networking and why it was so important.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/ii-internet/12-internettech/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re going to be taking a look at the Hypertext Markup Language. This is a continuation of our previous videos where we talked about the history of the internet, as well as how the internet actually worked. Now, in those videos, we took a look at Sir Tim Berners-Lee, who invented the Hypertext Markup Language along with the web server and the technology that was used to actually serve those web pages. The first version of HTML that Sir Tim Berners-Lee released in 1990, was still a huge improvement over the content that was being served on the Internet at that time. We really had no unify language that we were able to use to distribute information on the web. HTML 1.0 brought that to light. Even though throughout the 90s, HTML was a pretty static language, meaning that our webpages were still pretty straightforward, there really wasn’t a whole lot of dynamic content. It wasn’t until Web 4.0 released and the late 90s and even into the early 2000s, where we started to make the transition to the Web 2.0 era, where we started to see a lot more social media type content, and very dynamic content being hosted on the web, like a lot of media as well. The big landmark version of HTML, HTML 4.0, was really important because this is also where Cascading Style Sheets came into play. Before, we could still style our web pages to a certain extent, but all of those styles were actually built into the page.\nCSS allows us to separate those styles into their own files, into their own language, and allows us to better compartmentalize those styles and as well apply more dynamic styling to our actual web page. This gave not just a single web page, but our entire website, more uniform styling, and it made programming that much easier. Now, in 2014, we had a big gap between HTML 4.0, and HTML5. But in 2014, HTML5 started to bring light to a little bit more of the dynamic content that is Web 2.0. Before then, we really used a lot of Adobe Flash, which was really big in the 2000s, and even JavaScript as well, to a certain extent, to create that dynamic content that Web 2.0 really needed. Around 2014-2015, when HTML5 was released, things like Adobe Flash started to be deprecated, in favor of using pure HTML. Now, HTML5 started to add the capability of adding more dynamic content. And even with the new CSS versions that we actually have, we can do a lot of the things that we would typically need JavaScript for, and do it all in plain HTML and CSS.\nAny web pages that you actually utilize today will most likely have a combination of these three technologies being used at that time. So HTML, JavaScript, or CSS in combination of. Now you don’t have to have all three of these to have an actual web page. You can do a web page or an entire website in just HTML. Without any styling, or without any CSS, you could still use embedded styling in your HTML. But most web pages are going to be a little bit more dynamic, a little bit more colorful and a little bit more streamlined, which requires the use of all three of these to make it a ubiquitous experience for the user, especially when we’re now living in a mobile era, where most people are actually browsing the web on their smartphones or their tablets. Throughout this module of videos, we’re going to be taking a look at HTML and CSS, as well as some basic JavaScript.\n",
    "description": "",
    "tags": null,
    "title": "Introduction to HTML",
    "uri": "/ii-internet/13-webprog/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script Introduction (Slides 1-3) In this course, we’re going to ask ourselves, what is computing science? It’s a really important topic that we’d like to cover throughout this course. But it’s also one that’s very difficult to understand. So when we try and understand the topics such as what is computing science, we can ask ourselves the questions: who? what? when? where? why? and how? And while I do this, I realized the question of “how” is really the best way to approach computing science. Specifically, I like to think of computing science as the study of how - how we can make things faster, better, more efficient, more accurate and more secure using computers. But that becomes a really interesting statement because we haven’t discussed exactly what a computer is.\nWhat is a Computer (Slides 4-7) So before we can look at all this “how”, let’s ask ourselves: “what is a computer?” We’re all probably familiar with the modern computers that you and I have in our homes and around us today, but is that really the best definition of what a computer is? Or is there more to it? That’s what we’re going to take a look at in this video. So to really understand what a computer is, we have to go back a little bit and look at some of the earliest examples of devices that might be considered a computer. And it turns out those devices are really wrapped up in the history of mathematics.\nSo on this slide, we see some mathematical equations, such as the equation for the exponential function, which is this long, repeated division. We can have sine and cosine and all of the trigonometric functions. We can have limits which are the basis of calculus, and we can even have logarithms which show up a lot in statistics and finance. And all of these functions are very, very difficult for people to calculate by hand. So how do we find the values of, for example, sine of 46 degrees? Using modern technology, we can find these values using some very interesting tools such as computers or calculators, but in the 1600s, they might have to use something such as this.\nThis is a book of math tables from 1619, and it gives the value of sine, tangent, secant for all sorts of different angle values. And so a table such as this might be used by engineers, mathematicians and scientists whenever they need to find these values for their work. And in fact, if you’ve taken a calculus class, or trigonometry class or geometry class, your textbooks probably had tables like this in the back of the book. And as recently as the 1960s and 1970s, engineers would have had little books full of these tables that they carried with them all the time before the rise of the modern pocket calculator. But of course, this begs the question of how do we get these numbers in these books? We don’t have computers, we don’t have calculators.\nSo how did we do it? And it turns out that that lies in the work of a lot of early mathematicians such as John Napier, who helped describe the logarithmic function, and Jacob Bernoulli, who helped describe the exponential function. And so one way that you could populate a book full these values is work with the best mathematicians at the time and have them perform all of that mathematical work. And this is important because in the 1600s, not many people had the level of mathematical training required to work with those really complex functions that we saw earlier. But of course, this is not a really great use of their time. So we tried to find ways where we could do better and easier mathematics to find those complex values.\nDivided Differences (Slides 8-10) One of those big improvements was the creation of Taylor series. If you ever take a calculus class, you’ll learn all about Taylor series. But the big thing to understand is a Taylor series is simply an infinite polynomial that expresses values of those complex functions. For example, the exponential function can be expressed as the infinite polynomial, one plus x plus x squared over two factorial plus x cubed over three factorial. And so we’ve reduced this value down to a set of individual terms. And so if we can calculate the value of each individual term and add them together, we can find the values for the exponential function. Of course, this is a little bit easier than that earlier statement, but it’s still very, very complex mathematics that would take a lot of work.\nEnter the work of Sir Isaac Newton, Isaac Newton, you’ve probably heard of lots of times in your math and science courses, and he was very impactful in a bunch of different fields. But for this particular field, we’re looking at one specific thing he created that’s not very well known, which is the method of divided differences. And so Newton’s method of divided differences allows you to find successive values of a polynomial, any sort of polynomial that you can create, including these infinite polynomials for Taylor series. You simply cut them off at a particular value, and then you use that polynomial and Newton’s method of divided differences to find those values that you would place in a book. So let’s look at an example of Newton’s method of divided differences to see how it works.\nTo understand Newton’s method of divided differences, we have this example with a polynomial: two x squared minus four x plus three. Then we’ve created a table below, where we have the first column that gives values of x and the second column that gives values of the polynomial applied to that value of x. So for example, if we put x equals zero into the polynomial, we’ll get the value three. If we put x equals one in the polynomial, we’ll get two minus four plus three, which is one, and so on. So we can populate the first few values in this polynomial column very easily using simple mathematics.\nOnce we’ve got a few of those values, then we can build this first differences column. And so the differences column will take the value of the polynomial at one minus the value of the polynomial at zero, and so we’ll have one minus three, which will give us negative two. Likewise, for the next value, we’ll take three minus one, and we’ll get the value two. And so we can do that to fill out the first few values in this difference column.\nAnd then we’ll do it again to make a second difference column. So here we have two minus negative two, which is for. And what Newton realized is if you do this enough times, you’ll eventually reach a column where all the values will be the same. And you have to do that for each order of the polynomial. So this is a polynomial of order two. So that means we need two division, or two difference columns to get to this column, where all the values will be the same. So now, once we know that this column is four, we can put in four for each of these values.\nAnd then we can use those to work forwards through the table to find other values of the polynomial. So now to fill out this value right here, we can do four plus two, and we’ll get six. Then we can do four plus six to get 10 here, then we’ll do four plus 10 to get 14, then we can work forward again and fill out the polynomial column where we have six plus three is nine. 10 plus nine is 19, and 14 plus 19 is 33. There we go. That’s how you do Newton’s method of divided differences.\nThis slide shows a completed table that is a little bit easier to read. And we can see that we got the correct values. Now this method of divided differences does have one major issue, and that is it’s very susceptible to human error. For example, what if we add four plus six and instead of getting 10, we get 11. Then what happens? Well, if we do four plus 11, here, we’ll get 15 instead of 14. Then if we do six plus three, we get 9, 11 plus nine, now we will get 20 here. And then likewise, if we do 20 plus 15, instead of 33. We will get 35. And so as you can see, by making one small error right here, we’ve actually made all of the subsequent values in the table invalid. And that’s the real problem with Newton’s method of divided differences. As soon as you make one error, it invalidates everything after it. So while it’s a very powerful tool, it still has a big weakness.\nCharles Babbage (Slides 11-12) And the real idea is how can we solve this weakness. And that was of interest to Charles Babbage. Charles Babbage was an inventor and a mathematician in England in the 1800s. And he was really interested in creating ways that we could perform these repeated calculations without the risk of human error. And he decided that it was possible to build a mechanical device that could perform these mathematical operations completely, repetitively without any error. And during his lifetime, he actually built a small prototype of this device that he called The Difference Engine, and he built blueprints for a much larger scale version of it, but that version was never actually completed during his lifetime. A few years ago, those blueprints were in the possession of a Computer History Museum and they decided to try and build a device based on his blueprints and see if it would actually work. And surprisingly enough, it totally worked. So let’s take a look at a video of that completed Difference Engine that was built by a Computer History Museum and see how it works.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/01-what-is-computing-science/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script Today we’re going to be learning about historical computing machines. Now, computers like we know today with your electronic laptops and cell phones and everything aren’t just electronic, but really anything that can compute a value, whether it be mechanical, electrical, or even biological. What we’re looking at here is a piece of what is considered one of the oldest computing machines that we know of the Antikythera mechanism. It was discovered in 1900 off the coast of a Greek island called Antikythera and really is puzzled scientists for quite some time. It was believed to have originated around 100 BCE, but little was known about its origin. But however, from the detailed gears and inscriptions on the piece itself, we can actually deduce what it is actually used for. As you learned in the video, the Antikythera mechanism was an early computer used to calculate the position of the sun, moon and planets in the sky, as well as important dates and eclipses. Now, after this period of time, it wasn’t until the 14th century that mechanisms of this complexity were ever seen again, though this was completely beyond its time in terms of technology.\nThe Abacus is another early example of a competing machine that you’ve probably seen and heard of, or maybe even used. They’re now used a lot as a children’s toy. But this is an example of a Chinese Abacus. With a little bit of technique and training, this device allows the user to perform addition, subtraction, multiplication, division, and even the calculation of squares and cube roots at pretty high speed once you get used to it. But even with that, this machine still has a still has some room for human error, which is really what the the crutch of a lot of these devices are.\nBut moving forward a few hundred years, in the early 1600s, the slide rule was invented. It uses a sliding set of logarithmic scales, and allows the user to calculate all sorts of values from simple multiplication to logarithms and even trig functions. And for students studying engineering through the 1960s it was the tool of choice for those calculations needed until the calculator or the electronic calculator started to catch on and become small enough and useful enough for it to pretty much overtake everything else that we have used so far. Even though the slide rule is this simple device, it was used for even things like the Apollo 13 launch and if you’ve ever watched Apollo 13 before you can kind of see through this particular clip of the slide rule being used to verify some calculations.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/02-early-computing-machines/02-introduction/"
  },
  {
    "content": " Resources Slides Video Script In this video, we’re going to take a look at computer programming languages and some of the history that’s behind them. First off, what exactly is a language. Something that we don’t really think about very often though. A language really is just a set of symbols, whether it be gestures, words, sign language, or even Braille, that are used in a uniform fashion to allow people to communicate with one another. We have to take a look at how we as humans can communicate with a physical or inanimate object: a computer. In order for us to tell computers what to do, we had to develop a language that we could use to communicate with it. Here on my slide I have on the left a bunch of different ways on how to say good morning, in various human languages that we use to communicate with with one another. And on the right side here we have a bunch of computer languages that we have. So the first one up here is happens to be Python 2, Python 3, C, Java, JavaScript, and even Rust. And so this is just a small number of different things that we would be able to use to communicate this particular message to our computer. Just likewise, we have a lot of different ways we could say good morning to someone.\nLet’s take a look though on where the idea of a computer language actually started to originate from. Ada Lovelace is our first influential woman in computer science that we’ll talk about. She is regarded as one of the first figures in history to truly understand computer programming, possibly only second to Charles Babbage. Ada Lovelace was the daughter of a famous English poet. Lord Byron, who I’m sure you’ve heard about before, but she had very little contact with her dad pretty much at all, and during her childhood, she was pretty much on her own. But during that period due to her father status, she was tutored by some of the greatest mathematicians of that time, including Augustus de Morgan, remember from the Boolean logic lecture, had the De Morgan’s theorem. And so she was already being tutored by some of these great mathematicians who were laying the groundwork and the foundations for what we use in computer science. One of the… one of the greatest quotes from from Charles Babbage, who he was talking about Ada Lovelace with. So, Charles Babbage said that Ada Lovelace was that “Enchantress who was thrown her magical spell around the most abstract of sciences and has grasped it with a force few masculine intellects could ever have exerted over it.” So this is a really big compliment from Charles Babbage, who was pretty much the pioneer in computer science at the time.\nAda Lovelace spent a lot of time visiting Charles Babbage and she was so intrigued by his Difference Engine that he had in his house, the prototype that he had made. But her goal in visiting with Charles Babbage so much is that she started to translate his work into English so she could bring it back to England, and explain how it worked and why it was so important and revolutionary. And to assist with that she included a set of notes with her own descriptions of the design of his Difference and Analytical Engines and how they actually worked and when completed her notes are actually longer than Charles Babbage’s memoir. She has so she had a very deep understanding on how Charles Babbage’s machines actually work.\nWhat makes Ada Lovelace so unique in the history of computing is Section G here in her notes. in that section she describes in complete and utter detail how you would use Babbage’s analytical engine to calculate a sequence of numbers called the Bernoulli numbers. You’re probably also familiar with. But while it appears to be written in English, it’s actually designed in a way that can be directly used by the Analytical Engine. So, in a way, you could say that it is in a language that the analytical engine would understand. And in doing so, she wrote the first computer program, which is simply, right, a series of steps specifically designed in such a way that could be easily ran on a computer.\nThere is some debate as to whether or not she wrote some of the programs she was previously attributed to. But there’s little doubt in the fact that she would be capable of doing so. In fact, she was one of the few people who saw the true potential of what Babbage had actually created. And she’d once remarked that under the correct circumstances, it could be used to create music. So the Analytical Engine she was talking about here. And that’s really quite extraordinary, something that Babbage probably hadn’t thought of at the time. But if you are a musicphile at all, music, right is just simple mathematics. And so if you have a machine that can compute mathematical values, why wouldn’t it be used to create music? So all told, Ada Lovelace is really truly a very important person in the history of computing science. And she’s widely regarded as the world’s first true computer programmer. And as a as another bonus side note here, she’s actually credited with discovering the first bug in a computer program as well. A bug. In fact that was found in a program that was written by Charles Babbage.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/04-programming/01-introduction/"
  },
  {
    "content": " Resources Slides Video Script Welcome back, everyone. In today’s video, we’re going to be talking about universal computers. Now to pretty much pick up where we left off a while ago when we were talking about Boolean logic, Claude Shannon had just proposed a way to take electrical circuits and represent any Boolean logical statement with them. And so this was a huge turning point in the history of computer science. But how did we make the leap from Boolean logic on electrical circuits to the modern computers that we have today, and we’ll talk a little bit about that gap here today, but there will still be some missing parts that we’ll talk about later. But this brings us to Herman Hollerith, who at the time was a United States Census office employee, and he was tasked with coming up with a better way to calculate the census result. Because at the time, calculating the US census was incredibly slow. The 1880 census alone took eight years to tabulate, which really kind of defeats the purpose of a census, right? If you only know how many people you have in your country, eight years after the fact, the census was actually taken.\nAnd so 10 years later, Herman had actually implemented a new system. And so in 1890, when he tabulated the US Census, then it only took one year to complete versus the eight years from the 1880 census. And this is even taking into account the 30% increase in population over that decade, which is pretty impressive, to say the least. So how did he do it? Well, just as Joseph Marie Jacquard had discovered, punch cards are really great way to organize and calculate information, particularly when you want that information to be read and used by machines. And so Hollerith was inspired by this fact. But really, actually, he was inspired by the way railroad conductors would actually use punch cards to track the gender and age and so forth from people buying tickets for the railroad. So not only did Herman Hollerith develop a new punch card in order to track US Census data, he also developed a machine to actually read it.\nSo this is an example of a Hollerith tabulating machine that was used in the 1890 census. So this machine could read the card and tabulate all of the information that was on them, and was also advanced enough to actually infer other facts and keep track of things like the number of married men and women. And depending on the data on the card, there is a compartment down you can kind of see towards the bottom right hand corner there. That was a storage box, for the cards and so depending on what kind of data was actually on the cards, a compartment in this storage box would open. So the operator that was using the machine could take the card from the machine and put it in the corresponding box. So essentially right it was auto sorting all of the census data, which was also pretty cool. But Hollerith continued to improve his designs and created several upgraded machines that could tabulate all sorts of data, not just census and donation, he would go on to create his own company, the Tabulating Machine Company, and a couple decades later, his company would join several under under a new name the Computing Tabulating Recording Company. But this was eventually renamed to be something else, the International Business Machines company, right. And many of you all know this company as IBM. Pretty cool, right?\nThis is something that I learned when coming to computer science, I had no idea how IBM got their start, but tabulating machines is pretty much where they come from. Now, this particular image from this slide is from the US Social Security Administration in 1936. This shows several IBM tabulating and sorting machines in use. And so they use these for all sorts of things as time progressed, and each one was able to keep track of all sorts of different kinds of information. One example could be tracking the sales of a particular person or company for the purpose of billing, right, or tabulating sales, and inside of a convenience store or something like that. Does all sorts of things, right. So things that were traditionally done on pen and paper or pencil and paper, and prone to a lot of human error. We could feed these punch cards through these machines and they would auto tabulate everything. For us, and they were pretty popular all the way through the 50s and 60s, until the computer started to take over really, but this pretty long time, right? About 30 years or so, for these tabulating machines, as they kind of took their grip. But we’ll talk a little bit here in just a second about the actual first computers that we actually had in the United States. But just as a quick little fun fact, we’ve talked briefly in a previous video How pretty much took a country torn by war before we actually started, or the world torn by war, really. Before we started to get a lot of advancements in computing technology. IBM was actually involved with selling these tabulating machines to the Nazi Party in Germany and may have inadvertently aided their attempts to catalog and later persecute the Jews. During the Holocaust, so a little bit of dark history behind IBM and their tabulating machines.\nBut anyways, let’s talk about the some of the early major computers that we actually had in the US. So, first and foremost, the mark one, the mark one that was really important because we started to see a shift from pure mechanical computers or computers like tabulating machines to something that was a little bit more flexible, a little bit more powerful, as far as what type calculations that could be done. But the mark one was an electromechanical computer, and it was the largest of its type ever built. And its main purpose was actually to aid in the calculating ballistics tables that were needed by the gunners to accurately aim and fire weapons that were being developed for the war because to try to stay ahead, the US was developing weapon at an alarming rate. And the time it would take about 20 hours for a skilled mathematician to analyze a single 60 second trajectory shot. This is way too slow at the pace that weapons are actually being developed. And so the mark one was completed 13 years after it was commissioned in 1944. And proved to be pretty useful, right. So this is also remember back with Grace Hopper when we talked about her. This was the computer that she was commissioned to work on by the US Navy. So then let’s chat about the kind of the next step up right. So the mark one was an electro mechanical computer, which had tons of parts, right. Five tons of computer if you can imagine that. And one little But the fun fact that I always like to emphasize here is that the mark one had five horsepower. Right? So it actually had an engine their in order to run it. So if you can kind of imagine having a laptop that had an engine in order for it to actually work kind of crazy to think about that your computer has horsepower.\nBut we did take a big leap forward after the mark one was completed. So in 1943, the US Army and the University of Pennsylvania began working on a project that would be the successor to the mark one called the electrical numerical integrator and calculator or any ENIAC right. Scientists like acronyms, and sometimes they’re pretty good. Sometimes they’re not so great. But when the ENIAC was completed in 1946, it turned out to be about 1000 times faster than the mark one. But the ENIAC was so revolutionary. because it was the first all electric programmable computer that was truly general purpose. And we’ll talk about that here in just a little bit. But remember how we were talking about the Difference Engine that Charles Babbage created that was truly are the Difference Engine number two in the analytical engine that were truly general purpose computers, right. And so now we have the first all electric computer compared to the mark one, which still had a lot of the mechanical parts right had five horsepower. But the ENIAC ran almost continuously from 1946 to 1955. So had a pretty good long, long term operation here. Again, right had an insane number of parts right over 17,000 vacuum tubes that were used to run at 70,000 resistors, 10,000, capacitors and over 5 million hand soldered joints. If you have a hard time trying to figure out what’s wrong with your computer Now, imagine trying to debug and fix a computer that had so many different moving parts or so many different hand soldered parts is really kind of crazy to think about. But we’ll bring up the neck and the mark one and another lecture as well.\nBut I do kind of want to highlight a really big important part during this time frame, right? During the mark one and the ENIAC because remember, this is during World War Two, where a lot of the men were overseas fighting the war. And so a really far less known fact in computer science right? Early computer scientists were all women. So in the early days of computer science, the mark one ENIAC the majority of these machines and computers were being serviced, programmed and ran by women during the war. There’s this awesome documentary called the Top Secret Rosies, I would highly recommend watching the entire documentary. I’m sure you could probably find it streaming online somewhere. But this particular clip that I will show here in just a little bit, is just kind of a summary of the role of these women played during World War Two\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/05-universal-computers/01-introduction/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Weird Truth About Arabic Numerals (SciShow)",
    "uri": "/i-concepts/06-algorithms/02-arabic-numerals/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Top Secret Rosies",
    "uri": "/i-concepts/05-universal-computers/02-top-secret-rosies/"
  },
  {
    "content": " Resources Slides Video Script Introduction (Slide 1-2) For this lesson, we’re going to be talking primarily about Boolean logic, Boolean algebra and how that plays into computer science and the foundations of how important that is and the role it plays and what we do. So before we get started, and before we can talk about things such as Boolean logic, we need to know where it came from. That leads us to Aristotle, way back in the 300 BC, as you may know, right Aristotle is one of the fathers of modern philosophy and logic among many other things. He studied under Plato, who himself was taught by Socrates and was also the teacher of Alexander the Great, so pretty much affected the entire world of Western philosophy that came after him. One of his major contributions was this idea of using formal logic to prove a point, then this form of logic, also known as Aristotelian logic, a point is proven based off of a series of premises.\nAristotelian Logic (Slide 3) For example, in this form of logic, we can present a series of facts. And so our premise here in that sense, all humans are mortal. Socrates is human. Each one of these is a fact and pretty easily proven to be true. Now, under Aristotelian we can use these use this premise to then prove a new fact. So if all humans are mortal, which is true, and Socrates is a human, which is also true, we can also prove or conclude that Socrates is also a mortal.\nBoolean Logic (Slide 4]) If we skip ahead a few thousand years later, we come to George Boole. In 1854, he published a book called An Investigation of The Laws of Thought, in which he tried to apply the rapidly growing field of mathematics to the laws of logic. His goal was to reduce something as complex as logic to simple mathematical equations. And with the right rules in place, even a complex logic Statement could be completely proved, or even disproved using the same algebraic techniques they used to understand other parts of the world.\nAnd so if we take a look at an example, our same style of facts that we had before now transcribed into something that is more easily represented in algebra or mathematics, so for example, if we take are all humans are mortal and Socrates is a human, we can map that to different variables. And you can kind of imagine different kinds of facts being transcribed here where we can substitute proven facts or true facts in places of a and b and c, we can conclude new facts or new premises or new things from that. So if A and B so the upside down would be their means and we’ll talk about that here in just a little bit. But if both A and B are true, and B and C are true, we can conclude that A and C is true. Since A and B are true, B and C are true, then A and C must also be true. But this translation is somewhat flawed but we can leave that for a later course in logic or philosophy to describe why …but let’s take a deeper dive into what each of these mean so primarily Boolean operators Boolean values and what that means for Boolean logic.\nBoolean Values (Slide 5) As you know from the reading computers operate primarily using only binary values so ones and zeros and Boolean logic and Boolean algebra operate off of true and false principles or yes no answers but that in itself is a binary decision there is no in between. So we can easily translate binary and Boolean logic back and forth. Commonly speaking, one is going to mean true and zero is going to mean false. Now, this is the same thing is translated in a variety of other contexts, like electrical systems where a on or off signals being produced one or on meaning electrical current, or off or zero. meaning no electrical current. So while these are traditional representations in many electrical and programming contexts, these values can be reversed for a variety of reasons. And really the moral of the story here is make sure you know which one you’re working on.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/01-introduction/"
  },
  {
    "content": "Chapter 0 Introduction Welcome to the Computer Science Introductory course!\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/00-introduction/"
  },
  {
    "content": "Part I Computer Science Concepts The basic building blocks of computer science theory and programming, along with a bit of history!\n",
    "description": "",
    "tags": null,
    "title": "CS Concepts",
    "uri": "/i-concepts/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "IC Invention (Integrated Circuits - Jack Kilby)",
    "uri": "/i-concepts/08-architecture/02-ic-jack-kilby/"
  },
  {
    "content": " Notes About This Selection The director of the Computer Science Museum’s Babbage Project demonstrates how Charles Babbage’s Difference Engine #2 works. While Babbage himself was not able to build the machine in his lifetime, a modern builder created it according to Babbage’s instructions. Through this creation, computer scientists have been able to prove that the Difference Engine works exactly as Babbage intended!\nReference WIRED. (2008, May 2). Babbage’s Difference Engine No. 2 [Video]. YouTube. https://www.youtube.com/watch?v=0anIyVGeWOI\n",
    "description": "",
    "tags": null,
    "title": "Babbage's Difference Engine",
    "uri": "/i-concepts/01-what-is-computing-science/02-babbage-diff-eng-num-2/"
  },
  {
    "content": "Part II The Internet A fundamental part of today’s world! Let’s learn how it works, and how we can write webpages ourselves!\n",
    "description": "",
    "tags": null,
    "title": "The Internet",
    "uri": "/ii-internet/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "AT\u0026T Archives: Invention of the First Electric Computer",
    "uri": "/i-concepts/07-encoding/02-att-first-computer/"
  },
  {
    "content": "Part III Computer Science Topics An overview of some of the most important topics, research areas, and cool ideas in computer science!\n",
    "description": "",
    "tags": null,
    "title": "CS Topics",
    "uri": "/iii-topics/"
  },
  {
    "content": " Resources Slides In theory, a dictionary is very similar to a list in Python - it is a data structure that can store many different items within a single variable. However, instead of just storing single values as elements and assigning them sequential indexes, dictionaries store a number of key-value pairs. A key is any value that can be used as a unique identifier for the associated value to be stored in the dictionary.\nFor example, we can use a dictionary to store the “score” for various words in the game of Scrabble. In this case, our key would be the word stored as a string, such as \"test\", and the value would be an integer representing the score, 4. These two items make up a key-value pair (\"test\", 4) that can be stored in a dictionary.\nThere is one major rule that dictionaries must follow - each key in a dictionary must be unique. Or, put another way, if the dictionary already contains a value for a given key, and we try to add another value that uses the same key, the first value will be overwritten. So, we must be careful and make sure that the keys we choose to use are indeed unique so that they will work in a dictionary.\nCreating a Dictionary Dictionaries in Python can be created in much the same way as a list. We can create an empty dictionary using a set of curly braces {} as shown here:\ndict_1 = {} We can also create a dictionary that contains some initial key-value pairs by placing them inside of the curly braces. Each key-value pair is separated by a comma , with the key provided first, followed by a colon : and then the value. Here’s a brief example:\ndict_2 = {\"a\": 1, \"b\": 2, \"c\": 3} In this dictionary, the keys are the strings \"a\", \"b\", \"c\", and each one is associated with the values 1, 2, and 3, respectively.\nFinally, to make it a bit easier to read our code, we can also reformat the code to create a dictionary across multiple lines, with each key-value pair shown on its own line as seen in this example:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } This dictionary associates various animal species with the common name of their classification within the animal kingdom.\nAdding Items to a Dictionary We can also easily add new items to a dictionary by simply providing a key inside of square brackets [] and then using an assignment statement to assign that key a value. Consider this example:\ndict_1 = {} dict_1[\"Kansas\"] = \"Topeka\" dict_1[\"Nebraska\"] = \"Lincoln\" dict_1[\"Missouri\"] = \"Jefferson City\" Here, we start by creating an empty dictionary, and then we can add key-value pairs using the names of states as the key and the state’s capital city as the value.\nnote-1 Notice that we use square brackets [] to access individual items in a dictionary, just like with lists, but we use curly braces {} to create a dictionary. This can cause confusion for many new Python programmers. So, pay special attention to the syntax of each data structure, and remember that it can sometimes be difficult to tell whether a data structure in Python is a list or a dictionary without reading the code to see where it was created.\nAccessing Items in a Dictionary Once a dictionary contains items, we can access the value associated with a given key by providing that key within square brackets [] after the variable storing the dictionary. Here’s an example of what that looks like in Python:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } print(dict_3[\"cat\"]) # mammal As we can see, we’re able to provide the key \"cat\" and then access the associated value \"mammal\" that was stored in the dictionary.\nWhat if we try to access a key that doesn’t exist? In that case, Python will raise a “KeyError” and the program will crash. So, we’ll have to be careful and make sure we only try to access keys that are actually stored in the dictionary, unless we are using them in an assignment statement to add a new key-value pair.\nUpdating Items We can also update the value associated with a given key in a dictionary using an assignment statement, as shown here:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } dict_3[\"cat\"] = \"feline\" print(dict_3[\"cat\"]) # feline In this example, we are simply replacing the value for the key \"cat\" with a new string “feline”. Remember that the keys in a dictionary must be unique, so if we try to add a new value using the same key, it will simply overwrite the existing value associated with that key.\nDictionaries in Python Tutor To really understand how dictionaries work in Python, let’s go through a quick example using Python Tutor. Consider the following Python program:\ndef main(): base = int(input(\"Enter a whole number: \")) powers = {} for i in range(6): powers[\"{}^{}\".format(base, i)] = base ** i print(powers) main() This program will ask the user to provide a number as input, and then it will populate a dictionary where the key is a string representing a mathematical expression including that number, and the value will be the result of that expression. Let’s trace through this program in Python Tutor. As always, you can copy and paste the code in the tutor.py file in Codio, or click this Python Tutor link to open it on the web.\nWhen we start tracing the program in Python Tutor, we can skip ahead until it reaches the first line of code in the main() function, at which point we’ll see this state:\nThis first line of code asks the user to input a value. For this example, let’s assume the user inputs the string \"3\". So, we’ll store the integer value $3$ in the base variable as seen here:\nThis line will create an empty dictionary in the powers variable. Just like lists in Python, a dictionary is actually stored in the objects area in memory, and the variable is simply a pointer, or reference, to the location in memory where the dictionary will be stored. So, after we execute that line of code, we should see this state:\nAt this point, we reach the for loop. This loop will iterate $6$ times, so we’ll start by storing the first value $0$ in the iterator variable i and then entering the loop:\nInside of the loop, we see a single line of code that is pretty complex. This line will actually perform three different operations! First, it will generate a string using the string format() method, which will become the new key that is added to the dictionary. Then, it will compute the value of the base variable raised to the power of i. Finally, it will store that computed value in the dictionary associated with the newly created key. Once all of those steps are complete, we’ll see a new item in the dictionary as shown here:\nIn Python Tutor, we can see the key for the item on the left, and then the associated value on the right. So, it is similar to how a list is represented, but instead of just showing the index, it will show the key and the value.\nAt this point, our program will loop back to the start of the for loop. Since there are more iterations to complete, we’ll update the iterator variable i to $1$, and then enter the loop again.\nOnce inside the loop, we’ll add another item to the dictionary, and then loop back to the top.\nFrom here, hopefully it is clear what the rest of the program will do. Each time we enter the loop, we’ll generate a new key and value pair to add to the dictionary. So, let’s skip ahead to the end of the loop.\nAt the end of the program, we’ll print the contents of the dictionary to the terminal. Just like with lists, Python will print dictionaries in a clean and easy to understand format, as shown in the output in Python Tutor:\nA full animation of this program is included below.\nAs we can see, dictionaries in Python work very similar to lists. When we create a dictionary, it is stored in the objects area in memory, and we can easily add, access, and even print the contents of a dictionary in our code. Dictionaries are really one of the most flexible data structures available in Python.\n",
    "description": "",
    "tags": null,
    "title": "Python Dictionaries",
    "uri": "/x-cis115-labs/14-dictionaries/01-python-dictionaries/"
  },
  {
    "content": " Resources Slides To create a nested loop in Python, we can simply place a loop structure inside of the block of statements that is repeated by another loop structure. This is very similar to how we can nest conditional statements as well.\nFor example, consider this short Python program:\ndef main(): i = 1 while i \u003c 10: j = i while j \u003c 10: print(\"{} \".format(j), end=\"\") j = j + 1 print(\"\") i = i + 1 print(\"Complete!\") main() In this example, we see a Python while loop that uses the variable i in its Boolean expression first, and then inside of that loop we see another loop that uses j in its Boolean expression. When we run this code, each time we execute the steps inside of the outer while loop, we’ll have to completely go through the inner while loop as well. It can be very complex to keep track of everything, but with a bit of practice we’ll learn some strategies for mentally working through loops.\nBefore continuing, take a look at that program’s code and see if you can determine what it will print!\nCode Tracing Example To really understand how a set of nested loops work, let’s go through a code tracing example using Python Tutor. To follow along, place this code in the tutor.py file in the python folder on Codio, or click this Python Tutor link to load Python Tutor in a web browser.\nWhen we first load this code in Python Tutor, we should see the following state:\nWhen we look at the bottom of the Python Tutor page, we’ll see that we are on step 1 of 187 steps! That’s a very large number of steps to deal with! Up to this point, most of our programs have been around 20 or 30 steps in total. So, already we’re seeing that nested loops can quickly create programs that execute many more steps.\nIf we click next a few times, we’ll see Python Tutor find the main() function definition, and then call that function from the bottom of the code. By the time we’ve entered the main() function, we should be at this state:\nHere, we are setting up the iterator variable i that is used for the outermost loop. So, we’ll store the value $1$ in i and then move to the next line:\nNow we’re at the start of our outer while loop. That means that we’ll need to evaluate the Boolean expression and determine if it is True or False. In this case, we can see that i \u003c 10 will evaluate to True, so we should enter the loop.\nOnce we are inside the loop, we’ll start setting up the iterator variable j for the inner loop. In this code, we are storing the current value of i in j, so at this point j will also contain $1$.\nAt this point, we need to decide if we should enter the inner while loop. So, once again we’ll look at the Boolean expression, j \u003c 10, and see that it is also True and we should enter the loop.\nInside of the inner while loop, we’ll perform two actions. First, we’ll print the current value of j to the output, but we won’t move to the next line since the end parameter is set to an empty string in the print() function:\nThen, we’ll increment the value of j by $1$ before looping back to the top of the innermost loop:\nNotice that when we reach the end of the innermost loop, we jump back to the beginning of that loop, NOT to the beginning of the outermost loop. This is an important concept to learn - since we are only dealing with the inner loop at this point, we must continue to repeat its steps until the Boolean expression evaluates to False. So, since the Boolean expression j \u003c 10 still evaluates to True, we should enter the loop once again.\nInside the loop, we’ll print the current value of j to the same line of output as before:\nAnd once again we’ll increment the value of j by $1$ and jump back to the top of the innermost while loop:\nHopefully at this point we have a pretty good idea of what each step of the innermost while loop does. It will simply print the value of j and increment it by $1$, repeating those steps until j is greater than or equal to $10$. So, once the inner while loop terminates, we’ll see this state:\nWe jumped from step 13 to step 35 just to complete the inner while loop. Finally, at this point we’ll print an empty string, which will move our output to the next line, and then we’ll increment the value in i by $1$ before looping to the top of the outer while loop:\nNow we must check to see if we should enter the outer while loop again by checking the Boolean expression i \u003c 10. Since that evaluates to True, we’ll enter the loop a second time.\nInside the loop, we’ll reset the value of j to be the current value stored in i, which is now $2$, and then we’ll reach the inner while loop:\nHere, we can evaluate the Boolean expression j \u003c 10, which is currently True, and determine that we should enter the inner while loop.\nInside the loop, the code hasn’t changed, so we can use our understanding from before to quickly figure out what this loop does. It will print the current value in j and then increment j by $1$, so we’ll end up at this state:\nAt this point, we can easily assume that the inner loop will do pretty much the same thing as before - it will print all of the values from i up through $9$ to the output, all on the same line. So, once the inner loop has completely finished, we’ll see the following state in Python Tutor:\nWe were able to quickly jump from step 42 all the way to step 64 just by understanding what the inner loop is doing and extrapolating from our previous experience. Now, we can finish up this iteration of the outer loop by printing a newline and then incrementing i by $1$, and then we’ll be back at the beginning of the outer while loop:\nAt this point, we’ve completely worked through two iterations of the outermost while loop, including two complete executions of the innermost while loop. So, we’re at a good point to make a prediction about the output of the program as a whole, without executing the next 120 steps. It looks like the inner loop will print the values from i through $9$ on a single line, and then each line will start with the value of i being incremented by $1$ each time. So, overall, we can expect the entire outer while loop to produce the following output:\n1 2 3 4 5 6 7 8 9 2 3 4 5 6 7 8 9 3 4 5 6 7 8 9 4 5 6 7 8 9 5 6 7 8 9 6 7 8 9 7 8 9 8 9 9 And, indeed, if we jump ahead to the last line of the program we’ll see exactly that situation in Python Tutor:\nThe program ends by printing the string \"Complete!\". At the end of the program, we’ll see the following state:\nA full animation of this process is shown here. After the first full iteration of the outer while loop, the rest of the internal steps are omitted and only the end of each loop iteration is shown.\nWorking through an example program such as this one is a great way to explore how nested loops work in Python\nTips for Nested Loops Writing code that has nested while loops can be quite tricky, as there are several pitfalls that we might encounter. Here are a few tips to keep in mind when designing code that uses nested while loops:\nTry to understand the relationship between each loop’s Boolean expression. If possible, use different variables in each one. It is easy to write code where the Boolean expressions are closely related, causing an infinite loop to occur. Consider moving the internal loop to a separate function. That way it can be tested independently by calling the function directly elsewhere in your code. Look for ways to combine the nested loops into a single loop if possible. While this may not always be an option, it can make reasoning about the code much simpler. Try to make the loops as simple as possible. It is much easier to debug loops that use a simple iterator that increments regularly instead of a complex Boolean expression. Likewise, try to build loops that either both increment or both decrement the iterator variable to maintain consistency. Nested loops present a very difficult challenge for programmers, because they are short snippets of code that may end up resulting in hundreds or even thousands of individual steps to be executed. So, anything we can do to make the loops simpler and easier to understand will greatly improve our ability to write programs with fewer bugs.\n",
    "description": "",
    "tags": null,
    "title": "Nested While Loops",
    "uri": "/x-cis115-labs/12-nested-loops/01-nested-while-loops/"
  },
  {
    "content": " Resources Slides The first collection we’ll review in Python is the list. A list in Python allows us to store many individual values, or elements, in a single variable. To keep track of the elements, each one is assigned an index, which is an integer that uniquely identifies the element’s position in the list. In Python, just like in many other programming languages, the indexes begin at $0$ and count up from there.\nCreating a List There are many ways to create a list in Python. The simplest is to simply use an empty set of square brackets [] to represent an empty list, and then store that in a variable using an assignment statement:\nlist_1 = [] If we know what values we want to store in the list, we can include them inside of the square brackets. For multiple items, we can separate them by commas:\nlist_2 = [1, 2, 3] We can store any value in a list, including strings, numbers, Boolean values, and even other lists. We won’t cover lists inside of lists in this course, but it is important to know that it can be done.\nAdding New Items to a List Once we’ve created a list, there are two ways to add items to a list. First, if we want to add a new item to the list and expand it’s size by one, we can use the append() method. For example, we can start with a list containing three items and then add a fourth item:\nlist_2 = [1, 2, 3] list_2.append(4) Accessing List Items To access existing items in a list, we can use the index of the item inside of square brackets after the name of the list. Consider this example:\nlist_2 = [1, 2, 3] print(list_2[0]) # 1 print(list_2[1]) # 2 print(list_2[2]) # 3 The list stored in list_2 initially contains the items 1, 2, and 3. To access the first item, we can use index $0$, as in list_2[0]. We can similarly use index $1$ and $2$ to access the other items.\nUpdating List Items We can also use the index to update a value stored in a particular location of the list. In effect, each location in the list can be treated just like a variable in an assignment statement.\nlist_2 = [1, 2, 3] list_2[1] = 5 print(list_2) # [1, 5, 3] In this example, we are replacing the value 2, at index $1$ in the list, with the new value 5. As we can also see in that example, we can even print an entire list at once in a print statement!\nLists in Python Tutor Thankfully, tools like Python Tutor make it very easy to work with lists in Python and understand what is happening in memory on the computer itself. Let’s walk through a brief example program that includes lists in Python Tutor:\ndef main(): sums = [] total = 0 for i in range(1, 5): total = total + i sums.append(total) print(sums) main() As always, we can copy this code to the tutor.py file in Codio, or click this Python Tutor link to open it in a web browser. We can skip ahead a few steps to the point where the execution pointer enters the main() function and we see this state:\nThe very first line of code in the main() function will create a new list and store it in the sums variable. So, when we execute that line of code, we’ll see some new information appear in the frames and objects area in Python Tutor:\nAs we can see, in Python lists are treated like objects, so the sums variable in the main() function’s frame points to an empty list object in the objects list. As we add elements to the list, they’ll show up in the object itself. We’ll come back to this concept later in this lab to show why it is important to know that Python treats lists like objects instead of other variables.\nThe next line creates the total variable, setting it equal to $0$, and then we’ll reach the for loop:\nThis for loop iterates four times, from $1$ up to but not including $5$. So, we’ll enter the loop with i storing the value $1$.\nInside of the loop, we’ll add the value of i to the total:\nThen, we’ll append that new value in total to the end of the sums list. Since that list is empty, it will become the first item in the list, as we can see here:\nNotice that the list in the object area now includes a single element. On that element, we can see a small $0$ at the top of the box, which is the index of that element. Then, at the bottom and in a larger font, we see the value stored in that element, $1$. Just like with other variables, even though the assignment statement references the total variable, we are actually storing the value in the list, not a reference to the variable.\nAt this point, we’ve looped back to the top of the for loop, so we’ll increment i by one and enter the loop again:\nInside of the loop, we’ll add the new value of i to total, and then append that value to the sums list. After both of those steps, we should see the following state in Python Tutor:\nNotice that we now have two elements in the list. The first item, at index $0$, is still $1$, but now we’ve appended a second element at index $1$ that stores the value $3$. We’ve reached the top of the loop, so we’ll increment i and repeat those steps again. After the next loop iteration, we’ll see this state:\nThe process repeats one more time, leading to this state at the end of the for loop:\nNotice that each time the loop iterates, we get a new value added to the sums list. Finally, we’re out of items to iterate over in the range, so we’ll jump to the bottom of the for loop and continue executing code from there:\nThis last line of code will print the current contents of the sums list to the terminal. Python does a great job of formatting lists on the terminal so they are easy to read and understand. So, when we execute this line, we should see the following state, with output added in the print output section at the upper-right of the screen:\nAs we can see, adding elements to a list using a for loop works very easily, and Python Tutor does a great job showing us how Python will store that data in memory. The image below shows a full animation of this entire program.\nLater in this lab, we’ll see why this particular structure is used and why it is important.\n",
    "description": "",
    "tags": null,
    "title": "Python Lists",
    "uri": "/x-cis115-labs/13-lists/01-python-lists/"
  },
  {
    "content": " Resources Slides To explore the various ways we can use conditional statements in code, let’s start by examining the same problem using three different techniques. We’ll use the classic Rock Paper Scissors game. In this game, two players simultaneously make one of three hand gestures, and then determine a winner based on the following diagram:\n1\nFor example, if the first player displays a balled fist, representing rock and the second player displays a flat hand, representing paper, then the second player wins because “paper covers rock” according to the rules. If the players both display the same symbol, the game is considered a tie.\nSo, to make this work, we’re going to write a Python program that reads two inputs representing the symbols, and then we’ll use some conditional statements to determine which player wins. A basic skeleton of this program is shown below:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") # determine the winner main() Our goal, therefore, is to replace the comment # determine the winner with a set of conditional statements and print statements to accomplish this goal.\nLinear Conditional Statements First, let’s try to write this program using what we already know. We’ve already learned how to use conditional statements, and it is completely possible to write this program using just a set of linear conditional statements and nothing else. So, to do this, we need to determine each possible combination of inputs, and then write an if statement for each one. Since there are $3$ possible inputs for each player, we know there are $3 * 3 = 9$ possible combinations:\nPlayer 1 Player 2 Output rock rock tie rock paper player 2 wins rock scissors player 1 wins paper rock player 1 wins paper paper tie paper scissors player 2 wins scissors rock player 2 wins scissors paper player 1 wins scissors scissors tie We also have to deal with a final option where one player or the other inputs an invalid value. So, in total, we’ll have $10$ conditional statements in our program!\nLet’s first try to make a quick flowchart of this program. Since we need $10$ conditional statements, our flowchart will have $10$ of the diamond-shaped decision nodes. Unfortunately, that would make a very large flowchart, so we’ll only include the first three decision nodes in the flowchart shown here:\nAs we can see, this flowchart is very tall, and just consists of one decision node after another. Thankfully, we should know how to implement this in code based on what we’ve previously learned. Below is a full implementation of this program in Python, using just linear conditional statements:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") and not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") main() This program seems a bit complex, but if we step through it one step at a time it should be easy to follow. For example, if the user inputs \"scissors\" for player 1 and \"rock\" for player 2, we just have to find the conditional statement that matches that input and print the correct output. Since we were careful about how we wrote the Boolean expressions for these conditional statements, we know that it is only possible for one of them to evaluate to true. So, we’d say that those Boolean expressions are mutually exclusive, since it is impossible for two of them to be true at the same time.\nThings get a bit more difficult in the last conditional statement. Here, we want to make sure the user has not input an invalid value for either player. Unfortunately, the only way to do that using linear conditional statements is to explicitly check each possible value and make sure that the user did not input that value. This can seem pretty redundant, and it indeed is! As we’ll see later in this lab, there are better ways we can structure this program to avoid having to explicitly list all possible inputs when checking for an invalid one.\nBefore moving on, it is always a good idea to run this code yourself, either directly in Python or using Python Tutor, to make sure you understand how it works and what it does.\nAlternative Version There is an alternative way we can write this program using linear if statements. Instead of having an if statement for each possible combination of inputs, we can instead have a single if statement for each possible output, and construct more complex Boolean expressions that are used in each if statement. Here’s what that would look like in Python:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if (p1 == \"rock\" and p2 == \"rock\") or (p1 == \"paper\" and p2 == \"paper\") or (p1 == \"scissors\" and p2 == \"scissors\"): print(\"tie\") if (p1 == \"rock\" and p2 == \"paper\") or (p1 == \"paper\" and p2 == \"scissors\") or (p1 == \"scissors\" and p2 == \"rock\"): print(\"player 2 wins\") if (p1 == \"rock\" and p2 == \"scissors\") or (p1 == \"paper\" and p2 == \"rock\") or (p1 == \"scissors\" and p2 == \"paper\"): print(\"player 1 wins\") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") and not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") main() In this example, we now have just four if statements, but each one now requires a Boolean expression that includes multiple parts. So, this program is simultaneously more and less complex than the previous example. It has fewer lines of code, but each line can be much trickier to understand and debug.\nAgain, feel free to run this code in either Python Tutor or directly in Python to confirm that it works and make sure you understand it before continuing.\nIn terms of style, both of these options are pretty much equivalent - there’s no reason to choose one over the other. However, we’ll see later in this lab, there are much better ways we can write this program using chaining and nesting with conditional statements.\nnote-1 The Python programming language has its own style guide, known as “PEP 8” to most Python programmers. One of the major conventions proposed in that guide is limiting the length of each line of code to just 79 characters, in order to make the code more readable. However, as we’ve seen above, it is very easy to exceed that length when dealing with complex Boolean expressions, and we’ll see this again as we add multiple levels of indentation when we nest conditional statements.\nIn this course, we won’t worry about line length, even though some text editors may mark those lines as being incorrect in Python. Likewise, in many examples we won’t wrap the lines to a shorter length, except for readability purposes in the videos and slides.\nThat said, it’s definitely a good style to try and follow, and we encourage you to think about ways you can write your code to keep it as concise and readable as possible. Having shorter lines of code, while still using descriptive variable and function names, is a good start!\nFile:Rock-paper-scissors.svg. (2020, November 18). Wikimedia Commons, the free media repository. Retrieved 16:57, February 28, 2022 from https://commons.wikimedia.org/w/index.php?title=File:Rock-paper-scissors.svg\u0026oldid=513212597.] ↩︎\n",
    "description": "",
    "tags": null,
    "title": "Linear Conditionals",
    "uri": "/x-cis115-labs/9-nested-conditionals/01-linear/"
  },
  {
    "content": " Resources Slides The first type of loop we’ll explore in pseudocode is the while loop. A while loop is an iteration statement that will constantly repeat the code inside of it while a Boolean expression evaluates to true. This is very similar to how an if statement is constructed - we know that the code inside an if statement is only executed if the associated Boolean expression is true. In the case of a while loop, we do basically the same thing, but at the end of the code inside the loop, we go back to the top and check the Boolean expression again. If it is still true, then we execute the code inside it over and over until it evaluates to false.\nIn pseudocode, the basic structure of a while loop is shown here:\nREPEAT WHILE(\u003cboolean expression\u003e) { \u003cblock of statements\u003e } When we encounter a while loop, we first evaluate the \u003cboolean expression\u003e inside the parentheses to see if it is true. If so, we enter the loop and execute all of the code in the \u003cblock of statements\u003e between the curly braces {}. Once we’ve reached the end of the block, where the closing curly brace } is found, we then go back to the top and evaluate the \u003cboolean expression\u003e again. If it evaluates to true, we run the code inside the loop again.\nWe keep doing this until the \u003cboolean expression\u003e evaluates to false. As soon as it does, we jump down to the code immediately following the closing curly brace } at the end of the loop - we don’t execute the code inside the loop again.\nThis also means that when we initially reach the loop, we could run into the situation where the \u003cboolean expression\u003e evaluates to false the first time we see it. In that case, we just jump to the end of the loop and start executing the code after the closing curly brace }. There is no guarantee that we’ll ever execute the code inside the loop, just like in an if statement.\nCode Tracing Example To understand how a while loop works in practice, let’s code trace an example program. Consider the pseudocode program shown here:\nPROCEDURE main() { DISPLAY(\"Enter a number: \") x \u003c- NUMBER(INPUT()) y \u003c- 1 REPEAT WHILE(y \u003c= x / 2) { IF(x MOD y = 0) { DISPLAY(x + \" is divisible by \" + y + \"\\n\") } y \u003c- y + 1 } } main() Before we run a code trace on this program, take a moment to read it and see if you can guess what it does!\nAs always, we’ll start our code trace by reviewing the code and keeping track of variables and procedures, as well as output. So, our initial setup will look like this:\nAs we scan through the program, we’ll find the main() procedure and record it in our list of procedures.\nAt the bottom of the program, we’ll find a call to the main() procedure, so we’ll jump to that procedure’s code and start executing it.\nThe first two lines of the main() procedure simply prompt the user for input and then store that input in the variable x. In this example, let’s assume the user inputs the string \"12\" as input. So, we’ll store the number $12$ in the variable x\nNext, we’ll store the value $1$ in the variable y.\nAt this point, we’ve reached the start of our loop. So, first we need to determine if the Boolean expression inside of the parentheses is true or false. Looking at the expression, it is checking if the value in y is less than or equal to half of the value stored in x. Since x is currently storing $12$, we know that half of x is $6$. Because y is only storing $1$, we know that y is definitely less than or equal to $6$, and the Boolean expression evaluates to true. Therefore, we should enter the loop and start executing the code inside.\nInside of the loop, we find an if statement. So, we must determine if the Boolean expression inside of the if statement is true as well. In this case, we are checking if the remainder of dividing x by y is $0$ using the MOD operator. This is the same as checking to see if x can be evenly divided by y. Since y is currently $1$, we know that any integer divided by $1$ is itself with no remainder. So, this Boolean expression will evaluate to true and we should execute the code inside the if statement.\nHere, we find a DISPLAY() statement, so we’ll just add that to our output and then exit the if statement below.\nBelow the if statement, we see a simple assignment statement that will increase, or increment, the value of y by $1$. So, the variable y is now storing the value $2$.\nAt this point, we’ve reached the end of the while loop. So, we need to loop back up to the beginning of the loop and start over again.\nHere, we need to once again evaluate the Boolean expression inside of the while loop. Since the value of y has changed, it might be different this time. However, we see that the $2$ store in y is still less than or equal to half of the value $12$ stored in x, so we enter the loop again.\nInside the loop, we repeat the same process as before. We start by evaluating the Boolean expression inside of the if statement. Since $12$ is evenly divisible by $2$, that expression is true and we should enter the if statement.\nSo, once again we’ll print some output to the terminal:\nAnd then we’ll leave the if statement and increment the value stored in y by $1$.\nWe’re at the bottom of the loop, so we’ll need to repeat by going back to the top once again.\nHopefully by this point we have a pretty good idea of how this loop is working. We first check to see that $3$ stored in y is less than or equal to half of the value in x. Since it is, we’ll continue the loop, and in the if statement inside we’ll find that $12$ is evenly divisible by $3$, so we’ll print some output, increment y by $1$, and loop back to the top. So, after that whole iteration, we should see the following in our code trace:\nWith small, simple loops like this one, once we know what it does, we can typically just treat the whole loop like a single statement in our mental model of a computer. We know that it will increment the value of y each time, and if the value of x is equally divisible by y, it will print some output. Finally, we know we should keep repeating this step until y is greater than half the value of x. In many cases, we can simply refer to each iteration of the loop by the values of the variables used in the loop itself. So, after the iteration where y is equal to $4$, we’ll see this state:\nLikewise, after the iteration where y is $5$, we’ll see this state:\nNotice that this iteration did not produce any output, since $12$ is not evenly divisible by $5$. At this point, y is storing the value of $6$. Since that is exactly half of $12$, it still makes the Boolean expression true so we should execute the code in the loop again. After that iteration, we’ll see the following state:\nAt this point, y is now storing the value $7$. Since $7$ is not less than or equal to half of $12$, the Boolean expression inside the while loop will evaluate to false and we’ll jump down to the bottom of the loop.\nSince there is no more code in the main() procedure, we’ll return back to where the procedure was called, and then we’ll see that we’re at the end of the program! An entire trace of the program is shown in this animation.\nAs we can see, this program will determine all of the possible factors of the value that is provided by the user as input, and it will print them one at a time to the output.\nWhile Loop Flowchart Another way to visualize a while loop is using a flowchart. The pseudocode program above can be represented as the following flowchart:\nIn this flowchart, we once again begin at the top at the circle labeled “Start”. From there, we see that our program will read input and store it in the variable x. We also create the variable y and store the initial value of $1$ there. At this point, we hit a diamond-shaped decision node, representing the while loop. If the Boolean expression in that decision node is true, then we follow the branch to the right that enters the loop. Here, we see yet another decision node that represents the if statement inside of the loop. When we see a loop and an if statement side by side in a flowchart like this, it is very easy to see how similar they actually are.\nAfter the if statement, we increment the value stored in y, and then we see the flowchart path will loop back up to the beginning of the while loop, starting with the decision node at the top. This is the key concept in a while loop - once we reach the end of an iteration, we must go back to the top and enter the decision node once again.\nWhen we reach a point where the Boolean expression evaluates to false, our flowchart will then finish at the circle labeled “End”.\nSo, just like we saw with conditional statements, using flowcharts is another great way we can try to understand the control flow in our programs. Feel free to make use of any of these tools as we continue to develop more complex programs in this course.\nnote-1 In the Official AP Pseudocode, the REPEAT WHILE loop is instead replaced with a REPEAT UNTIL loop. The concept is the same, except that the loop will repeat until the Boolean expression is true, instead of while the Boolean expression is true. We feel it is worth highlighting this change, since it does deviate from the official standard.\nThis is a very subtle change, and it is easy to translate between the two by simply adding a Boolean NOT operator to the Boolean expression. However, we chose to introduce loops using REPEAT WHILE instead of REPEAT UNTIL because most programming languages, including Python, only use while loops. There are few, if any, modern languages that use an “until” loop, and we feel that it adds an unnecessary complication to our pseudocode language. So, we’ve chosen to stick more closely to Python’s loop structures than the ones introduced in the AP Pseudocode.\n",
    "description": "",
    "tags": null,
    "title": "While Loops",
    "uri": "/x-cis115-labs/10-pseudocode-loops/01-while-loops/"
  },
  {
    "content": " Resources Slides The first type of loop to explore in Python is the while loop. A while loop uses a Boolean expression, and will repeat the code inside of the loop as long as the Boolean expression evaluates to True. These loops are typically used when we want to repeat some steps, but we aren’t sure exactly how many times it must be done. Instead, we typically know that there is some condition that must be True while we repeat the code, and once it turns False we can stop looping and continue with the program.\nThe general syntax for a while loop in Python is shown here:\nwhile \u003cboolean expression\u003e: \u003cblock of statements\u003e Notice that this syntax is very similar to an if statement. We start with the keyword while, followed by some sort of a \u003cboolean expression\u003e that will evaluate to either True or False. The Boolean expression in Python does not need to be placed inside of parentheses, unlike in pseudocode. After the Boolean expression is a single colon :. Then, starting on the next line and indented one level is a \u003cblock of statements\u003e that will be executed when the Boolean expression evaluates to True. Once again, just like in an if statement, we know which statements are part of the block within a while loop based solely on indentation.\nJust like in pseudocode, it is possible for the Boolean expression to evaluate to False initially, which will bypass the loop entirely and never execute the code inside of it. Likewise, if we aren’t careful, we can also write a loop where the Boolean expression will always be True, and the loop will run infinitely, causing our program to lock up and never terminate.\nCode Tracing Example To truly understand how a while loop works in Python, let’s go through a simple code tracing example in Python Tutor. Consider the following Python program:\ndef main(): x = int(input(\"Enter a number from 0 to 100: \")) total = 0 while total % 100 != x: total = total + 9 print(\"The smallest multiple of 9 that ends in {} is {}\".format(x, total)) main() See if you can figure out what this program does before moving on!\nAs always, you can copy and paste this code in the tutor.py file in Codio, or click this Python Tutor link.\nWhen we load this code in Python Tutor, we should see the usual default state:\nThe first couple of steps will simply find the main() method and record it in the global frame, and then call the main() method from the bottom of the program\nThe first line of the program will prompt the user for input and store it in the variable x. For this example, let’s assume the user inputs the string \"27\".\nTherefore, we’ll store the value $27$ in the variable x. The next line will store the value $0$ in the variable total, as shown here:\nAt this point, we’ve reached the beginning of the while loop. So, we’ll need to determine if the Boolean expression evaluates to True or False. In this case, the value of total % 100 is equal to $0$, so it is not equal to the value stored in x. Therefore, the Boolean expression is True, and we should enter the loop.\nInside of the loop, we are simply adding $9$ to the value in total. So, we’ll see that variable is updated, and the execution pointer goes back to the top of the loop.\nNow that we are back at the top of the loop, we need to check the Boolean expression again. This time the value of total % 100 is $9$, which still isn’t equal to the value stored in x, so we’ll enter the loop again.\nWe’ll add $9$ to the total here, and jump to the top again.\nOnce again, we will check the Boolean expression and see that it is still True, so we’ll enter the loop and add $9$ to the total yet again before repeating the process from the top of the loop. At this point, we should see this state in Python tutor.\nWhen we compute total % 100, we get the value $27$, which is the same as the value stored in x. This will make the Boolean expression evaluate to False, so we can skip the loop and jump to the bottom of the program.\nHere, we are simply printing out the output, and then the program will terminate.\nA full animation of this program’s execution in Python Tutor is shown here.\nTracing the execution of a while loop is quite simple, especially with tools such as Python Tutor to help us make sure we’re updating the variables in the correct order.\n",
    "description": "",
    "tags": null,
    "title": "While Loops",
    "uri": "/x-cis115-labs/11-python-loops/01-while-loops/"
  },
  {
    "content": " Resources Slides In pseudocode, we can create variables that store values using the Boolean data type. These variables can only store one of two values: true or false. So, a Boolean value is really the simplest data value we can imagine - it is a single binary bit representing a value of true or false. In some systems, we may also refer to these values as 0 or 1, but in pseudocode we’ll just use true and false.\nTo create a variable that stores a Boolean value in pseudocode, we can use the following assignment statements:\nx \u003c- true y \u003c- false In pseudocode, both true and false are keywords in the language. They represent the special boolean values true and false, and cannot be used as the name of a variable or procedure. Since they are values and not strings, we do not have to put them in quotation marks.\nConverting Between Data Types We can use the special BOOLEAN() procedure to convert any value to a Boolean value. Here are the basic rules for that conversion:\nStrings: \"true\" will evaluate to true and \"false\" will evaluate to false. Capitalization doesn’t matter. All other values are undefined. Numbers: 0 will evaluate to false, and any other value will be true. The reverse works as well - Boolean values can be provided as input to the STRING() or NUMBER() procedures, and the outputs produced there will match these rules. Specifically, the true value will convert to the number $1$, but any non-zero number would be valid.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Booleans",
    "uri": "/x-cis115-labs/6-booleans/01-pseudocode-booleans/"
  },
  {
    "content": " Resources Slides Now that we understand how to use Boolean values in our pseudocode programs, it’s time to put those values to use. One way to think of the result of a Boolean expression is that it helps us make a decision in our programs. For example, if we want to do something special in our program when the user inputs the value $42$ into the variable x, then we can write the Boolean expression x = 42 to help us decide if the user input the correct value.\nOnce we have that decision made, we need some way to tell our program to run a different piece of code based on the outcome of that decision. In pseudocode, as well as most other programming languages, we can use a special construct called an if statement to do this. If statements are one example of a conditional statement in programming.\nIn an if statement, we start with a Boolean expression. Then, if that Boolean expression evaluates to the value true, we run the code inside of the if statement. Otherwise, we just skip that code and continue executing the rest of the program.\nThe general structure of an if statement in pseudocode is shown here:\nIF(\u003cboolean expression\u003e) { \u003cblock of statements\u003e } In this structure, the \u003cboolean expression\u003e is any expression that results in a Boolean value. Typically, we use Boolean comparators and operators to construct the statement, along with any variables that are needed. Likewise, the \u003cblock of statements\u003e is just like a block of statements inside of a procedure - it consists of one or more statements or lines of code, which can be executed.\nTo see how an if statement works, let’s go through a couple of code traces in an example program.\nCode Tracing Example - False For this example, consider the following program in pseudocode:\nPROCEDURE main() { DISPLAY(\"Enter a number: \") x \u003c- NUMBER(INPUT()) IF(x = 42) { DISPLAY(\"You found the secret!\\n\") } DISPLAY(\"Thanks for playing!\\n\") } main() Let’s run trace through this program a couple of times to see how an if statement works in pseudocode. As always, we’ll start our code trace as shown below:\nNext, we’ll process through the code, finding our main() procedure. At the end, we’ll reach the call for the main() procedure:\nSo, we’ll enter the main() procedure here.\nThe first line of code will display a prompt to the user:\nThen, we’ll read the input from the user and convert it to a number. In this example, let’s assume the user inputs the value \"16\" at the prompt. So, we’ll store the number value $16$ in the variable x.\nNow we have reached the beginning of the if statement in our code. When we evaluate an if statement, the first thing we need to do is evaluate the Boolean expression inside the parentheses. In this example, we are evaluating the expression x = 42. Since x is $16$, this evaluates to false:\nWhen the Boolean expression is false, we don’t execute the code inside of the if statement’s curly braces {}. So, we’ll just skip to the bottom of the statement, and execute the next line:\nThis line simply displays a message to the user, and then the program ends:\nThis entire process is shown in the animation below:\nCode Tracing Example - True Now let’s go back a few steps in the program to the point where it is expecting user input:\nThis time, let’s assume the user inputs the value \"42\" at the prompt. So, that means that the variable x will now store the value $42$ as shown here:\nNow, when we reach the beginning of the if statement, we’ll evaluate the expression x = 42 again, but this time the result will be true since x is indeed storing the value $42$:\nWhen the Boolean expression is true in an if statement, we should execute the code inside its curly braces {}. So, we’ll move the arrow down to that line:\nThis line will print out special output for the user, as shown here:\nOnce we’ve reached the end of the block of statements inside of the if statement, we’ll just continue through the program starting with the next line of code after the if statement:\nThis line will print a message as well, and then the program will end:\nThis entire process is shown in the animation below:\nAs we can see, an if statement is a powerful construct in our program. We can use any variables to create a Boolean expression using comparators and operators, and then we can use that result to make a decision about whether to run a special piece of code or not.\nIf Statement Flowchart Another way to visualize an if statement is using a flowchart. Consider the following pseudocode:\nx \u003c- NUMBER(INPUT()) IF(x \u003e 0) { DISPLAY(x) } DISPLAY(\"Goodbye\") This pseudocode can also be represented as the flowchart shown below:\nWhen we read flowcharts like this, we typically go from top to bottom, starting with the circle labeled “START”. The first step is to read input from the user, and store that value in the variable x.\nThen, we reach a decision node, which uses a diamond shape. This node asks if the value in the variable x is greater than 0. Notice that there are two lines coming from the decision node: one labeled “True” and another labeled “False”. They correspond to the possible values that can result from evaluating the Boolean expression x \u003e 0. So, if the result of that expression is true, then we’ll follow the path that exits the diamond from the side labeled “True”, and we’ll output the value x to the terminal. Once that is done, we can follow that path around to the next box that will output the string \"Goodbye\".\nIf that result is false, then we’ll follow the downward path labeled “False” and skip the path to the side. Instead, we’ll just reach the line that prints \"Goodbye\" and then end the program.\nAs we learn how to use if statements in our code, we might find it easier to use flowcharts or other tools to help understand exactly what our program will do. The path that a program takes through a flowchart like this is called the control flow of the program. We’ll discuss that topic a bit more toward the end of this lab.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode If",
    "uri": "/x-cis115-labs/7-conditionals/01-pseudocode-if/"
  },
  {
    "content": " Resources Slides Previously, we learned about strings and string values in pseudocode. Recall that a string is just text inside of a set of quotation marks \"\", such as \"Hello World\" or \"Willie Wildcat\". In technical terms, a string is an example of a data type in programming. A data type defines the way a particular value can be stored in a computer. For text values, we use the string data type.\nWhat about numbers? We all know how important numbers can be, especially since we’ve probably spent more time studying mathematics than just about any other subject in school. So, let’s introduce a new data type in pseudocode called the number data type. This data type can store any single number, such as $1$ or $2.3$ or even special numbers like $\\pi$ (pi) or $e$ (Euler’s number).\nSo, to create an expression that evaluates to a numerical value in pseudocode, we can just use the numbers in our code instead of text in quotes. For example, to store the number $7$ in a variable, we’d use the following assignment statement in pseudocode:\nnum1 \u003c- 7 Notice that the numerical value 7 in our code does not have quotation marks around it. This is because we want to treat it like a numerical value instead of a string.\nAlso, recall from earlier that we cannot use a number as the first symbol in a variable name? This is because numerical values must always start with a number, so we enforce this rule to allow us to tell the difference between numerical values and variable names.\nFor a number with a decimal in it, such as $1.23$, we can use a similar process:\nnum2 \u003c- 1.23 If we have a value that is less than $1$, we must put a 0 in front of the decimal point, like this:\nnum3 \u003c- 0.42 We can also create negative values by placing the negative symbol - (the same symbol as the minus sign) in front of the numerical value:\nnum4 \u003c- -4.56 Notice that we have to be careful to include a space between the arrow symbol \u003c- in the assignment statement and the negative symbol - for a negative value.\nAs we can see, creating variables that store numerical values is pretty easy, and it hopefully works exactly like you expect it to work.\nConverting Between Data Types Now that we have two different data types, strings and numbers, it might be useful to convert between the two data types. Officially, the AP Pseudocode does not include an explicit way to convert between data types, or any concept of different data types at all. Instead, they just assume that variables can “automagically” convert data as the developer intended, without performing any additional steps.\nHowever, this can get a bit confusing, so we’ll briefly introduce two different procedures in pseudocode that can handle converting data between different types.\nTo convert any type of data to a number, we can use the NUMBER(expression) procedure. It will evaluate the expression to a value, and then convert that value to a number. Of course, this requires us to make sure that whatever value we get when we evaluate the expression will make sense as a number. Since we aren’t running this on a real computer, we don’t have to worry about any errors or crashes - instead, it will just mean that our program won’t make any sense when we try to run it on our “mental model” of a computer.\nLikewise, to convert any data to a string, we can use the STRING(expression) procedure in a similar way. Thankfully, pretty much any value in any data type can be represented as a string in some way, so we don’t have to worry about this procedure causing issues if the expression results in a strange value.\n",
    "description": "",
    "tags": null,
    "title": "Numeric Data",
    "uri": "/x-cis115-labs/4-math-operators/01-numeric-data/"
  },
  {
    "content": " Resources Slides So far, we’ve mainly focused on writing programs that can store and manipulate data, but the data itself has always been included in the code itself. While that approach is great for learning the basics, real programs often need to receive data as input from the user. This allows programs to truly be interactive and perform work based on what the user needs. So, let’s introduce a new expression in pseudocode that allows our programs to receive input from the user.\nInput Expression We can use the INPUT() expression in pseudocode to get input from the user. It works just like a procedure, similar to DISPLAY(), but it doesn’t require any parameters. Instead, when evaluated the INPUT() expression will simply result in whatever input value is provided from the user. So, we can use this in an assignment statement to store that value in a variable.\nThe INPUT() expression can be a bit confusing to work with in pseudocode, since we can only run these programs on our “mental model” of a computer. There isn’t any user interface, and we are acting both as the computer and as the user in most cases. However, this allows us to build and reason about programs that require input from the user, which is a useful skill to develop. As we continue to learn more about a real programming language, we’ll see that this same skill applies there as well.\nLet’s look at a quick example of using the INPUT() expression in pseudocode:\nDISPLAY(\"Enter your name: \") name \u003c- INPUT() DISPLAY(\"Hello \") DISPLAY(name) As we work through this program, we see the second line requires input from the user. So, it is not longer enough to simply read the code and process what it does - we must also consider what the user inputs as well. For this example, let’s assume the user inputs Willie Wildcat when prompted. In that case, the output should look like this:\nEnter your name: Willie Wildcat Hello Willie Wildcat In this example, we store the user’s input in a variable named name, and then we print the value of the name variable using a DISPLAY() statement. By default, the INPUT() expression will result in a string value, so it can accept just about any text that the user could provide.\nNumerical Input What if we want the user to input a number instead? Traditionally, the AP CSP Pseudocode would just handle this automatically by converting the data to whatever type is needed or makes the most sense. In this course, however, we’re going to explicitly convert data between types. So, we can use the NUMBER() procedure to make that conversion.\nLet’s look at an example:\nDISPLAY(\"Enter a number: \") text \u003c- INPUT() number \u003c- NUMBER(text) square \u003c- number * number DISPLAY(\"The square of your input is \") DISPLAY(square) Let’s quickly trace this program to understand how it works! We’ll set up our code trace like always, as shown below:\nThe first line will simply print a prompt to the user for input, so we’ll add that to the output section and move to the next line:\nHere, we are asking the user for input. On a real computer, the program would pause with a blinking cursor, allowing the user to enter input. In our code trace, we’ll show the user’s input as white text against a black background. So, if the user enters the text 6, it would look like this in our code trace:\nThe INPUT() expression will give us that value, which we can store in the text variable as shown in this step:\nThe next line will use the NUMBER() procedure to convert the text value \"6\" to the numerical value $6$ and store that in the new number variable:\nNotice that the value $6$ in the number variable does not have quotes around it. In our code traces, just like anywhere else, we’ll be careful to make sure that string values are surrounded by quotation marks, and numerical values are not.\nOn the next line, we’ll compute the square of the input by multiplying it by itself, and storing that result in the square variable:\nFinally, the last two lines of the program will display output to the user, including the new square value. We’ll start this output on the next line, since user input usually ends with the user pressing the ENTER key to denote the end of the input, which results in a newline character that is part of what is shown on the screen:\nThe full process can be seen in this animation:\nThis example shows us quite a bit about how we can use the INPUT() expression in our pseudocode to build programs that are interactive and allow the user to input data for our programs to store and manipulate.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Input",
    "uri": "/x-cis115-labs/5-input-strings/01-pseudocode-input/"
  },
  {
    "content": " Edited Transcript Hello and welcome to cc 110. I am Emily Alfs-Votipka and I’ll be your instructor for this semester. Feel free to call me Emily or Mrs. Alfs-Votipka. Either is fine with me, I wanted to just do a quick announcement video of what you can expect for this first week and just general tips for the course.\nThe first thing that I wanted to share is ways to contact me. The best way for course related stuff is using the CC 110 Help email, which is here in the syllabus. With your K-State email, you should be able to just type cc 110 hyphen, help and hit tab and it should autocomplete the rest of this email. My personal email is here as well it’s emilyalfs@ksu.edu. I do prefer for course communications though that you use the CC 110 help. The other benefit of using the CC 110 Help email is that it also goes to the undergraduate teaching assistants. So if you email that email, you may get a response from myself or Carrie or Nathan or Nate or Emma or Ryan.\nThey also will have office hours. The main cc 110 uta will be Carrie. And so if you have any questions about Codio, or things related to how the course is running, Carrie is the best TA to reach out to during office hours. Also feel free to reach out to me as well though. However any of these TAs would be able to answer questions about Python. So these four TAs are for CIS 115, which is the computer science specific version of this course. Whereas this course serves more for the computational core or the integrated computer science degree.\nHere we have the schedule of office hours. And again, you’ll notice there are some cis 115 courses listed here. And that is because the TAs serving dual purpose of having office hours available for CIS 115 and CC 110. So again, just to stress if you have any Python questions, you may visit any of their office hours. However, if you have any cardio or more tool related questions, you’ll need to talk with Carrie or myself specifically.\nThis semester, we are trying scheduling a little bit different. So if you think we could be doing something more different or better, please let me know.\nSo what will happen is week to week, you’ll need to check if you have a programming assignment. And you’ll also need to read the relevant chapters. The easiest way to keep track of this is the either the to do list on the right hand side. So this tells you all of the pertinent due dates and has them in order of earliest or soonest the latest due dates. You can also look at the course calendar. And the course calendar will show you a overview of when things are due. So we can see we have a lab and some reading some lab and reading.\nIt may be tempting to just click on one of these, but you’ll need to make sure that you read the appropriate module content before taking the quiz. So for example, this programming quiz is a part of chapter four. So you will need to make sure that you read Chapter Four before attempting that quiz.\nSo in the modules, they do have often prerequisites and also requirements to complete the module. Here we can see that I have completed the requirements for five of the module contents, I have not finished the syllabus yet. And I have not finished these down here either. This symbol on the top right shows me that I am not done with this module yet. And I need to complete all the items still.\nIn this programming module and says that my prerequisite is that I finished all of Chapter zero. And similarly for chapter one, I need to make sure that I finished chapter zero first. And then for Chapter Two, I need to read chapter one first and so on.\nI would like to point out there are a few places and I’ll mention this in a future announcement video as well. But I just want to draw attention to it. Now, there are some chapters that are numerically out of order. But in terms of content or concept, they’re pretty in line. So for example, chapter 12 is over how the internet works. And then chapter 19 is about search and information retrieval. So this kind of goes hand in hand with searching the web and page rank. So we still have though that you know to do chapter 12, you have to do chapter 11 first, and then to do chapter 19 you have to do chapter 12 first.\nSo for this first week, you’ll need to finish chapter zero that’s by the 26th then for the week after that you will need to do lab two, which will be due on Thursday, September 1. And then you’ll need to read chapters one and two and take the respective quizzes and do this discussion.\nI will have some in person office hours. And I will also have a component where we can meet virtually if needed. I will make an announcement once those office hour times are set.\nI think that’s all that I have for you for this first Announcements video. If you have any questions or concerns please feel free to reach out using that help email.\nI wish you well for the first week of classes for this fall semester. And please don’t be afraid to reach out if you have any questions.\n",
    "description": "",
    "tags": null,
    "title": "Fall '22 Week 1",
    "uri": "/y-weekly-updates/01_week/"
  },
  {
    "content": " Edited Transcript Will be updated shortly!\nKey Points:\nMy office hours are Monday and Friday 10-12 (DUE 2161) CC Help Sessions Wednesday 3:30-4:45 in Calvin 306 Check on the office hour schedule for TA office hours (DUE 1118) Use the CC110 help email for course help! Use the course calendar to stay up to date on due dates ",
    "description": "",
    "tags": null,
    "title": "Fall '22 Week 3",
    "uri": "/y-weekly-updates/03_week/"
  },
  {
    "content": " Edited Transcript Transcript to follow!\n",
    "description": "",
    "tags": null,
    "title": "Spring'23 Welcome",
    "uri": "/y-weekly-updates/00_welcome/"
  },
  {
    "content": " In this lab, we’re going to cover various ways to install Python on your computer. First, we’ll cover the basic way to install Python on a Windows system. To begin, open a web browser and go to python.org/downloads. Here you can find downloads for the latest version of Python for Windows as well as other operating systems. I’m going to click the button here to download the latest version of Python for Windows.\nOnce the file is downloaded, I can double click it to open and run the installer. When we run the installer, there are a couple of options that we’ll want to change. Notice by default, it will install Python into this complicated directory here, which can make it very hard to find. Also, it does not add Python to the path which we definitely want to do. So we’ll check mark this checkbox and then we will customize the installation. We’ll go ahead and check mark the boxes to install all of the optional features. When choosing advanced options, we can check mark the option to install for all users, which will place Python in the program files directory, making it much easier to find. We can click install and it will install very quickly.\nOnce we’ve installed Python on our computer, we can verify that it works by loading it in PowerShell. On Windows, I’m just going to search for PowerShell in the start menu to find that program. Once PowerShell loads, we can run Python using the python command. Notice that this is different than most Linux and Mac systems where to run Python version three, we must run the command python3. On Windows with the most recent installer, we can simply use the python command followed by --version to see the current version of Python. If we type python3, it might load the Microsoft Store in prompting us to install an older version of Python. This can get a bit confusing, it’s one of the problems with Python is the inconsistent usage of the python command to refer to Python version two, and Python version three. So if you follow this guide to install Python on your computer, just be aware that anytime you see the python3 command in documentation or in the labs, you’ll just need to use the python command instead, which will run Python version three.\nTo make it easy to write Python files on Windows, you may also want to install a text editor that is specifically designed for writing code. One of the easiest to use is Atom which is a text editor provided from GitHub. So we’ll download and install that as well. Once again, once we’ve downloaded Atom, we can double click the installer to install it. Once Atom is installed and open, you can close all of the open tabs to get a view that looks like this.\nTo make it easy to program in Python, we’re going to create a folder just for the Python work in this course. To do that, I’m going to click the add folders button right here. In Windows, we recommend creating a folder inside of your users home directory for all of your programming work. By default, it will open up the Documents List. But to get to your users folder, we’re going to go to the C drive, then Users. Then we’ll find our username. And then in here, we’re going to create a new folder. And I’m going to name this cis115 to match the class. And we’ll select that folder as the folder to open in Atom. Now we see a view similar to this.\nFrom here, we can easily add a Python file by right clicking on the folder and creating a new file. I’m going to name this file hello.py. And then inside of that file, I can type print hello world as a simple Hello World program. Once I’ve written that program, I can go to the File menu and choose to save the file. I can also use Ctrl+S to Save the file. Once I’ve done that that file should now exist on my system in that folder.\nOnce we’ve done this, we can run this file using Python by again opening PowerShell. In PowerShell, we need to navigate to where that is that folder is found. Notice that PowerShell already opens into our users folder. So all we should have to do is type cd cis115 to open up that folder. Then we can type python and the name of the file that we just created to run it. There we go. That’s all it takes to run a Python program on your Windows system. It should give you enough to get started in this class. As always if you have any questions please feel free to reach out to either of the instructors or any of our TAs and we’d be happy to assist you\n",
    "description": "",
    "tags": null,
    "title": "Python on Windows",
    "uri": "/x-cis115-labs/1-installing-python/01-introduction/"
  },
  {
    "content": " Learning to program involves learning not only the syntax and rules of a new language, but also a new way of thinking. Not only do we want to write code that is understandable by the computer, we must also understand what the computer will do when it tries to run that code.\nA key part of that is learning to think like a computer thinks. We sometimes call this our “mental model” of a computer. If we have a good “mental model” of a computer, then we can learn to read code and mentally predict what it will do, even without ever running it on an actual computer. This ability is crucial for programmers to develop.\nOne easy way to develop this ability is to learn how to use a programming language that isn’t an actual programming language. This language cannot (or at least wasn’t intended to) be run on a computer. Instead, we must simply learn to use our “mental model” of a computer to determine what programs written in this language will do.\nThese languages are sometimes referred to as pseudocode. If we look at the word pseudocode, we see the prefix pseudo, which means “not genuine.” That definition makes sense - a pseudocode is, in essence, not a genuine computer code. So, a pseudocode is simply a programming language that looks like a real programming language, but it isn’t actually intended to be run by a computer.\nThere are many examples of pseudocode that we could learn. In this course, we’re going to use the pseudocode that is used by the AP Computer Science Principles exam. This is an extraordinarily easy to understand pseudocode, and it covers all of the operations we need to learn in this course. If you want to learn more, you can find the CSP Reference Sheet online by clicking the link.\nThroughout this course, we’ll introduce new programming concepts using pseudocode first, which will allow us to learn how they work by adapting our “mental model” of a computer to include the new functionality. By learning how these concepts work in theory first, we’ll be much better able to get them to work in practice on a real computer using Python later. It may sound strange, but this is actually a great way to learn how to program!\nIn this first lab, we’re going to learn the basics of programming in pseudocode, including how to display message to the user, store information in variables, and write repeatable procedures that we can use as building blocks of a larger program. Let’s get started!\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Introduction",
    "uri": "/x-cis115-labs/2-print-variables/01-pseudocode-intro/"
  },
  {
    "content": " Resources Slides As our programs get larger and larger, we’ll probably find that we keep repeating pieces of code over and over again in our programs. In fact, we’ve probably already done that a few times just working through this lab. What if we had some way to build a small block of code once, and then reuse it over and over again in our programs?\nThankfully, this is a core feature of most programming languages! In our pseudocode, we call these procedures, though many other programming languages refer to them as functions, methods, or subroutines. For now, we’ll use procedure in pseudocode, and later on we’ll introduce the same concept in Python using a different term.\nCreating a Procedure Creating a procedure requires a more complex structure in our code than we’ve seen previously. The best way to learn it is to just see it in action, so here is the basic structure of a procedure in pseudocode:\nPROCEDURE procedure_name() { \u003cblock of statements\u003e } Let’s look at each part of this structure in detail to see how it works:\nEvery procedure starts with the special keyword PROCEDURE. Just like DISPLAY, the PROCEDURE keyword is a built-in part of our language that we use to create a new procedure. Following the keyword PROCEDURE we see the name of the procedure. In this case, we are using procedure_name as the name of the procedure. Procedure names follow the same rules and conventions as variable names that we discussed earlier. The two most important rules are: A procedure name must begin with a letter. Procedure names must only include letters, numbers, and underscores. No other symbols, including spaces, are allowed. Next, we have a set of parentheses (). These are used for the parameters of a procedure, which we’ll learn about on the next page. Following the parentheses, we see an opening curly brace { on the next line, and a closing curly brace } a few lines later. The curly braces are used to define the block of statements that make up the procedure. Inside of the curly braces, we see a \u003cblock of statements\u003e section. This is where we can place the code that will be run each time we run this procedure. Each procedure will include at least one statement here, but many times there are several. It may seem a bit complex at first, but creating a procedure is really simple. For example, let’s see if we can create a procedure that performs the “Hello World” action we learned about earlier. We’ll start by writing the keyword PROCEDURE followed by the name hello_world, some parentheses, and a set of curly braces:\nPROCEDURE hello_world() { } That’s the basic structure for our procedure! Now, inside of the curly braces, we can place any code that we want to run when we use this procedure. To make it easier to read, we will indent the code inside of the curly braces. That makes it clear that these statements are part of the procedure, and not something else. So, let’s just have this procedure display \"Hello World\" to the user:\nPROCEDURE hello_world() { DISPLAY(\"Hello World\") } There we go! That’s what a basic procedure looks like.\nCalling a Procedure Of course, learning how to write a procedure is only part of the process. Simply creating a procedure doesn’t actually cause it to run. So, once we have a procedure created, we have to learn how to use it in our code as well.\nWhen we want to run a procedure, we call it from our code using its name. It may seem strange at first, but the term call is what we use to describe the process of running a procedure in our code.\nThankfully, a procedure call is very simple - all we have to do is state the name of the procedure, followed by a set of parentheses:\nhello_world() So, our complete program would include both the definition of our procedure, and then a procedure call that executes it. Typically, we include the procedure calls at the bottom of the program, so it would look like this:\nPROCEDURE hello_world() { DISPLAY(\"Hello World\") } hello_world() Pretty simple, right? To make our code easy to read, we usually leave a blank line after the creation of a procedure, as shown in this example.\nWhen our “mental model” of a computer runs this code, it will start at the top. Here, it sees that we are creating a procedure called hello_world, so it will make a note of that. It won’t run the code inside the procedure just yet, but it will remember where that procedure is in our code so it can find it later. It will then jump ahead to the end of the procedure, marked by the closing curly brace }. As it moves on from there, it will see the line that is a procedure call. Since it knows about the hello_world procedure, it can then jump to that place in the code and run that procedure before jumping back down here to run the next line of code. However, it can be a bit tricky to follow exactly what is going on, so let’s go through a code tracing exercise to make sure our “mental model” of a computer can properly follow procedure calls in our programs.\nCode Tracing a Procedure Call Let’s consider the following program, which contains two procedures, and a bit of code to call those procedures:\nPROCEDURE foo() { DISPLAY(\"Run \") } PROCEDURE bar() { DISPLAY(\"Forrest, \") } foo() bar() foo() As before, we can set up our code tracing structure that includes our code, variables, and output. However, this time we’re also going to add a new box to keep track of the procedures in our program. So, our code tracing structure might look something like this:\nOnce again, we can work through this program line by line, starting at the top. In this program, the very first thing we find is the creation of a new procedure. At this point, we aren’t running the code inside the procedure, we are simply creating it. So, our program will record that it now knows about the procedure named foo in its list of procedures, and it will skip down to the next line of code after the procedure is created.\nThis line is just a blank line, so our “mental model” of a computer will just skip it and move to the next line. Blank lines are simply ignored by the computer, but it makes it easier for us to write code that is readable. So, on the next line, we see the creation of another procedure:\nOnce again, we see that a new procedure is being created, so our computer will simply make a note of it and move on. It will skip the blank line below the procedure, and eventually it will reach the first procedure call, as shown below:\nOk, here’s where things get a bit tricky! At this point, we are calling the procedure named foo. So, our computer will check the list of procedures it knows about, and it will see that it knows where foo() is located. So, our “mental model” of a computer knows that it can execute that procedure. To do that, it will jump up to the first statement inside of the procedure and start there. At the same time, it will also keep track of where it was in the program, so it can jump back there once the procedure is done. We’ll represent that with a shaded arrow for now:\nNow we are looking at the first line of the foo procedure, which simply displays the text \"Run \" on the output. So, we’ll update our output, and move to the next line of the procedure.\nAt this point, we’ve reached the end of our procedure. So, our computer will then jump back to the previous location, indicated by the shaded arrow.\nSince there is nothing else to execute on this line, it will simply move to the next line.\nOnce again, we see that this is another procedure call. So, the computer will make sure it knows where the bar() procedure is, and then it will jump to the first line of that procedure. When it does, it will remember what line of code it was currently running, so it can jump back at the end of the procedure.\nLike before, it will then run the first line of the bar() procedure, which will display \"Forrest, \" to the user. So, we’ll update our output section, and move the arrow to the next line.\nWe’re back at the end of a procedure, so we will jump back to the previous location and see if there is anything else to do on that line:\nSince there’s nothing else there, our “mental model” will just move to the next line of code:\nBy now, we should have a good idea of what is happening when we call a procedure. We simply jump to where it starts, making sure we remember where we came from:\nThen, we execute the lines of code in the procedure:\nFinally, when we reach the end of the procedure, we go back to where we came from and see if there is anything else to do on that line:\nThere’s nothing left to do, so we’ve reached the end of our program! The full process is shown in the animation below:\nIt is very important for us to make sure our “mental model” of a computer knows how to properly call and execute procedures, since that is a core part of developing larger and more complex programs. Thankfully, we’ll get lots of practice at this as we learn to program!\ntip-1 One of the tricky parts of learning how to program is knowing when to take a piece of code and make it into a procedure. A great principle to keep in mind is the Don’t Repeat Yourself or “DRY” principle of software development. In this principle, if we find that our program contains the same lines of code in multiple places, we should make a procedure containing those lines of code and call that procedure each time we use those lines in our program. In that way, we are only writing that block of code once, and we can use it anywhere.\nAnother principle is that programs should only consist of procedures, and each procedure should only be a few lines of code. By following this method of development, each procedure only performs one or two actions, making it much easier to test and debug those procedures independently and make sure they are working properly before testing the entire program as a whole.\nAs we continue to learn more about programming, we’ll see both of these principles in action.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Procedures",
    "uri": "/x-cis115-labs/3-functions/01-pseudocode-procedures/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video series, we’re going to be taking a look at big data. So exactly how big is big data? So here’s a slide of the metric prefixes. And so which ones do you think constitute as big data? or big data? Today, we’re talking about data anywhere from gigabytes to petabytes and beyond. And the future, we may even be dealing with exabytes of data. I said, gigabytes, right. But I can have a single video or even in these lecture series, that might be a gigabytes worth of data. And in the grand scheme of things, right, that’s just one video. But if you break down that gigabyte worth of data, you can actually start to chunk that up into lots of different lots of different parts, right? If we’re recording in 4k, for example, as a significant number of frames per second in the video, along with a significant number of pixels. And if you tack on the sound information with that as well. It is a significant amount of information that can be packed into a single gigabyte, big data is going to deal with or one, how do we actually store all of this information? How do we use this information? And how do we get information out of it, right, because we can have lots of information. But without any algorithms or way or ways of actually presenting that information becomes pretty much useless at the end of the day.\nSo where is all of this data coming from? Right? A lot of what we actually come across in the current age is web 2.0 stuff, right? Social media, and video streaming services as well. So if we look at 2017 versus 2018, we can actually see a lot of different changes here. Specifically, right, we have 4.1 million videos and YouTube, versus 4.3 million videos watching YouTube and within the second year, so not a huge jump. But if we take a look at Netflix, the popularity of Netflix is has drastically increased from 2017 to 2018, from 70,000 hours, to 266,000 hours of video watched every single minute on the internet. And likewise with things like Snapchat, Twitter, Facebook, emails, all sorts of different things. And so this slowly evolves over time, as we even get to some of the older stuff, right from 2016 to 2019, which is previous year. So we went from 2.7 8 million views on YouTube to four and a half million on YouTube, and 700,000 pages on or 700,000 logins on Facebook to 1 million, the number of Google searches has drastically increased. So 2.4 million to 3.8 million Netflix, right, we’re up to almost 700,000 hours of Netflix wash per minute. And things like online shopping have also drastically increase sharing of pictures, things like Instagram, Snapchat, and music, right? Especially smart home devices as well. And even things like twitch are starting to gain significant in popularity as a mainstream streaming service as well. You kind of imagine the sheer amount of information that streams online every 60 seconds is quite mind boggling.\nHow do we actually make infrastructure that can support the scale of streaming of that information, live and in High Definition? Or in a quick manner, right? Because we don’t want to have to sit here and wait five hours in order to download a YouTube video like what we’d had to do in the late 90s, early 2000s things of that nature. So how do we create an infrastructure that can support this type of information? And how do we create software that allows a normal user to interact with that data in a meaningful way.\nAnd that’s really where the Big Data stack comes into play. We can use all this all these tools and techniques not only to store information, but also also to view that information. This technique creates somewhat of a stacked approach here and management of the data where the bottom layer is going to represent all the providers of that information. And if we look here, we have things like MySQL, Postgres, Hadoop, all of these sorts of things, our databases, database technology, and some of them things like Hadoop are specialized in big data. So doing performing operations on very large amounts of information very quickly, and so We have speed on one access and scale on the other. So how fast is that particular technology at working with information? And how much information can it work with per second. So we have megabytes to petabytes, and batch processing, meaning we can process stuff on demand, but it takes a little bit of time for us to actually do it. And then real time, meaning that when we ask for our data, our data is there instantaneously. And we do not and we don’t have to actually wait for it to be produced.\nIn the middle here on our stack, this is going to be where all the analysis of that information is, at the bottom is where the data is actually being stored and provided into the analysis layer, where we use packages, like things like Sai, pi, and NumPy, which are Python, Python packages for scientific analysis, also things like mo hoot, which is a machine learning library, and all sorts of other information processing libraries that live at this layer. And this is where we’re going to do some things like machine learning artificial intelligence, we’re going to crunch that data transform that data to prepare it to be displayed to the user, which is done at the service layer.\nNow the service layer at the top is where we all primarily interact with online. So when we go to Amazon, and we see those recommended items, or even if we open up Google News, or even Flipboard, or Pinterest, or whatever, those user curated websites and mobile apps, where we have our news articles that are presented to us, and a lot of those are curated for your viewing interest and reading interests. And so how do we take all of the data all of the news articles in the entire world and collapse them to a smaller bite of information in a smaller chunk bite sized chunks that you can consume as a user? How do you consume the data that you want to consume? And so that’s where these services come into play things like news curation, even weather forecasting, pricing of items online recommendation of items online, and even things like online reputation. So how do you gain reputation or fame on the internet for SNAP something that’s trending on YouTube, or Twitter, or Instagram or something like that.\nBut where is all this going? So we talked about some of the services that are provided using big data. But a lot of this is primarily used for business, right? We consume as users a significant amount of this information. But underneath the hood, a lot of this is being driven by business objectives as well. So customization of services that that everyone provides. So anymore, right with web 2.0, everything that we use online is a tailored service to you as the user. So your login information, if you have it on Google that is being tracked, right and all of that information that you do would online searches, websites that you visit, you have that digital footprint, that digital footprint allows websites and companies to provide a tailored service to you specifically, also allows companies to help react to certain market trends a lot easier. So what’s trending at the moment. And they can make business decisions on that information. They real time optimizations for identifying certain costs and making more accurate decisions. And really, overall better holistic rd, right better research and development processes that are available, because we have all this information available to us. And we can crunch that information in a meaningful way make better decisions for our company. We have a lot of that information that we that big data stack that we saw before, right? Where we have, what we can, how we are able to provide information through things like Hadoop, and we’ll talk about MapReduce later. There’s a lot of other technologies listed there. ETL. So extract transform right load.\nSo how do we take the raw data that’s being generated by things like smart devices and transform that in a way that is easily searchable queryable and presentable to users in the middle area, right? How do we analyze that data? So things like MaHoot, scipy, hive, a lot of machine learning libraries here statistical software, and then the real business and objectives here the the task here so predictive modeling, sentiment analysis. So how do you detect if a tweet is positive or negative in terms of sentiment? Is this user tweeting negatively about my product or very positively about my project or my product? So these are a lot of the different things that we can achieve using big data techniques and technology to transform that information. A great example of some of these services that businesses can provide are, for example, Google Analytics, and Google Trends.\nSo Google Trends is actually one of my personal favorites, Google Trends. And I’ll attach this link in Canvas. But Google Trends allows you to actually see what’s trending on Google right as far as who’s searching what. So really interesting thing to look at is year in search. So you can look at what has been trending in the past years. So out of the entire out of all of last year, what was the top five or top 10 things that people actually searched online for? You can look up things like different holidays, politics, gaming, music, movies, you name it, you can actually find and compare who was being searched the most for on Google and the previous year, or even right now. And if you think about the number of sheer number of people that have actually used that use Google, if we look at last year, 2019 3.8 million Google searches per second or per minute, so there every 60 seconds, 3.8 million searches on Google. So how do we actually transform that into something that is usable, right, that’s all information that we can actually look at, and rely on and make decisions on what’s currently being popular, and so forth.\nAnother interesting service of that nature is healthmap.org. Now, healthmap.org is a website that was originally a research project. But what they do is they actually go in and collect all of these different news articles on the web, and consume them and look for outbreaks. So viruses, diseases, things like that. And where are those news articles are actually being written and try to geo locate those outbreaks on on a map in order to track disease outbreaks. Take a look at this. This is also so mapping, taking things like news articles, and trying to map them on a geolocation. This is called the thematic mapping. As I mentioned, this site tracks disease outbreaks mentioned online by location and provides a map showing the current outbreaks it costs the crunchy. And you can also look around the world a little bit as well, I’m just showing a screenshot here of the US. But this screenshot here was back in 2015, when we had a big outbreak of the bird flu. And so you can kind of see, for example, here, these are articles written in Leavenworth County, that identified an outbreak of bird flu in that region. As you can see, the color and the size of the dots kind of indicate the the size of that outbreak and severity of that outbreak. And we can even compare that to current events with the COVID-19 crisis, where we can see a lot of different dots across the US and certain regions and areas that have higher concentrations of COVID-19 cases that have been reported in the news.\nSo this is a really interesting way to consume news articles in order to track outbreaks of diseases. There’s also been very similar use cases of thematic mapping with Twitter data, specifically Twitter data with tracking the impacts of natural disasters as well. So things like hurricanes, tornadoes, and things and earthquakes and things like that. There’s a lot of different uses of big data as you can imagine. And we’ve only shown a different a couple different ones. A lot of the big topics are listed here, though, with things like topic modeling, where we can analyze text of an article for an for an example to determine what is talking about. So I’m given three articles. One of them is about a sports game. One of them’s about a sports video game, and one of them is about a sports movie. How can a computer to tell the difference between the different topics, right? They’re all about sports. But how do we write an algorithm to determine which article is about the video game, which one is about the actual sport game, and which one is about about the movie. So there’s a lot of different situations that topic modeling can help us solve and actually teaching computers to actually recognize a section of text and what that section of text is actually about because we’re computer understanding natural language Whether it be written, or spoken like natural language processing as extreme and as an extremely difficult task. So that’s what NLP or natural language processing is actually trying to accomplish here out as a computer understand spoken words. We’ve already talked about the analytics and data forecasting.\nNow that’s things like the Google Trends, sentiment analysis, and crowdsourcing. We’ve talked about that all as well. So is your brand getting good reviews? Right? How do we tell if a comment or a tweet is positive or negative? Can you? Can you use that to figure out what the problem is? So a lot of companies are really great at using this, others probably not so much. A lot of things with big data are reduced down into information visualization, as well. So how do you make sense of this large amount of data? One way is to visualize it so people can easily understand it. And this isn’t like making a simple xy chart, or graph in algebra or even using Excel. These are large amounts of information. So how do we transform that into a visualization that makes sense and allows us to extract the information that we need out of it, or the interesting information that that is that exists in it. And we’ve also already talked about thematic mapping, where we can map out data items by location or even geolocation and across time to understand what’s going on in the world around us.\n",
    "description": "",
    "tags": null,
    "title": "Big Data",
    "uri": "/iii-topics/20-big-data/02-big-data/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’re going to take a look at one great example of the use of cryptography in computer science. And to do that we have to go all the way back in history to look at World War Two. This slide right here shows the height of German occupation of Europe during World War Two. And during that time, the Germans were sending encrypted messages to all of their field commanders using a system that was very, very much thought to be uncrackable at that time. So we’re going to take a look at what that system is, how it works, and how the Allies were actually able to crack it by taking advantage of some of the knowledge that they had about such a system. Oh, and of course, some of this information would have been very much top secret, and a lot of it was classified up until just a few decades ago. So it’s really an interesting time to take a look back at what was going on during World War Two, and take a look at how the Germans were able to build a very interesting encryption system that was then later broken by the allies. So let’s start by taking a look at a quick video demonstrating the German’s Enigma machine and how it worked.\n",
    "description": "",
    "tags": null,
    "title": "Enigma Machine Introduction",
    "uri": "/iii-topics/16-cryptography/02-enigma-intro/"
  },
  {
    "content": " Video Transcript Hello there, my name’s Gavin, and welcome to this episode of The Slow Mo Guys very oddly presented from my living room.\nA while ago, I made a video called “How a Camera Works In Slow Mo”, and the response was great. So I thought a good natural progression to that video would be how a TV works in slow mo.\nThis is an 85-inch LCD TV, and whenever I’m playing something on it or watching something on it, my eyes and brain are being misled and tricked, giving me the illusion of watching a moving object when in fact I’m just watching several still images just shown to me very, very fast. If I’m watching a film, I’m being shown 24 images every second, and to my eyes, that looks like I’m looking at a moving object when in fact I’m looking at 24 individual pictures. If I’m playing a game, it’s the same, except maybe 30 to 60 frames a second, and if I’m on a PC, it could be 100s, PC master race.\nBut a TV like this is actually incapable of showing you one image and then 1/24 of a second later just switching all at once to the next image, and to illustrate this next point, I’m gonna use a very old and very crap CRT TV. That stands for cathode ray tube. If you’ve ever seen one of these filmed, you may notice that it looks slightly different on camera than it does to your eye. Look at that.\nThe reason it looks like this is because the shutter speed of this camera is out of sync with the refresh rate of this screen. The frame is constructed from the top to the bottom multiple times per second; that’s 60 times in the US, 60 Hertz. I’ve prepared for you some high speed footage that I shot a long time ago on the v2511 of this screen and this screen and some others. A lot of it is Dan paying “Super Mario” on the NES extremely badly.\nHere’s the TV and the cat played back at 25; this is how it would be perceived in real time. And now at 1600 frames a second, you can actually see the scan line moving from the top to the bottom, and you’ll notice that on a CRT screen, it’s only the active line of pixels that’s bright, and your persistence of vision will actually build that into a complete image. It’s messing with my eyes, this. - It’s like a dance floor. Oh, I didn’t even make it past the first guy. -\nSlowed all the way down to 2500 frames a second, you can now differentiate each individual frame being built from top to bottom. It takes an extremely fast camera to see that each frame is built line by line from top to bottom, but it takes an even faster camera to see that each line is drawn from left to right. Slowed down to 28,500 frames a second, we’re now seeing glimpses of that, but we do need to go even slower. This is now 118,000 frames a second, and I’m gonna put the stats up for you here so you can see the actual amount of time that it took, and you can see now that the line is being drawn from left to right on the screen.\nNow at 146,000 frames a second, to gain perspective on just how slow this actually is, you can see the exact time I shot this. So this is hours, it was just past midnight, 23 minutes, 41 seconds, this is 1/10 of a second, 1/100 of a second, 1/1000 of a second or a millisecond, and then over here you’ve got 1/10,000 of a second, 1/100,000 of a second, and this unit here is the millionth of a second, or a microsecond.\nWe are now at 380,000 frames a second as our recording frame rate. That is the highest frame rate we’ve ever shot so far on this channel, and using this information, here’s a little bonus fact: a CRT screen can draw Mario’s mustache in less than 1/380,000 of a second. That is some seriously fast facial hair.\nAnd if you’re wondering why this footage looks extremely mucky and blurry, it’s because the resolution is only 256 by 128, which, plonked into a 4K frame, is this big. That CRT screen is standard def; this is a 4K screen, which means it’s 3840 by 2160 pixels. That’s over eight million pixels. So think of the processing power that this TV has to have to update an image that big that many times every second.\nThe first thing you’ll notice about a modern LCD screen is that it’s not only the active line of pixels that retains brightness; it’s the entire image. So you can actually see the full image as each scan-line passes down the screen. This is every frame of the start-up sequence on an Xbox One. I also recorded myself playing a game of “Halo”. Nothing will make you feel worse about your performance than watching your lousy aim in slow mo, look at that. It’s crazy to think that when you’re playing “Halo”, this is actually what is happening on your TV. If only you could see at this speed, your aim would be incredible.\nIt honestly makes me feel bad when I fall asleep watching TV, knowing that this TV is doing all this intensive work changing literally 10s of millions of pixels every second, and there’s no one there watching it. Here’s a fun fact: the same applies to an iPhone, except it’s in portrait mode. So if you’re watching a video in landscape mode on your iPhone, you’re actually getting updates from left to right, or right to left, depending on which way you’ve flipped it, and that just proved to me that you can’t see the refresh direction with your naked eye, because I had no idea, whenever I was watching a YouTube video on my iPhone, that the screen was updating in a completely different direction. I’m not sure if this is the case for all smartphones, but it’s certainly the case on an iPhone 7 Plus, which is what I filmed this on.\nSo we’ve talked about one illusion of TVs, the illusion of movement. The second illusion I wanna talk about is the illusion of color. For this next part, I’m gonna need a second camera. Here’s one, that’s you, hello, you. So in order to film this screen extremely close, I’m gonna have to set my focus to the minimum possible distance, so it’s sort of like right here now.\nSet to my minimum focus, as I slowly move towards the screen, it becomes sharper, and you will then, at the last minute, see a very odd looking pattern. And what you’re seeing there is an effect caused by the camera, this camera, trying to resolve individual pixels on the surface of this screen. As I push further forward, the effect disappears, and everything goes out of focus. That’s because I’m now beyond the minimum focal distance of this lens, which is about, well, that’s about there. Not close enough. In order to get closer, I’m gonna need a macro lens.\nHere’s one. As I approach the white, and everything starts to become in focus, you can see that white isn’t so white anymore. It looks like I have to go closer even than that. Thankfully, I can go all the way to five times magnification. Now, one thing from this point, I am definitely gonna need a tripod, because there’s no way my arms are sturdy enough to hold this in place, but I’ll just ease it in just to show you the level of magnification we’re talking about now. Well, this close, it’s a different story altogether. I’m gonna get a tripod. Here’s one.\nWhat a mission this is, all right, let’s see what we can do here. We’re so close up right now that I can actually disturb this image by blowing on the lens. We’re now looking at the sub-pixel level. A pixel is made up of three sub-pixels, red, green, and blue, RGB, you may have heard that before, and this creates the illusion of different colors. By dimming and brightening different sub-pixels to different intensities, this screen can create the illusion of literally millions of different colors. When all three are lit to full brightness, you get white. When all three dim, you go through gray all the way down to black. So if green dims away, and red and blue are still lit, then you go into magenta, purple, that sort of area, and that’s how the colors are made. So every time on your TV you’re looking at a white image, you’re looking at tons of blue, green, and red lights. They’re just so small they look like white to your eye. Before you get white; red, green, and blue blurs into yellow, cyan, and magenta, and that’s what happens here when I move the screen slightly out of focus.\nThis is too close to watch a Slow Mo Guys video. I might vomit. It’s the same situation, just entire blocks and they’re bigger. As I mentioned before, this is a 4K LCD screen, which, a while back, were typically lit by CCFLs, or a cold cathode fluorescent lamp, which means the entire panel is backlit by fluorescent tubes. Nowadays, they are backlit by LEDs. This is why this would actually be marketed as an LED TV. The benefit of LED screens over CCFL screens is that they’re a lot thinner.\nNow I’m gonna point it at where some black text is. Now, interestingly, even though this area is black because all the sub-pixels have dimmed, they are still in fact backlit. Let me show you that right now. Now you can see, as we push in here, you have to pardon the noise, we’re at an extremely high ISO to get this shot through a macro lens, but you can see even the dimmed pixels, part of the liquid crystal display as it’s now trying to block all light from penetrating through, but it’s still a backlit pixel, and that’s one of the fundamental limitations of an LCD screen.\nYou can see this effect on an LCD screen in the credits of a film, ‘cause you’ve got an almost completely black image, but because there’s white text, the entire backlight has to be on to display the white, which means light will leak out from the black pixels, which means it’s not true black. There is another technology that’s becoming much more common these days, and that is an OLED screen, organic light-emitting diode. I did wanna include a comparison between an LCD panel and an OLED panel, but I didn’t actually have an OLED TV, and by sheer luck, right in the middle of me shooting all this footage, LG got in touch and offered to supply me with an OLED TV for the purpose of making this video, which I really appreciate. Thanks, LG.\nWhy don’t we go and take a look at it. This is a 77-inch LG OLED TV. The way OLED technology works is that each pixel is self-illuminating, depending on how much voltage is passing through it, which means there’s no global backlight on the TV. Each pixel is individually in control of how bright it is, and it’s not being lit from behind. And that means, when we go to our high ISO experiment, just like we did on the LCD, that when there’s an area of black on the screen, all of those pixels are off, and you can see here where I’m putting my cursor in front of the lens, you can see each sub-pixel lighting up and then completely turning off when it goes away. This technology means much deeper blacks, and the possibility of a very thin screen. And there you have it: a brief explanation of how a TV works in slow mo. If you found that video interesting, chances are you might find some other videos interesting on this channel, so make sure you boop, and once you’ve booped, feel free to check out our it’s just there. Thank you very much for watching. That was good timing, weren’t it? TV timed out, and now there’s fireworks.\n",
    "description": "",
    "tags": null,
    "title": "How a TV Works in Slow Motion - The Slow Mo Guys",
    "uri": "/iii-topics/22-graphics-and-video-games/02-how-tv-works/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re going to be taking a look at artificial intelligence. But before we get to the artificial part, what is actually intelligence? So what does it mean to be intelligent? This is a question I ask all of my students from the kindergarteners that I do outreach with all the way up into college classes like this, and I get a very wide range of responses here. And usually the default answer that I get is intelligent means someone is smart, right? But it’s not necessarily always the case, right? A person who’s smart or has an high IQ is capable of doing math, really good at remembering information, and creation of information. But it’s not necessarily intelligent behavior. So intelligence involves a lot of different things, including reasoning and problem solving, which of course, smart people are able to do those things as well. Our ability to reason to a certain degree and problem solved to a certain degree is definitely an intelligent behavior. When you encounter a situation in you’re environment, and you reason and solve that particular problem to get around that particular obstacle. And we see these types of behaviors and all sorts of beings, right? Not just humans, but it is documented quite frequently in the animal kingdom as well. Intelligent behavior also involves our ability to construct knowledge, right? So as we learn from our environment, right? Learning is also another intelligent behavior. But as we start to interact from our environment, we’re going to gather data, information, things that we see, taste, hear, touch, all of those things, our ability to perceive from our environment, which is also an intelligent behavior, our senses, but that information needs to go somewhere, right? An intelligent being like an animal or human is going to be able to take that information and construct knowledge to a certain degree.\nNow the level of intelligence can impact what kind of knowledge that can be constructed, probably some of the most basic ones, right? Even my kid right now we have those buckets, right, that have little different shape holes on top, and you have a bunch of different blocks. So the square block goes into the square hole, and the star block goes into the star hole. And it takes a little while, right? That is information that you can kind of get from trial and error, trying to put the square block in a triangle hole isn’t going to work out very well, but eventually you’ll figure out that, hey, the square goes into the square hole, and so on. Right? So that is one of our base forms of being able to construct knowledge and learn from our environment. Our ability to perceive also impacts our ability to learn and construct that knowledge. So the first time that you ever touched a hot stove by accident or a hot pan, right, that pain is something that we remember and is ingrained in us. So before that ever happens, we don’t really truly learn what it means to touch something that’s very hot. And we don’t sense that as a true thing of danger until that is actually touched. And then we get that pain reception. And we hopefully learn to not touch that hot pan again, even though we do that probably by accident. And hopefully we don’t do that on purpose again. So intelligent behavior, right? Not necessarily someone who’s smart, although smart people are definitely intelligent and exhibit intelligent behavior, but intelligent behavior isn’t necessarily connected to how smart someone is. But if that is intelligence, what does it mean to have artificial intelligence? Well, on a very basic level, right, is a non-biological thing that has or exhibits forms of intelligence, right, a machine right or robot or computer or phone, whatever it may be something that is not living a does exhibit some form of intelligence. Now, it may not be total human intelligence, but it may be partial human intelligence.\nSo a lot of this came from a man by the name of John McCarthy, who really was the creator or really helped start the field of AI. So in 1956, john McCarthy, who worked at Dartmouth College at the time, helped to organize a conference to discuss the idea of artificial intelligence. And so the 50s, this is really after world war two was over, and everyone was home and the big computers that we had created for the war, are now no longer being used for military purposes, but are starting to be transformed into industrial purposes. John McCarthy also had a lot of other things credited to him, including the Lisp programming language, but primarily he is credited for helping organize the idea of artificial intelligence and so on. During that summer of 1956, several leading minds in the world of AI at the time, although AI really wasn’t solidified at that point, but many of the people who had interest in this type of idea gathered for a very several long week brainstorming session, essentially, little mini conference. Attendees included john McCarthy, of course, Alan Newell, Herbert Simon, Claude Shannon, who we’ve talked about before Marvin Minsky, and quite a few others. I’ll talk about a lot of those folks here later on and the following videos. But pictured here are some of the surviving members of the conference from at least in 2006, when they’re celebrating their 50th anniversary. But at this conference, overall, a lot of the groundwork and the ideas of artificial intelligence were first introduced. And it really helped to shape the field for many years to come.\nSo we had this discussion already of what is intelligence and what is artificial intelligence. According to john McCarthy, it is the science and engineering of making intelligent machines, especially intelligent computer programs. It is related similar to the task of using computers to understand human intelligence. But AI does not have to confine itself to methods that are biologically observable. I really like that particular part there that is not biologically observable, right? There’s a lot of things in the world that are intelligent behaviors, right? Especially a lot of animals, cells, all sorts of things. But there’s a lot of things that machines can do that biological processes can’t as well. What does that mean for the definition of intelligence? Well, John McCarthy continued here to say that intelligence is the computational part of the ability to achieve goals in the world. Varying kinds of degrees of intelligence occur in many people, animals, and even some machines, as we talked about with artificial intelligence. But there’s really no true solid definition of intelligence, and particularly when it doesn’t depend on human intelligence, because a lot of times, of course, we as humans are defining intelligence. And most of the time, we’re defining intelligence in terms of our intelligence. So the problem is that we cannot yet characterize in general what kinds of computational procedures we want to call intelligent. We understand some mechanisms of intelligence and not others. So we don’t really truly fully understand the human brain yet and a lot of the nuances of our own human intelligence. So it’s kind of hard to quantify intelligence as a whole, especially artificial intelligence when we’re trying to transition into human-like AI.\n",
    "description": "",
    "tags": null,
    "title": "Introduction to Intelligence",
    "uri": "/iii-topics/18-ai/02-intelligence/"
  },
  {
    "content": " Resources Slides Video Script So in this video, we’re going to reiterate a little bit what we talked about with our relational database, right? Because the whole point of the relational database is that we can store lots of information in a very structured way that is easily searchable. That’s really important in today’s world, because we have the World Wide Web, right, the internet, it’s huge. Now that we know how to store data in a reasonable fashion, we have to talk about where most of the data in the world is actually stored. And for that, really is just the internet. So at the highest level, right, we can think of the internet as a very big, very big, completely unstructured database of all of the information in the world, right, because pretty much almost everything is connected to the internet anymore. Not everything, but pretty much. Some parts of it are very structured, and very well formed and easily searchable. But generally, it will never be as well structured as we’d like. And one structure might be entirely different than another. And so it’s not going to be very uniform across the entire internet. However, we are pretty much constantly using tools like Google to find information and the vast amount of data that is out there on the web, and it does a pretty good job, doesn’t it? When you do a Google search most of the time you find what you’re looking for. So how do we go about finding information in a big giant unstructured pile of data that really is pretty much like finding a needle in a haystack, as far as Internet is concerned. So that task is the job of information retrieval specialist, and the algorithms and research they do. In a base form, right, let’s say we want to find some information on a very simple Internet, maybe this is back in the early early, early days, where there was pretty much nothing out there.\nSo our internet has three pages, only three pages, and those three pages have very little amount of information. And so we want to find out some information about all this data that is on the web. So we want to run these search queries. And you can kind of imagine these being just put into a Google search box. Okay, so we want to find all the pages that have cats, dogs, dog sat, “dog stood”, cat or mat, and cat and mat. But how could we do that? How could we find all of the pages that match these queries? Well, the most basic or straightforward way to do it is just to read through all the pages and find all the occurrences right. But in reality, the internet is huge, this approach works perfectly fine for what we currently have, right? We only have three pages, I can read this in like under five seconds and find all the results right. But doing that process on the actual internet is a really bad idea, because it’s huge and would take forever so your searches would just never complete. And so we need a better way of looking at data in order to answer all of our questions very quickly and accurately to that.\nSo the first step here, then is to try to simplify the data. So instead of scanning each character, each word, every single time we tried to run a search or query, we can actually do what we call indexing. For each word, we could create a list that a list that contains which document that word is actually listed in. This indexed collection becomes a little bit easier to search because now we don’t have to look at all of the words in all of the web pages, we’re just looking at this index list. So which queries that we had before? Which of these queries can be actually answered with this information? Well, we can find cat right because cat is one of the words that we have sat there. index. And if we look at cat here, you can see that cat occurs in our document 1, and then cat also occurs and document 3. But in order to find cat, we didn’t have to read the entirety of one we didn’t have to read two. And we didn’t have to read the entirety of three that is already done for us. We just find the word in our list, and then we know already which pages that actually occurs in. But most of these can work just fine, right? Even dog sat, dog space sat, so we’re trying to find any of any occurrences of dog and any occurrences of sat here so quickly. Number 3 here would return to 3. And then it would also return 1-3. So, so one, two and three would be returned entirety for that query there. But cat or matt also works. Cat and mat. So pages that have both cat and mat.\nOverall, we can answer all these queries, right? Except for “dog stood”. So “dog stood” doesn’t work. Why? If you ever ran a Google search before, so if you type in just a two word search query is looking for any occurrences in any position on any page. So if I search for just dog space sat, it’s looking for any occurrences of dog and any occurrences of sat on that webpage. But if I use quotation marks, it’s looking for position, it’s looking for position, right, it’s looking for the word dog, immediately followed by a space, followed by the word stood. So now we’re dealing with the position of the words in the webpage. We can’t answer information like that with what we have. Because all we are actually storing here is the word itself, and then if it occurs on and what page it actually occurs on on the in the web, and not the position of where that word occurs on in that page. So in order to do that, we need to modify our index algorithm a little bit. So to improve our indexing algorithm, we could store the location of the word within the document, along with the document number in our index.\nSo using this information, we can answer all of our queries now, right? How would we actually do that? Well, let’s skip all the rest of them, because we already know we can answer everything else. But let’s look at dog stood. So first we’re looking for for dog, right, so imagine what our algorithm is looking for here, we’re looking for dog stood dog, followed by the word stood. So we can look at dog; dog occurs at two, two. So document two, position two, and document three, position six. So that’s well and good. And so we also need to find stood. So we find stood at document two, three, and document three, three. So dog and stood occur both in both two, documents two and three. So let’s look at the position of those words. So stood obviously is the second position and dog is the first position, so we need to have dog followed by stood. So if we look at the second number here, which is the position of the word, so we have dog that occurs at position two here, and stood that occurs at position three here. So since dog is immediately followed by stood, document two would be a valid page that matches that query. But if we look at document three, dog occurs at position six, and stood occurs at position three. And so since stood does not come after dog in document three, that is not a valid page that matches our search results, or our search query. So in a very, very basic way, this is what your Google search query is actually doing on the internet, it’s trying to, or what Google is doing is trying to basically index the entire internet, so that when you run a search query, it knows where that text is actually occurring in the web, and you can run more intelligent queries like this to find a little bit more accurate information and narrow down your search results.\nSo if we made an algorithm to actually do execute what we just did with dog stood, it would look something like this in a very formal sense. We haven’t shown you any formal algorithms in this structure yet. A formal definition of an algorithm will look like this, where we have input, output and the algorithm steps itself. So this is kind of like pseudocode here. So the input or in other words, called the precondition describes what the input will actually be to this algorithm or the expected input. So in this case, we’re expecting a two word phrase in the form of word one followed by word two, and this is in a quoted string. And the output or the post condition describes the expected or produced output from the algorithm. So given this this input, we’re going to produce this output, and our output is going to be an answer list of all of the numbers of the webpages that contain the phrase. And then the steps that we have here are exactly what I did just before, where we are going to index the web here. So the page number position number pairs for word one, so find all the matches for word one in our index and find all the matches for word two in our index. And then we’re going to go through each of those page number position pairs to see if we have a word that happens right after it. So for each pair in list one, see if there is a pair in list two such that the page number is the same as the one in list one. And the position number is immediately after the position number in the first page position pair. Looks a little bit more complicated than what I actually did before.\nSo that is a big step that we’re kind of making here and formalizing our algorithm definition. But you’ll see this a lot in computer science, especially as you move forward in our courses. But we can’t answer all of our search queries using this particular algorithm. This particular algorithm is expecting our word one word to our two word phrase here. And so it works perfectly fine for when we’re trying to look up the phrase cat sat, using our indexing list or our indexed list. But cat space stood doesn’t match our precondition, because it doesn’t have the quotation marks around it. We could answer cat stood, but we couldn’t answer cat or stood.\nSo how could we modify our algorithm in order to handle the other different types of queries? And so there’s a lot of things that we would have to think about when we did that, we would have to make sure we’re modifying our precondition for it to accept different types of search queries. And then we’re going to also have to modify our algorithm itself in order to handle those different types of search queries. So this is just some more complexities of actually formalizing an algorithm definition to make sure and one of the reasons why we would actually do that is to make sure our to make sure to verify that our input and output is correct. So making sure our algorithm does what we want it to actually do.\n",
    "description": "",
    "tags": null,
    "title": "Searching the Web",
    "uri": "/iii-topics/19-search-info/02-searching-web/"
  },
  {
    "content": " Resources Slides Video Script So finally, let’s talk about storing passwords securely in your applications. And there are a lot of different ways you can store passwords so that users could use them to authenticate. Let’s take a look at that. First, obviously, we could store the password itself. The user types in a password, we store that password in the database. Great, right? They type that password in again, we check it to make sure they typed in the same password. If they did, they let them in. That sounds like a really great system, doesn’t it? Hopefully, you’re cringing a little bit thinking about this. Because obviously, websites that have databases on them get hacked all the time. And if a hacker gets access to this database, they have your password. Simple as that. There’s nothing that they have to do, there’s no decryption they have to worry about, they get your password. And of course, one of the weaknesses of people on the internet is we tend to use the same password over and over again. Raise your hand, if you do that. I do. I use the same password a lot of places on the internet, it’s something I probably shouldn’t do. But I do. And so if somebody gets one of my passwords, they might be able to use that password to log into other websites that I use that same password on. So this is obviously not very secure. And the only thing that they need to compromise this is database access. As soon as they access the database, they have all the passwords, and it’s really simple so we probably shouldn’t do this.\nWhat if we store the passwords by encrypting them using a key? Well, that makes them a little bit more secure, which means now if you get the database, you also need to have a key to decrypt the passwords, or of course, some sort of a lookup table or a rainbow table to decrypt the passwords. And so you know, as soon as they get the database in the key, it would compromise all the accounts. So this is better than storing the raw passwords. But it’s still not great. And it’s not that hard. T\nhe really best way to store passwords is using what’s called a password salt. And this is because users are generally bad at creating good passwords. And so what we can do is take their short, crappy passwords and add a long string of random characters to it before we encrypt it. And so that will make the encrypted password much much stronger, it will feel like a longer password, even if the user’s portion of that password is very short. So it protects against all sorts of things like dictionary rainbow table attacks, Rainbow table attacks assume that passwords are pretty short. Most rainbow tables only work on passwords that are 10 characters or less. So if we add a salt of 25 characters to the end of a password, we’re guaranteed to get something that’s pretty long and hard to break using just standard encryption attacks. So if we store with a global salt, which means that we use the global salt value, the same salt value for all passwords, then a hacker would have to get the database, the encryption key we used, and that global salt value. And the nice thing is those are typically stored in three different places. The database is stored, obviously, as the database. The encryption key is probably stored somewhere in the software, and the salt value is probably stored somewhere in the software’s configuration. And so you need to get all three of those parts to break these passwords. If you didn’t have the encryption key or the salt value, you could try and brute force it, but it would take a long time. The downside is once you brute force a password, you could get the key and the salt and use that to compromise all the other accounts. So if you get one, you still get all the accounts compromised, but it is a little bit harder to do. The other thing you can do, of course, is you can encrypt all the passwords with a unique salt value. So every single user, every single account gets its own salt value. And if you do that, you need the database encryption key and the salt value for each user account in order to crack it. And that makes it even much harder. That means you can only compromise one account at a time, because every single time you need to get that salt value for that account. And so that makes cracking these passwords really, really hard to do.\nSo lastly, let’s take a look at one of the instances where people have really broken passwords very, very quickly. And this is from the Adobe hack from several years ago. And again, this is an XKCD comic. But what happened is Adobe misused an algorithm called block mode ds. And what that does is every block of your password gets chunked up. So every eight characters or so it gets broken, and it gets encrypted separately. And because they did that incorrectly, if the user had the same password in that first eight characters, it would encrypt to the same thing. And so what you end up with is basically the world’s largest crossword puzzle. So for example here you would have weathervanessword and then you have name one. If you’re a fan of redwall, you might understand that weathervanessword might have something to do with Matthias from redwall and so this might be Mateus1. Here you have favorite of the 12 people apostles - Matthais, and then you have all these other ones like alphaobviousmichaeljackson. I’m guessing this is ABC123- the famous Michael Jackson hit from when he was in the Jackson5. It’s an obvious password, and it’s alphabetical. So there are lots of different examples of bad passwords, being stored improperly not correctly salting and hashing them like you should and this is one that Adobe definitely got called out for back in the day. So finally, if you want to take a look at your own passwords and see how secure they are, there’s this website howsecureismypassword.net. You can go online you can type in your passwords and it will give you an idea of how long it would take to crack that password.\n",
    "description": "",
    "tags": null,
    "title": "Storing Passwords",
    "uri": "/iii-topics/17-cybersecurity/02-storing-passwords/"
  },
  {
    "content": "Lab 1 Installing Python ",
    "description": "",
    "tags": null,
    "title": "Installing Python",
    "uri": "/x-cis115-labs/1-installing-python/"
  },
  {
    "content": " Resources Slides Video Script Next, let’s take a look at another form of compression called Huffman coding. Huffman coding uses the frequency of the letters in a piece of text to reduce the amount of space that they take up in the encoded data. To do this, we will count the occurrences of each character in our text. And we’ll use that count to make a binary tree with the data. Then the paths of the tree to each character give the codes that we use for the Huffman encoded data. This is a little bit complex.\nBut let’s take a look at an example and see how this works. Let’s say we’d like to send this particular text using a Huffman tree. This is an example of a Huffman tree. If we count this just as plain ASCII characters, it would take 298 bits, which is 8 times 36 characters to send this data. So now let’s look at how we would encode it into a Huffman tree. The first thing we would do is we would count the number of occurrences of each character.\nSo let’s look at an example of how we would convert this into a Huffman tree. The first thing we would do is we would count the frequency of each character. So let’s take a look at the spaces we have 1 2 3 4 5 6 7. So we have seven space characters in this particular example, so we can make a list. On this slide, we see the list of some of the most common characters in that text. There are seven spaces, 4 letter A’s, 4 letter E’s, 3 F’s, 2 H’s, 2 I’s, 2 M’s, 2 n’s, and so on.\nSo with that data, we can then construct a binary tree by using the frequency of the characters to determine where they go in the binary tree. Since the space is the most frequent character, we’re going to put it at the very top of the tree, whereas least frequent characters, for example, a p would go toward the bottom of the tree. So if we follow the Huffman example algorithm, we’ll see that we create a binary tree that looks something like this. And this is pretty complex. And we’re not going to exactly talk about how to build this binary tree. But there is a very unique algorithm that you’ll learn about later on that can allow you to do this.\nSo now we look at this tree. And we see that the space character is way over here. We mark it for you. So the space characters right here. So to get to that space character, we will make right, here, right here, and right here. So the space character, in terms of directions would be RRR. Likewise, the E, we would go left, left, left. So E is going to be left, left left. This is the space, this is the E. And so in Huffman coding, we would use the direction that we go in the binary tree to become our data. So if we encode this, so that right is ones, we would do 111 for the space, for the E, it would be 000. Pretty cool, isn’t it?\nLikewise, if we want to get to the letter A, we would go left, then right, then left, so A would be left, right left to get A. So that would be 010. Pretty cool, isn’t it. So we’ve taken characters that normally need eight binary values to represent them. And we can represent them here with this tree in anywhere from three to five characters. So if we look at this Huffman example, broken up, we’ll see something like this, the letter team becomes 0110, H is 1010. And if we go on, we can eventually find the A, which is going to be this one right here, th, this, space, is, space, A n, space, example, we saw that he was 000. So right here, we’ve got a really big improvement. We’ve gone from 288 bits of data all the way down to 135 bits of data. So we’ve nearly cut it in half a little bit more than half actually, to make this work.\nNow, of course, Huffman trees do come with one particular caveat that we have to talk about. If we want to transmit this data encoded using a Huffman tree, we would also have to send a representation of the Huffman tree itself to allow this data to be decoded. And that can add a significant amount of overhead on small texts like this. In fact, the amount of data we would need to send this Huffman tree would be way more data than we needed to encode the original message even completely uncompressed. So while Huffman tree is a very powerful encoding system, It really works well when you’re sending large amounts of text like an entire book, then using a Huffman tree to encode that you can get significant savings in your compression. So once again, we’ve got a little example of the Huffman tree encoding problem that you can try on the next quiz.\n",
    "description": "",
    "tags": null,
    "title": "Compression - Huffman Coding",
    "uri": "/iii-topics/15-compression-error-checking/02-huffman/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re going to continue our talk on HTML and start looking a little bit at HTML tags. As we mentioned before, the language itself works off of a series of tags, tags are denoted by a less than and greater than symbol with the name of the tag in between. Now, some tags may also actually have attributes in between there, but we’ll get to that later. To make a basic web page, we need four primary tags, HTML, head, and body. But we’ll also add in title there, so we can actually have a name for our webpage as well. The HTML tag primarily wraps the entire contents of the web page, although not all of those contents are actually displayed directly on the web page. For example, the head tag will actually have some meta information about the page, but it’s not actually rendered in the web browser, the title tag actually belongs to the head tag. And while it’s not rendered on the page, it’s actually going to denote the name of the webpage in things like your tabs. So when you open up a page in a new tab, and you have the name of the webpage, there, that’s where that comes from. The body tag is going to have all the rest of the content of the actual website.\nSo the things that you would typically see on a web page will be contained inside of that body tag. But let’s take a look at an example of a basic web page. so here we can see a lot of the tags that we’ve already talked about the HTML tag, the header tag, the title tag and the body tag. But we also have this doctype up here at the top, this tag is a special tag that we don’t necessarily have to include most modern web browsers will actually render HTML without it. But what this tag does is it informs your web browser what type of content it’s actually going to be displaying. So when you make a request to ace a web server, and the webserver responds with content on the web browser will actually look at this tag and determine how to actually treat this particular web page. But other than that, you can see the gist of our website is actually between these two HTML tags. Now, we talked about tags already, but the tags themselves actually have an open tag and a close tag. There are some tags that will actually be self closing and when we have one, but I’ll show one of those here in a little bit. But the open tag is just as what we’ve seen already the less than symbol and greater than symbol with a name of the tag in between. And then we have a corresponding closing tag that has the same name.\nBut with a slash to start out with, that’s going to indicate the close or the end of that particular content inside of that tag, we have the same thing with the head tag, we have an open and closed head tags, same thing with the title head tag that will typically come first up here towards the top of your HTML or inside of your HTML tags. And then the body tag will follow where our body tag is we have the content of our actual web page. And then here, we’re just doing a simple text for now. But let’s take a look at how this would actually look like when it’s rendered by the browser. But let’s go ahead and type in our tags that we showed in the slide down there. So we first need the doctype, which indicates the contents of this file our HTML. And then we start out with our HTML tag, our open tag, and I like to get into the habit of always doing the open tag and then immediately typing out the closing tag. That way you don’t have any hanging or loose HTML tags. So let’s do our header tag, then close head. And then we have our body tag, and our closed body tag. inside of our body tag, we just have a simple Hello World. And inside of our head tag, we have our title.\nSo Open title, close title. And then in between here, we’re going to say homepage. Now, let’s save that out. So I can open this file up. So this is just the actual RAW file being loaded into my web browser. So we have our simple Hello World here. And most web browsers like Firefox or Chrome You can actually Inspect Elements here and actually see the contents of the webpage itself. So here is my head tag that we had before which we have header. You can ignore the script here. This is part of some of my browser extensions. But you should see hello world here, and the end of my body tag in the close my HTML, this is a really great way to debug or look at your web page to make sure everything that you put here is actually being rendered. But let’s take a look at a few more HTML tags. So the header tag is going to be indicated using H and then a number you’ll typically see this go from h1 through h6, h1 being the largest header that you can make, and h6 being the smallest P is going to be for your typical paragraph. So if you want to put text anywhere on your webpage, that’ll be the best way to do it, the paragraph tag will actually add some whitespace before and after the tag itself. line breaks here, this is actually a self closing tag, as we talked about before, but we haven’t actually seen one yet, a line break will actually force all the content to the web page to be separated on out onto a new line itself. And this also goes for like a horizontal rule. So if you have a line across your web page, HR, and then a which has a self closing tag as well. But br here break is going to self close, you won’t actually have an open tag and a closing tag, you just have this particular tag. So it opens and then closes all on the same line. So open and then closes, where typical closing tag will actually have the slash before the name of the tag.\nThe ‘a’ tag here, this is a typical link that you would expect to click on and your web page. So and but it is called an anchor tag, O L and ul which are ordered and unordered lists, so numbered or bulleted lists in that order. And then inside of a ordered or unordered list, you have a list item. So this is what you will actually use to denote each item in the list. But let’s actually go ahead and try to add a list to our webpage. So here are two simple lists that we have here, O L and ul unordered list and a unordered list. And I just have some default items in here. But let’s try to get this on to our actual web page. So here was our original web page that we just did a little bit ago. And I’m actually going to go ahead and change my hello world here to be wrapped inside of a header tag instead of having it directly into the body. But then, let’s go ahead and start getting out some of our other tags that we already did. Let’s do a simple paragraph here. This is a sample website. So in our sample website here, let’s go ahead and add our ordered lists over here. So remember, r o l is the ordered list and ul is the unordered list.\nSo I’m going to go ahead and start typing this out here, O L, and then close o l remember to always add your closing tag for an open tag. And then let’s do our list items. And I’m going to do the same thing for the unordered list. But all we need to do here is change o l to ul. And note that my formatting here with the indentation of the tags is not required, I could actually toss all of this all on one single line and the webpage would still render just fine. But this is just to get into some better formatting practices to make your HTML a lot more readable if someone is actually going in here to look at your webpage or edit your code. But if we save that, and go and refresh our local file, we now see something like this, where we have our paragraph text here. We also have hello world as part of a header tag now, so it’s much larger than it was before as just plain text. And notice that there is some white space here between I have my paragraph tag here. And likewise, we have a ordered list and our unordered list. But let’s continue on and checking out more of these HTML tags. One of the most common things that we actually use to create an interactive web page, of course, are links, right or anchor tags. And so an anchor tag works just like this. Will we have the open a tag and the closing a tag, but now we’re actually introducing attributes to our tag.\nSo most attributes are allowed to have any number of specific attributes. These can help define other properties or things that this particular tag actually does. So in this case, for our anchor tag, we’re going to define an href attribute, this href attribute is going to be equal to http cs ksu.edu. This is going to be the location or the URL, the content that is actually loaded, when you click this link, and then the text that actually appears to the user is going to be the click me here. This can be pretty much anything. So you could actually make almost anything clickable in HTML. So let’s say if you wanted to make an image, a link, you could put the image in here and the image would be clickable to that external URL. Okay, so let’s go ahead and add this link into my webpage. So I am going to go ahead and add that up here towards the top underneath my paragraph tag. So we have the A for anchor, and then the corresponding closing tag. And then we had clicked me here as part of the text to visit. And then we want to actually put the attribute href in here. So we have a particular spot to actually go to when we click OK. So the location that I want to go to is HTTP slash colon CS dot k asu.edu. If we save that, and refresh our page, we can now see the click me. And when I click it, it takes us to the computer science homepage. Now, you can also again, right click and open up a new tab. Notice, right, we forgot to mention earlier, notice that the title of our web page is loaded up here as part of the tab. If you want this to open up in a new tab, we can add a target here. And if you set the target to be blank, it actually ends up loading into a separate tab. So that way, you don’t have to actually press back and forth.\n",
    "description": "",
    "tags": null,
    "title": "Basic HTML Part 1",
    "uri": "/ii-internet/13-webprog/02-basic-html-1/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Beocat Tour - Kyle Hutson",
    "uri": "/iii-topics/14-hpc/02-beocat-tour/"
  },
  {
    "content": " Resources Slides Video Script The first thing we’re going to cover in this module is the concept of binary numbers. Binary numbers are really the core of everything that a computer does. And so we need a way that we can convert the base 10 numbers that we know today such as 24 42 86, into binary numbers that only use ones and zeros.\nSo let’s start with simple natural numbers, the counting numbers, the whole numbers that are greater than zero. So let’s take a look at this example. In here we have a binary number 00101010. And above that binary number we’ve put in the value of each place. So in a decimal number, each of these places would be powers of 10. So the first place would be one followed by 10 100 1,000, and so on. And so we know that the number 1234 would be 1, 234.\nIn this number, however, we see that we only have ones and zeros, but they use the powers of two instead of the powers of 10 in each place. So let’s look at how we can calculate the actual decimal value of this binary number. To calculate the value of a binary number, all we have to do is look for the places that have one. And then we know that this is one times 32. We have a zero here, so there’s no value there. We have one here. So this is one times eight. We have a zero here, we have a one here, so this is one times two. Notice that this is the same thing that we do when we’re using decimal numbers. Remember, the example I just gave 1234 would be one times 1000 plus two times 100 plus three times 10 plus four. So this value is 32 plus eight plus two, which is 42.\nAt this point, if you are a fan of the work of Douglas Adams, you will find a definite pattern in the rest of this lecture, we’re going to look at many different ways that we can encode the same number 42, in all sorts of different ways in our computer system. So as we saw with this example, it’s really easy to take a binary number and convert it into its decimal value. All we have to do is multiply the ones by their place values in the binary number and then add the resulting number together to get the binary number.\nWhat if we want to go the other way? How would we do that? For example, let’s say we want to encode the number 86 as a binary number. To do this, we would have to again know our places are powers of two. So first, look at 128. Since 86, is less than 128, we know we can’t have any values there. So we’ll give that a zero. The next place would be 64. Since 86, is greater than 64. We know that we have at least one value of 64 in here, and now we’ll have to do at Minus 64 and we will get 22. So now we go to our next power of two, which is 32, 32 is greater than 22, which means we’ll give this a zero, then we will have 1616 is less than 22. So we get a one here, and then we’ll subtract 16 and we will get six. So our next power is eight, eight is greater than six, we’ll have a zero, then we’ll have four, four is less than six. So we’ll have a one here, and then we subtract four and we get two, then we’ll have a two that is the same value. So we’ll put a one and then two minus two is zero. So our ones place will have a zero. And so that tells us the binary number 01010110 is equal to the decimal number 86.\n",
    "description": "",
    "tags": null,
    "title": "Binary Numbers",
    "uri": "/i-concepts/07-encoding/03-binary/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "High Tech Heroes #32, part 1: Paul Baran",
    "uri": "/ii-internet/12-internettech/02-high-tech-heros/"
  },
  {
    "content": " Resources Slides Video Script The device that Jack Kilby pioneered is shown here, it is the first integrated circuit. What we have here is a piece of germanium with several components printed directly on to the semiconductor material and a few wires coming off of it. And while it may not look like much now, if you connect the wires up properly, you can actually see a sine wave on an oscilloscope produced by this device. They call this device an integrated circuit because the circuit between all of the components and the wiring is all connected directly onto the piece of germanium.\nNow, of course, you might realize that we don’t make computer circuits out of germanium today, and so there’s a little bit more work that needed to be done. This lies in the work of another engineer named Robert Noyce. Robert Noyce worked at Fairchild Semiconductor and was working on a similar idea to Jack Kilby’s. However, he decided that instead of using germanium he would build an integrated circuit using silicon a very similar element. And it turns out that using silicon was a much better choice, and he was able to overcome some of the design flaws of Kilby’s design working independently at about the same time.\nA few years later, Robert Noyce left Fairchild Semiconductor along with Gordon Moore, another engineer to create their own company focused on developing and building these integrated circuits. Do you want to guess what that company is? That company is Intel. It was founded by Robert Noyce, Gordon Moore and Andy Grove, pictured here in 1968. And unlike Fairchild Semiconductor, who didn’t really see as much value in the integrated circuit, Intel very quickly realized that the integrated circuits would be the future. And so they focused on designing, creating and manufacturing these new integrated circuits using semiconductors.\nGordon Moore is another important engineer in the history of computer science. You’ve probably heard of Gordon Moore based on his namesake Moore’s law in 1960 Five Gordon Moore wrote a paper called cramming more circuits onto integrated components. And in that paper, he discussed what the future of these integrated circuits might look like. He predicted that the number of circuits on a chip could double about every year to 18 months for another 10 years at most. And of course, it turns out he was much more correct than even he thoughts shown in the graph. Here we have the number of transistors on a particular chip versus the date of introduction. And you’ll notice that throughout the lifetime of computers all the way through about 2010 Moore’s Law held very fast, it was a very good way of measuring the quick growth of power among computer chips.\nSo in 1971, Intel finally released their first central processing unit or CPU, the Intel 4004, which is pictured here. This chip may look very small, but it had 2300 transistors built on it all in the size of a small finger. And the circuits inside of here are 10 times smaller than the human hair. This was a really revolutionary chip and it was used in a variety of places. In fact, one of the first devices to use this chip was an adding machine such as the ones you see at banks or accounting offices today. This chip is a better example of a microcontroller. A microcontroller is a chip that includes everything a device needs to think in function all on a single little chip.\nAnd so this is a chip similar to an Intel 4004 that’s had the top shaved off. And so if that chip is the size of a finger, this little interior part is the size of the fingernail on that finger. And inside of there is where the transistors actually lie. And so here you can see those filaments connecting to the wires that are smaller than a human hair that make this device work. These microcontrollers form the basis of today’s modern computers, but that’s only part of the story. The other part of the story is looking at how we make today’s modern computers actually react to input and operate in the real world will take Look at that in the rest of this module.\n",
    "description": "",
    "tags": null,
    "title": "Integrated Circuits",
    "uri": "/i-concepts/08-architecture/03-integrated-circuits/"
  },
  {
    "content": " Resources Slides Video Script In this module, we’re going to talk about the history of the Internet. The history of the internet is a very interesting topic in computer science. But I think it’s one that we don’t think about very often today, we just take the internet for granted and just know that it’s always there. So let’s take a look at where the internet came from. The internet was really built to solve a unique problem.\nNetworking is complicated. And in the early days of computer networking, the only way two computers could talk to each other was via a direct connection between those systems, much like the phone systems of the olden days. And so we’ve already seen some network connected computers such as the NLS system that Douglas Engelbart talked about, for example. But networking was really complicated. And so because of this, we had to have direct connections. And it was very slow and very tedious to have really powerful computer networks. We ran into problems that were very similar to the tyranny of numbers problem that we talked about in an earlier Module. So the internet was really created to solve that particular problem.\nOne of the visionaries of the creation of the internet was J.C.R. Licklider. Licklider was a computer scientist at the defense, the Department of Defense Advanced Research Projects Agency, or DARPA. And he was interested in how we could build computer systems to aid the work of his agency. And so his work was really around some of the earliest networked computers such as ones at MIT in Santa Monica. But the real frustration he had was each one of those computer systems required a different terminal and different commands to interact with it. And J.C.R. Licklider really dreamed of having just one computer terminal on his desk, and one set of commands that he had to memorize. And from that terminal, he could access any computer system nationwide to get the information that he needed. And so he really famously talked about this and came up with some really interesting ideas. Let’s take a look at a video of J.C.R. Licklider talking about his ideas For what became the internet.\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/ii-internet/11-internethistory/02-introduction/"
  },
  {
    "content": "The full video of the Mother of All Demos is linked below, but it is nearly 2 hours long. While we’d love to have you watch the whole thing (and you are more than welcome to do so), we wanted to highlight a few of the more important parts. Listed below are the timestamps for a few important sections and a bit of discussion about each one. Feel free to skip around to watch a few of these sections to better understand what Douglas Engelbart was presenting.\n1:40 - 3:11 - Introduction. This gives a great overview of the project, and ends with the great line that he will attempt to show, rather than tell, what the NLS system is capable of. 12:53 - 14:40 - Wikis. Here he shows that you can give items a code and then click on the item to get to more information. This is the basic concept behind hyperlinks that make up the World Wide Web, but also the wiki-style of information storage popularized by Wikipedia. 15:35 - 16:30 - Graphics. Here, he expands upon the links shown earlier by adding a graphical map of the locations he needs to visit. So many of our organizational and productivity apps can directly trace some of their functionality back to NLS as shown here. 21:42 - 25:45 - Presentations. Through his use of a “chain of views” Engelbart is able to create a presentation using NLS. This is a precursor to modern applications such as PowerPoint. 30:31 - 32:48 - Mouse. Here Engelbart shows a bit more information about the devices he is using to interface with NLS, including his mouse. Oh yeah, and remote video as well! 42:42 - 43:40 - CRT. Here he shows some remote video of the CRTs that are being used to create the views the audience sees. 1:02:32 - 1:03:45 - Word Processing. While creating documents and papers may seem like a very common use of computers today, it’s very telling to see that it was nearly one hour into the presentation before Engelbart talks about the ability to use NLS to edit papers. This really shows how much focus he placed on building truly usable computer systems that didn’t rely on paper at all. 1:04:01 - 1:06:50 - Email. This is a bit of a surprise! Engelbart and his team needed to communicate and collaborate asynchronously, and came up with a technique for sending and receiving messages. While these weren’t delivered via the internet, many of the concepts and conventions directly correlate to our modern email systems. The “content analyzer” is also an early form of regular expressions. 1:13:03 - 1:16:38 - Live Collaboration. This is honestly the coolest part! Since NLS was a shared computer system, it was easy to build systems where users could collaboratively edit and work with data. It wasn’t until over 40 years later with the development of Google Docs that such capability was widely available in mainstream software. They even predict the idea of webcams! ",
    "description": "",
    "tags": null,
    "title": "The Mother of All Demos",
    "uri": "/i-concepts/10-hci/02-mother-of-all-demos/"
  },
  {
    "content": " Resources Slides Video Script Charles Babbage (Slides 23-17) Charles Babbage designed many different engines during his lifetime, but very few of them were actually built.\nIn the previous video, you saw a completed version of the Difference Engine built very recently, which we actually see here. And his Difference Engine was very revolutionary because it proved that you could build a device that was purely mechanical, that could perform calculations. But the difference engine was actually a very small part of Babbage’s overall vision for building these mechanical computational devices.\nHe also designed another engine that he called the Analytical Engine, and it was never completed during his lifetime and thus far it has not been completed in modern day time either, but there are small parts of it that exists. For example, this is one small part of it that is in a museum. The analytical engine would have been a true multi-purpose computer. Instead of just performing Newton’s method of divided differences, it was capable of performing all sorts of different mathematical operations.\nBabbage’s Analytical Engine would have been programmed using input cards, such as what you see here. And one surviving portion of the Analytical Engine is the Mill, which is a general purpose computational device that can perform all sorts of different mathematical operations. It’s very similar to the CPU in modern computers.\nIn addition, he would have created a device called the store, which was capable of storing and retrieving up to 1000 numbers at 40 decimal places, which is roughly 16 kilobytes of data, which is really respective for the 1800s. And parts of the design for the store were actually used in the design of the Difference Engine, which is the picture you see here. So what have looked very similar.\nAnd so because of all of his work, designing and thinking about how you would build these multipurpose computational devices, we refer to Charles Babbage as the father of modern computing. Unfortunately, a lot of his designs were forgotten over time. And it wasn’t until very recently that his work was really recognized as being so revolutionary in the history of computing science. In a later lecture in this class we will actually analyze some more work of Charles Babbage, specifically the Analytical Engine, and how it fits better into the history of computing science.\n",
    "description": "",
    "tags": null,
    "title": "Charles Babbage",
    "uri": "/i-concepts/01-what-is-computing-science/03-babbage/"
  },
  {
    "content": " Resources Slides Video Script Our next famous woman in computer science that we’ll be talking about is Rear Admiral Grace Hopper. Grace Hopper enlisted in the Navy and worked on the Harvard Mark I computer, as well as the UNIVAC, a successor to the ENIAC, and we’ll talk about the UNIVAC and ENIAC computers in another lecture. So grace also developed a programming language called FlowMatic which was later adapted into a language called COBOL, which is still somewhat used today. COBOL is traditionally a language that was used very heavily in the financial industry, because it was used to generate a lot of financial reports. You don’t see it a whole lot now, you may see it used occasionally at places like banks, or accounting firms and things like that, but it’s not very widely used anymore.\nBut beyond that, she was a truly a pioneer and out of the box thinker for her entire life. And as you’ll see in the following videos, Grace Hopper is a pretty sassy lady but a pioneer in modern computing. She was also pretty famous for her description of a nanosecond in the Dave letterman show, which you’ll see here in just a little bit. Another thing here every year, there is a Grace Hopper conference to celebrate diversity and inclusion and women in computing. And so there’s actually scholarships available for students if you would like to attend this conference. And it’s something that I would highly recommend if you ever get the chance, it is truly a great experience to actually participate in.\n",
    "description": "",
    "tags": null,
    "title": "Grace Hopper",
    "uri": "/i-concepts/04-programming/02-grace-hopper/"
  },
  {
    "content": " Top Secret Rosies Website\n",
    "description": "",
    "tags": null,
    "title": "Top Secret Rosies Website",
    "uri": "/i-concepts/05-universal-computers/03-top-secret-rosies-web/"
  },
  {
    "content": " Resources Slides Video Script Now that we have an understanding of the resources available at the time, let’s take a step back and think about what it would be like to be an inventor in let’s say the 1600s for a minute. If you wanted to design a machine that would aid in the computation of complex values, what should it do? What does that mean for a computer? Right? If we’re trying to avoid a lot of the human error that we have in calculating specific values, or make our lives easier, what should that computer what should that device actually do?\nBased off of that discussion, or based off of that thought, I’m going to suggest four different things that a modern computer should be able to do. It should be able to compute some form of complex value and not just one calculation, but many, many types of calculations. It should be able to accept variable input. So not just a simple calculator that can accept numbers, but accept all sorts of different things like even a program, for example. It should be able to store information and should also be able to output that information as well. Because what’s the point of computing something if you can’t actually see what the result is? So you might see that many of these actually compared to the functions of computers today, right? The processor, a CPU that can compute value, programs for variable input, your RAM or your hard drive for storing information and your monitor or your printer that can output the results. Before we go further, right we need, we’ll need to figure out some way to compute values. And as we discussed earlier, human error is a major problem here. So regardless of how well the machine is capable of computing those values, we need to reduce or eliminate that factor of human error. So we want to design something that doesn’t have any humans involved in the calculation. Because if there is, like the abacus or the slide rule, the result is only as good as the person actually operating the machine.\nSo one step into that in 1642, Blaise Pascal invented the mechanical calculator to solve that problem. And now it was originally designed to help his father calculate tax revenues and of course if you know a little bit of history during that time period, taxes were pretty big deal and you know, if you collected too much from your townspeople, right, everyone grabbed their pitchforks and torches, and if you were the guy collecting taxes, if you didn’t collect enough, the king would go, you know, off with your head, that sort of thing, right? So this is a pretty big deal. Any sort of error could really literally mean life or death. So this machine was capable of addition and subtraction and could simulate multiplication and division by repetition. So, you know, essentially the beginnings of the calculator that we know and use today. Unlike the abacus, there’s much less room for human error. Here you input the numbers, and out come a result.\nTo further improve on Blaise Pascal’s design, in 1673 Gottfried Leibniz created a stepped drum, commonly referred to as a Leibniz wheel that greatly increased or enhanced the capabilities of any mechanical calculator that used it. With the innovations of these two guys here, the Pascal and Leibniz, the world now had the capability, at least the mechanical capability, to perform calculations.\nThat really led to Charles Babbage. And now in 1823, Charles Babbage designed his first Difference Engine, and built the prototype that was showcased in his study in his home for quite some time. Now, this is the, the larger version of that prototype, but the difference engine itself was capable of simple mathematics and could solve even polynomial equations up to six digits. So, this was a huge step forward, but it was only a small part of what Babbage had actually envisioned. The Difference Engine is what we call a fixed program or a single purpose computer, meaning that it could only do the task that it was built for; it couldn’t be reprogrammed to do anything else like our modern computers could. The Difference Engine could calculate the value of any seventh order polynomial, given the correct input by using method of finite differences. While the differentiation itself in its entirety wasn’t built during his lifetime, Babbage’s idea here was really truly revolutionary.\n",
    "description": "",
    "tags": null,
    "title": "What is a Computer (Pt. 1)",
    "uri": "/i-concepts/02-early-computing-machines/03-what-is-a-computer-pt1/"
  },
  {
    "content": " Resources Slides Video Script So what is an algorithm in computer science? A good definition for an algorithm is a finite list of specific instructions for carrying out a procedure or solving a problem. If you think about it, every computer program we write consists of many different algorithms. Because as we’ve learned, writing a computer program is exactly that. It’s giving the computer a list of very specific instructions that we’d like it to carry out so that it can perform a task or solve a problem for us. So let’s look at an example of what an algorithm looks like. One of the most common algorithms used today is Euclid’s algorithm. Euclid was a Greek mathematician from 300 B.C, and his algorithm was developed to find the greatest common divisor of two numbers. That greatest common divisor if you studied algebra is used to reduce fractions. And even today in our computers and calculators. We use a modified version of this algorithm to do exactly this task. It really is one of the most efficient ways to To do this, so let’s explore what Euclid’s algorithm looks like and take a look at an example.\nSo Euclid’s algorithm consists of four simple steps. The first step is you start with two numbers labeled A and B. In the second step, if either of those numbers is zero, the answer is obviously the other number. However, if neither of those numbers is zero, we’ll take the smaller number, and we’ll subtract it from the larger number. Then we’ll repeat those steps two through four until an answer is found. So what we will repeatedly do is take the larger number, subtract the smaller number from it, which will make the larger number smaller. And we repeat that process over and over and over again until we find an answer. So let’s take a look at an example and see how this works. So let’s look at an example of finding the greatest common divisor of 1071 and 462. So we’ll start with our two numbers 1071 and 462. Now, we know that we need to label these numbers A and B. So I’m going to label 1071 as A, and I’m going to label 462. as B. In the algorithm, we see the first step is to see if either of these numbers are zero. So looking at these numbers, 1071 and 462, neither of them zero, so we can move on to Step three, which is subtracting the smaller number from the larger one. So we’ll replace a with 1071. And we’ll subtract 462 from that. And that will give us the result 609. So now our numbers are 609 and 462. Once again, we start over at step two, we see that neither of these numbers are zero. So we do the same thing again, A is still our larger number. So we’ll do 609 minus 462 and we will get 147 and B will still be 462.\nSo we can keep repeating this process. Now B is the smallest number, so we’ll do 462 minus 147 and we will get 315. Now we have 315, 315 is again, let the larger number, so we’ll subtract 147 again, and this time we will get 168. And 168 is greater than 147 again, so we will subtract 147. And we will get, I’ll go over here to a second column, we will get 21. So now our numbers are 147 and 21. So once again, we need to subtract 21 from 147. And I’ll just kind of do this quickly. We’ll get 126 then we’ll get 105. Then we’ll get 84, 63, 42. then we will get 21. And we’ll notice that here, they’re both the same number. So if we subtract that again, we’ll get zero. And so now that we have zero as one of our numbers, we know that the greatest common divisor of 1071 and 462 is 21. This slide shows that example worked out a little bit clearer so you can follow it. If you’re interested in the greatest common divisor algorithm written by Euclid, I encourage you to pick just two random numbers and see if you can perform this same process. It should work on any two random numbers you pick, but we were very careful in picking 1071 and 462. So we got a larger number as the greatest common divisor. Don’t be surprised if you find out the answer is something small like two or three. That is pretty common as well.\n",
    "description": "",
    "tags": null,
    "title": "What is an Algorithm",
    "uri": "/i-concepts/06-algorithms/03-what-is-an-algorithm/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Margaret Hamilton - 2017 CHM Fellow",
    "uri": "/i-concepts/09-software-engineering/02-margaret-hamilton/"
  },
  {
    "content": " Resources Slides Video Script Boolean Operators (Slide 6) And Let’s take a look at what the Boolean and operator does out in this Venn diagram here we’re going to kind of use these to showcase where the Boolean statements that we’re checking out with the Boolean operator where these statements are actually evaluated to be true. So if we assume that we are two facts here, A and B are both true. So let’s say this inner circle here, this left circle here represents a and this right circle here represents B and the square on the outside represents everything else. So when a and b are not, so if A and B are both true, then the statement evaluates to true. So the left hand side and the right hand side of the operator both must be true in order for the whole statement to be true. If A is false, or B is true. false, then the whole thing would be false. Now if we introduce a third fact, see, we kind of get the same results, right. So similar kind of story with the Venn diagram. Here we have a, b, and c. But notice that this little square here where we were actually filled in over here is no longer filled in. And that’s because all three facts must be true for the whole statement to evaluate to true. So a has to be true, B has to be true. And C has to be true in order for the whole statement to evaluate true.\nOr So we’ll have similar representation here for the OR operator where the English word is the representation in Python of the OR operator the double bar symbol, so this is just the two vertical bars from your keyboard that is the OR operator in Java, C sharp and other programming languages and then a capital V is great. To be the OR operator for Boolean algebra. So let’s take a look at how or operates. So if we have the same statement, as we have before the same two premises A and B both being true initially, and the circles are kind of the representation of the same thing here, but the OR operator will evaluate to be true if either side of the operator are true. So if the left hand side is true, or the right hand side is true, the whole thing will be true. So if A is true, or B is true, so left hand side and the right hand side, so if A or B is true, then the whole statement is also true. And so nothing on the outside will actually be filled in quite yet. And the similar kind of story is for a third fact or fifth, that one has to be true for the whole statement to be true. So if any of them are true, the whole thing is true, but things kind of get tricky when we’re in introduce this next operator the exclusive OR exclusive or you won’t really find normally in programming languages. The Exclusive OR can be simulated using and or and the next operator that we’ll be covering here in just a second.\nXOr But the exclusive OR works in a little bit of a different way than the regular or the exclusive OR operates very similar to what we would expect the normal or operator to be in the sense that if A is true, or B is true, the statement is true, but notice that a and b is now false. If a and b are both true, the statement is false. So the exclusive OR operator is expecting one or the other. So that means the left side or the right side must be true, but not both. That is where the exclusive portion of the exclusive OR or the X or operator actually comes out. If I introduce a third fact things get to be a little bit more difficult to understand because now I would expect it to be kind of similar pattern as we have up here just to be, or on my just with my two facts, everything in the middle would be white, but everything on the outside would be red. But you notice when when we have all three to be true, all three can be true and the exclusive OR would still be true. Now let’s take a look at why that would be the case.\nXOr White Board Example So let’s take a look at the example that we saw on the slides. We have our facts a, and our XOR operator. So we have a XOR B XOR. See, now if we kind of do our substitutions here now we could substitute ones and zeros here are true and false. So let’s go ahead and substitute our Boolean values here for our variables. So if A is true So we have a XOR B, which is also true. And C, which is also true. Now, just like most of your math problems, even when you’re just doing multiplication and division, you’re always going to evaluate your statement from the left to the right. So we need to first evaluates true x or true now XOR Exclusive OR exclusive right, the left or the right can be true, but not both. Since the left hand side of my operation is true, and the right hand side of my operator is true, this portion of the statement evaluates to false. Then all we need to do then is keep on working the rest of our statements. So we still have one XOR left. So we have false x or true? Now exclusive or one side or the other must be true but not both. So false x or true is actually true because both sides aren’t true. So this statement you say a false x or true, evaluates to true. So the whole thing true x our true, false XOR true, ends up being true.\nNot (Slide 6) So our last Boolean operator here is the NOT operator. The NOT operator acts pretty much like negation, as you would expect, like multiplying something by negative one not something is the opposite of what it actually is in Python as the previous Boolean operators the and and the OR operator, the NOT operator in Python is very English light not but Python is kind of weird. You will also see the exclamation point In some operations, but it doesn’t mean the traditional knots or negation operator as in many other programming languages. So, again, you’ll see not in Python, the exclamation point, this is going to be things like Java. And the weird sideways l here, this is going to be your Boolean algebra. So let’s take a look at what the Boolean operator not actually looks like. As I mentioned, the NOT operator is a negation, so not something as the opposite. So not a or not true is false. So not a if I write a here, so everything in the circle is a so when A is actually true, so everything inside of the circle then everything on the outside of a is actually true because it’s negated and similar idea for B when B is true, everything But B is true. So the whole statement is evaluated as such and similar idea if I introduce a third fact. So if I have three facts A, B and C, not B means that everything but B is true, just like in this example here.\n",
    "description": "",
    "tags": null,
    "title": "Operators",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/02-operators/"
  },
  {
    "content": " Resources Slides Previous Versions Video Script [Slide 1]\nHello and welcome to the Computational Core program!\nMy name is Emily Alfs-Votipka, and I’ll be one of the instructors for this program. My contact information is shown here, and is also listed on the syllabus.\n[Slide 2]\nThere are many other instructors and TAs for this program that you may interact with or see in the tutorial videos. They all have been instrumental in the development of this program.\n[Slide 3]\nIn this course we will primarily use a K-State email group (cc110-help or cc110-help@ksuemailprod.onmicrosoft.com) to communicate. Email sent to this address is forwarded to all instructors and TAs. Our replies to you will also be shared amongst the instructors and TAs so we all have access to the assistance you have already received. We will respond to you within a business day So a question emailed Friday night may not receive an answer before Monday.\nIf you wish to pose a discussion topic to you classmates, you should use the discussion feature in Canvas. Please note that asking a question on a discussion forum is not the same as emailing cc110-help; we will certainly monitor the discussion channels, but not with the same speed as the “help line”. Please read and adhere to the guidance on Netiquette in the syllabus for all electronic communications.\n[Slide 4]\nIn addition to email and Canvas, we’ll be using the online learning platform Codio for most of the programming tutorials and projects in this program. We’ll also discuss how to use Codio later in this module.\n[Slide 5]\nThe Computational Core program consists of several courses, and each course contains a number of learning modules. There are about 30 modules in this course. Each module will usually consist of some lecture material and quizzes, and there are a few modules which include a programming component. The modules themselves are gated, which means that you must complete each item in the module in order before continuing. In addition, the modules enforce prerequisite requirements from other modules. For CC 110 you must complete them in order starting with module 0, the enroll module should be completed first, but is not a prerequisite.\nYou are welcome to work on this course at any time during the week as your schedule allows, provided that you complete each module before the listed due date. There will be roughly two modules due each week. The modules are self-contained, and nearly all of the grading in this course is completed automatically through Canvas and Codio. So, you can complete modules at any time before the due date, and once a module is complete, you may immediately start on the next one.\n[Slide 6]\nLooking ahead to the rest of this introductory module, you’ll see that there are a few more items to be completed before you can move on. In the next video, we’ll discuss a bit more information about navigating through this course on Canvas and using the Codio learning environment.\n[Slide 7]\nOne thing we highly encourage each of you to do is read the syllabus for this course in its entirety, and let us know if you have any questions. My view is that the syllabus is a contract between me as your teacher and you as a student, defining how each of us should treat each other and what we should expect from each other. We have made a few changes to the standard syllabus template for this program, and those changes are clearly highlighted. Finally, the syllabus itself is subject to change as needed as we adapt this program to meet the needs of its students, and all changes will be clearly communicated to everyone before they take effect.\n[Slide 7]\nOne very important part of the syllabus that every student should read is the late work policy. First off, each module has a due date, and you may work on that module at any time before it is due, provided you have met the prerequisites. As discussed before, you must do all the readings and assignments in a module in listed order before moving on, so you cannot jump ahead. A module is considered completed when all items have been completed.\nFor the purposes of grading, we will use the date and time that the confirmation quiz was submitted at the end of each module to determine when the module was completed. This is due to the way that Codio handles automated grading, as it may resubmit previously graded assignments if an error in the module is corrected, making a previously completed assignment appear to be submitted late.\nIf any work is submitted after the due date, a penalty of 10% of the total points possible in that assignment will be deducted for each day it is late, up to a maximum of 3 days. After 3 days beyond the due date, you will receive a 0 on the assignment. Please refer to the full late policy in the syllabus for more information about how late work is handled in this course.\nFinally, even if a module is late, it still must be completed before you can move on to a later module. So, it is very important to avoid getting behind in this course, as it can be very difficult to get back on track. If you ever find that you are struggling to keep up, please don’t be afraid to contact either the instructors or GTAs for assistance. We’d be happy to help you get caught back up quickly.\nIn this program, the standard “90-80-70-60” grading scale will apply, though I reserve the right to curve grades up to a higher grade level at my discretion. Therefore, you will never be required to get higher than 90% for an A, but you may get an A if you score slightly below 90% if I choose to curve the grades.\nThis is intended to be a completely online, self-paced course. There are no mandatory scheduled course times. All of the content is available online, so you can work whenever and wherever you want. It could be a 3-hour block once a week, or a few minutes here and there between classes. It’s really up to you and your schedule. However, remember that each module may require 4 to 6 or more hours of work to complete, so make sure you have plenty of time available to devote to this course.\nAlso, a vast majority of the grading in this course will be handled automatically through Canvas and Codio. This means that you’ll be able to receive feedback directly from those systems as soon as you submit your work. You may also contact the instructors and GTAs for additional tips and feedback regarding your work, but depending on the number of students in the program, we may not be able to review every student submission directly.\nIn addition, due to the flexible online format of this class, there won’t be any long lecture videos to watch. Instead, each module will consist of a guided tutorial and several short videos, each focused on a particular topic or task. Likewise, there won’t be any textbooks required, since all of the information will be presented in the interactive tutorials through Codio. Finally, since we are using Codio as our learning platform, you won’t have to deal with installing and using a clunky integrated development environment, or IDE, just to learn how to program. Codio helps make learning to program quick and painless by moving everything to the web.\nFor this course, the only supplies you’ll need as a student are access to a modern web browser and a broadband internet connection. No other special hardware or software is necessary!\nFinally, as you are aware, this course is always subject to change. This is a relatively new program here at K-State, and we’re always working on new and interesting ideas to integrate into the courses. The best advice I have is to look upon this graphic with the words “Don’t Panic” written in large, friendly letters. If you find yourself falling behind, or not understanding seek our help via cc110-help.\nSo, to complete this module, there are a few other things that you’ll need to do. The next step is to watch the video on navigating Canvas and Codio, which will give you a good idea of how to most effectively work through the content in this course.\nTo get to that video, click the “Next” button at the bottom right of this page.\n",
    "description": "",
    "tags": null,
    "title": "Course Introduction - Spring 2022",
    "uri": "/00-introduction/01-introduction/"
  },
  {
    "content": "Big Ideas Guide CRD - Creative Development DAT - Data AAP - Algorithms \u0026 Programming CSN - Computer Systems \u0026 Networks IOC - Impact of Computing Computational Thinking Practices Guide CT1 - Computational Solution Design CT2 - Algorithms \u0026 Program Development CT3 - Abstraction in Program Development CT4 - Code Analysis CT5 - Computing Innovations CT6 - Responsible Computing Reference: AP Course and Exam Description\nCR 1 - Resources The teacher and students have access to college-level computer science resources, in print or electronic format.\nThe primary teaching resource in this course is Introduction to Computing, an eTextbook authored by K-State faculty. The textbook consists of lecture material and videos developed and presented by K-State faculty, as well as an annotated bibliography of additional readings and videos from across the internet on each topic. The textbook is used in two college-level courses taught at K-State:\nCIS 115 - Introduction to Computing Science CC 110 - Introduction to Computing The textbook can be found online at:\nPrimary Link: https://textbooks.cs.ksu.edu/cc110/ Alternate Link: https://ksu-cs-textbooks.github.io/cszero/ Authors \u0026 Contributors: https://core.cs.ksu.edu/authors/ Much of the content in the eTextbook is broadly inspired by two books:\nThe Pattern on the Stone: The Simple Ideas That Make Computers Work by W. Daniel Hillis Nine Algorithms That Changed the Future: The Ingenious Ideas That Drive Today’s Computers by John MacCormick These books are recommended reading for students in the AP version of this course but are not required.\nCR 2 - Develop Understanding of Content The course provides opportunities to develop student understanding of the required content outlined in each of the big ideas described in the AP Course and Exam Description.\nThe course consists of two major types of content:\nLecture Content, Videos, Discussions, Activities \u0026 Quizzes - roughly 2 college credit hours Programming Content, Labs, and Homeworks - roughly 1 college credit hour They are separated to allow teachers flexibility in structuring the course each semester. Below is an outline of the modules in each content area.\nLecture Content Unit 1 - CS Concepts Chapter 1 - What is Computing Science? Students are introduced to the field of computer science, including the original definition of a computer. They will learn about the reasons why pioneers such as Babbage and Lovelace desired to build machines to handle computations, reducing the risk of human error when computing mathematical tables.\nDAT 3.2 Data Abstraction, 3.16 Simulations IOC 5.1 Beneficial \u0026 Harmful Effects Chapter 2 - Early Computing Machines Students learn about the early history of computing machines, including the Antikythera Mechanism, abacus, and slide rule. Students then discuss and explore what features must be present in a device in order for it to be considered a computer, aiming for computation, storage, input, and output. Students are then introduced to key devices that pioneered the development of these features, such as Pascal’s Calculator and the Leibniz Wheel (computation), Jacquard Loom (input via punch cards), Babbage’s Difference Engine (output via press plates), and Babbage’s Analytical Engine (integrating all items and including a storage mechanism). Students will see that the development of computer technology required input from many areas.\nCRD 1.1 Collaboration, 1.2 Program Function \u0026 Purpose Chapter 3 - Bits \u0026 Boolean Algebra Students are introduced to the concepts in Boolean logic, including the AND, OR, NOT, and XOR operators. Students then explore Boolean algebra, observing how many of the rules have parallels directly to mathematics. Students also explore DeMorgan’s Theorem. Students work on several examples in class, going from truth tables to Venn diagrams and finally Boolean logic expressions. From there, students see how Boolean logic can be implemented using simple electronic circuits, forming the building blocks of modern computers.\nAAP 3.5 Boolean Expressions Chapter 4 - Programming Students explore the history of programming and many diverse pioneers such as Grace Hopper, Ada Lovelace and Margaret Hamilton. Students then learn what it means to actually “program” a computer and explore the process of taking code written in a high-level language (such as Java) and using tools such as compilers, interpreters, and assemblers to convert that code to assembly and eventually machine-level instructions that can actually be performed by a computer.\nCRD 1.1 Collaboration, 1.2 Program Function \u0026 Purpose AAP 3.2 Data Abstraction Chapter 5 - Universal Computers Students learn about the work of Alan Turing and the concepts behind a universal computer like the Turing Machine. Students work through an example to build a simple Turing machine to mimic Boolean logic operators using a few simple instructions. From there, students see how the concept of a universal computer, coupled with the prior concepts from other historical computers, led to the creation of the Von Neumann Architecture that is used in most modern computers.\nCRD 1.1 Collaboration AAP 3.2 Data Abstraction, 3.9 Developing Algorithms, 3.16 Simulations Chapter 6 - Algorithms Students learn about Al-Khwarizmi and the history of the word “algorithm” before exploring simple algorithms such as Euclid’s Algorithm. Students then go through an activity using playing cards to learn about four different sorting algorithms - insertion/selection sort, bubble sort, merge sort, and quicksort. At each step, students discuss how many “steps” it took to complete the algorithm, and then use that data to explore algorithmic complexity. Students are then introduced to Big-O notation as a way to compare the running time of algorithms, and by analyzing quicksort they also learn about the difference between worst-case and expected-case performance. Students are then introduced to the Traveling Salesman problem as a way to explore heuristics and the development of faster algorithms to find a good answer, but not necessarily the best answer.\nAAP 3.9 Developing Algorithms, 3.17 Algorithmic Efficiency Chapter 7 - Encoding Students learn about the work of George Stibitz and the creation of the Model K computer, one of the first to use binary values when performing calculations. Using that motivation, students learn about binary numbers and representation, including twos complement for negative values, floating-point for decimal values, ASCII for text, and both vector and raster image formats. Students also briefly see the basics of compression by replacing repeated data with smaller representations, but also see a case study showing how that can lead to loss of data and errors if done improperly.\nDAT 2.1 Binary Numbers, 2.2 Data Compression, 2.3 Extracting Information from Data AAP 3.2 Data Abstraction Chapter 8 - Computer Architecture Students learn about the development of the integrated circuit, seeing how it was the culmination of many small advancements by many different groups and how it helped solve the “Tyranny of Numbers” complexity problem of computers at that time. From there, students learn about Moore’s Law and how more and more components are placed on integrated circuit chips, leading to the first microprocessor in the Intel 4004 chip. Students also are re-introduced to Von Neumann Architecture and the parts of a modern computer. Finally, students perform an in-class exercise introducing finite state machines and how they can be used to represent real-world ideas in a computer program.\nCRD 1.1 Collaboration AAP 3.3 Data Abstraction, 3.9 Developing Algorithms, 3.16 Simulations Chapter 9 - Software Engineering Students learn about the practice of software engineering, including the software crisis and the recognition of the need for better language structures and processes. Students explore the various stages of the software development life cycle and different methodologies such as waterfall, iterative/incremental development, and agile.\nCRD 1.1 Collaboration, 1.3 Program Design \u0026 Development IOC 5.1 Beneficial \u0026 Harmful Effects Chapter 10 - Human-Computer Interaction Students are introduced to the field of human-computer interaction, starting with the work of Douglas Engelbart and the “Mother of all Demos” exploring his NLS system. Students then learn about the history of modern computer interfaces, including the creation of the desktop metaphor used in most modern systems. Students also learn about some failed experiments such as Microsoft Bob and discuss what makes a good or bad interface. Students see the work of Don Norman and user-centered design. Finally, students are introduced to several new and interesting concepts in HCI and future computer interfaces, such as virtual/augmented reality, multi-touch interfaces, and examples of building accessible interfaces.\nCRD 1.2 Program Function \u0026 Purpose IOC 5.1 Beneficial \u0026 Harmful Effects, 5.4 Crowdsourcing Unit 2 - The Internet Chapter 11 - The History of the Internet Students explore the history of the internet, starting with J.C.R. Licklider and his “Intergalactic Computer Network” concept, leading to the creation of the ARPANET. Students see videos and information from many pivotal figures in the history of the internet including Leonard Kleinrock, Vint Cerf, and Tim Berners-Lee. Students learn how the development of HTML and the world wide web helped bring the internet to the public, and how the dot-com bubble was a major turning point in the early internet before the rise of social media.\nCRD 1.1 Collaboration CSN 4.1 The Internet IOC 5.1 Beneficial \u0026 Harmful Effects, 5.4 Crowdsourcing Chapter 12 - How the Internet Works Students learn about the developments that lead to the technology behind the internet, such as packet-switching, and the various protocols that make up the seven layer OSI network model. Students learn how these developments were meant to build robust, fault-tolerant networks that can work in a variety of conditions.\nCSN 4.1 The Internet, 4.2 Fault Tolerance Chapter 13 - Web Programming Students learn the basics of web programming including HTML and CSS, and build a simple JavaScript Tic-Tac-Toe game to explore interactivity on webpages.\nCRD 1.3 Program Design \u0026 Development AAP 3.12 Calling Procedures, 3.13 Developing Procedures CSN 4.1 The Internet Unit 3 - CS Topics Chapter 14 - High Performance Computing Students learn about the concepts behind high-performance computing and why we need larger and more powerful computers to tackle some of the world’s biggest problems. Students explore ways that large problems can be broken down into smaller parts and run in parallel on multiple computers. Students also see some real-world examples of problems that high-performance computing can solve. Finally, students are given a virtual tour through K-State’s own supercomputer.\nCRD 1.1 Collaboration, 1.3 Program Design \u0026 Development Data 2.4 Using Programs with Data CSN 4.3 Parallel \u0026 Distributed Computing IOC 5.1 Beneficial \u0026 Harmful Effects Chapter 15 - Compression \u0026 Error Checking Students explore various ways that data can be compressed, including run-length encoding and Huffman coding. Students also learn about methods for detecting and correcting errors in data, such as checksums.\nDAT 2.2 Data Compression, 2.3 Extracting Information from Data AAP 3.2 Data Abstraction, 3.9 Developing Algorithms CSN 4.2 Fault Tolerance Chapter 16 - Cryptography Students learn the fundamental concepts and history of cryptography, starting with simple substitution ciphers. Students follow a case-study of the enigma machine and how it was defeated by the work of Alan Turing and others during the second world war. Students learn about modern cryptography principles including public-key cryptography, digital signatures, and perform a simple example of RSA encryption.\nCSN 4.1 The Internet IOC 5.1 Beneficial \u0026 Harmful Effects, 5.4 Crowdsourcing Chapter 17 - Cybersecurity Students explore the basics of cybersecurity, including a math-based discussion of passwords and relative password strength, as well as how passwords can be stored securely in a program. Students also learn about various cybersecurity threats such as social engineering.\nCSN 4.1 The Internet IOC 5.1 Beneficial \u0026 Harmful Effects, 5.5 Legal \u0026 Ethical Concerns, 5.6 Safe Computing Chapter 18 - Artificial Intelligence Students explore the field of artificial intelligence and what it means to say a machine is intelligent. Students engage in a discussion around the Turing Test and the Chinese Room counterexample. Students learn about intelligent agents and how they are used throughout the world, and explore other AI advancements such as neural networks and deep learning.\nDAT 2.3 Extracting Information from Data, 2.4 Using Programs with Data AAP 3.16 Simulations IOC 5.1 Beneficial \u0026 Harmful Effects, 5.3 Computing Bias Chapter 19 - Search \u0026 Information Retrieval Students explore the basics of databases and relational data. Students also learn about how information can be indexed and searched, followed by an introduction to ranking and the process of page rank for web searches.\nDAT 2.3 Extracting Information from Data, 2.4 Using Programs with Data AAP 3.9 Developing Algorithms, 3.16 Simulations CSN 4.1 The Internet IOC 5.1 Beneficial \u0026 Harmful Effects, 5.3 Computing Bias, 5.4 Crowdsourcing Notes - add bias to discussions\nChapter 20 - Big Data Students explore the impact of big data in computing and how it is being used to solve large-scale real-world problems in areas such as healthcare. Students are also introduced to the concept of map-reduce in programming.\nDAT 2.3 Extracting Information from Data, 2.4 Using Programs with Data AAP 3.9 Developing Algorithms CSN 4.3 Parallel \u0026 Distributed Computing IOC 5.1 Beneficial \u0026 Harmful Effects, 5.4 Crowdsourcing Chapter 21 - Ethics Students explore some of the legal and ethical impacts of computing, including intellectual property, bias, privacy, and fair use. Students also learn about the digital divide and how that impacts access to information and equity.\nIOC 5.1 Beneficial \u0026 Harmful Effects, 5.2 Digital Divide, 5.3 Computing Bias, 5.4 Crowdsourcing, 5.5 Legal \u0026 Ethical Concerns Notes - this is pretty aspirational?\nChapter 22 - Graphics \u0026 Video Games Students explore the basics of computer graphics and how they have evolved over time. Students learn about the “uncanny valley” effect. Students also see how early video game graphics were built, exploring concepts related to data compression and efficiency on such small systems.\nDAT 2.1 Binary Numbers, 2.2 Data Compression AAP 3.16 Simulations, 3.17 Algorithmic Efficiency Programming Content Lab 1 - Introduction This lab introduces students to the basics of the Codio interface and gives some examples of the various assessments contained in the labs.\nLabs 2 \u0026 3 - Basic Programming These labs introduce students to the basic syntax of both pseudocode and Python. Students learn how to use a simple Linux terminal to navigate the file system and execute programs. Students learn to use print to display output, and explore examples of printing input with and without newline characters. Students learn to create basic variables that store strings. Students explore code tracing both by hand (in pseudocode) and using Python Tutor. Finally, students learn to create functions or procedures, including simple parameters and arguments, and learn how to create a main function or procedure for their programs.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.4 Strings, 3.12 Calling Procedures, 3.13 Developing Procedures Labs 4 \u0026 5 - Operations \u0026 Input These labs introduce math and string operators in both pseudocode and Python. Students learn about integer and floating-point data types and how to convert between the two. In addition, students learn how to return data from functions or procedures, and explore how to use the basics of function composition to combine expressions into more complex statements, such as using the result of a function call directly as an argument to another function. Students learn how to request input from the user and convert a string into a numerical value.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors DAT - 2.1 Binary Numbers, 2.4 Using Programs with Data AAP - 3.1 Variables \u0026 Assignments, 3.3 Mathematical Expressions, 3.12 Calling Procedures, 3.13 Developing Procedures Labs 6 \u0026 7 - Conditionals These labs introduce students to conditional statements in both pseudocode and Python. Students learn about the Boolean data type and a number of Boolean operators and comparators used in Boolean expressions. Students then learn about if and if-else statements, and explore how to test their programs by developing inputs that achieve branch and path coverage.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.1 Variables \u0026 Assignments, 3.3 Mathematical Expressions, 3.5 Boolean Expressions, 3.6 Conditionals, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures Lab 8 - Homework 3 This lab is a stand-in for homework 3, which is partially done in-class along with the unit on web programming. It is discussed below.\nLab 9 - Nested Conditionals In this lab, students explore the concepts being nesting and chaining conditionals. Students learn about the usefulness of mutual exclusion when designing conditional statements, and also explore the concept of variable scope and blocks of code.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.5 Boolean Expressions, 3.6 Conditionals, 3.7 Nested Conditionals, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures Labs 10 \u0026 11 - Loops This lab introduces the concepts of loops and iteration in both pseudocode and Python. Students will see both for loops (iterating across a collection or range) and while loops (iterating while a Boolean condition is true). Students also learn how to use loops to prompt for input and repeat until a valid input is received. Students learn to test loops using inputs that achieve branch and path coverage. Students also learn how to import the random library in Python and generate random integer values in a range.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.5 Boolean Expressions, 3.8 Iteration, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.14 Libraries, 3.15 Random Values Lab 12 - Nested Loops This lab reinforces previous learning on loops with examples on how to nest a loop inside of another loop. Students will learn how skills for tracing execution through these loops by hand and using Python tutor. Students also learn skills for testing these loops and developing inputs that properly explore the edge cases.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.5 Boolean Expressions, 3.8 Iteration, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures Lab 13 - Lists This lab introduces students to the list data structure in Python. Students learn about the list data type, including accessing elements by index and adding elements. Students explore how to use loops with lists to iterate through elements. Students learn that lists are handled in a “pass by reference” way when used as arguments to functions. Students learn that strings can also be treated like lists, and that lists can be sliced in a variety of ways.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors DAT - 2.4 Using Programs with Data AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.4 Strings, 3.9 Developing Algorithms, 3.10 Lists, 3.12 Calling Procedures, 3.13 Developing Procedures Lab 14 - Dictionaries This lab introduces the dictionary data structure in Python. Students learn how to add and access elements in a dictionary, and how to iterate through all elements in a dictionary, including both keys and values. Students also see that dictionaries are treated similar to lists when used as function arguments.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors DAT - 2.4 Using Programs with Data AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.4 Strings, 3.9 Developing Algorithms, 3.10 Lists, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.16 Simulations Homework 1 The first homework typically involves some sort of mathematical simulation, such as compound interest. It reinforces the topics of variables, numeric and string data types, reading input, using math operators, and formatting output.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.3 Mathematical Expressions, 3.4 Strings, 3.5 Boolean Expressions, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.16 Simulations Homework 2 The second homework typically involves conditional statements as well as mathematical operators and more practice with input, output, and functions.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors AAP - 3.1 Variables \u0026 Assignments, 3.3 Mathematical Expressions, 3.5 Boolean Expressions, 3.6 Conditionals, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.16 Simulations Homework 3 The third homework introduces students to creating websites with HTML and CSS. Students also follow a tutorial to create a simple game in JavaScript to explore interactivity on web pages.\nAAP - 3.2 Data Abstraction, 3.14 Libraries CSN - 4.1 The Internet Homework 4 The fourth homework covers the use of nested conditional statements, as well as user input and handling functions with parameters and return values.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors DAT - 2.3 Extracting Information from Data, 2.4 Using Programs with Data AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.3 Mathematical Expressions, 3.4 Strings, 3.5 Boolean Expressions, 3.6 Conditionals, 3.7 Nested Conditionals, 3.9 Developing Algorithms, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.16 Simulations Homework 5 The fifth homework covers the use of loops and advanced data structures such as lists or dictionaries. It usually involves a larger amount of input, either a string or a list of values.\nCRD - 1.2 Program Function \u0026 Purpose, 1.3 Program Design \u0026 Development, 1.4 Identifying \u0026 Correcting Errors DAT - 2.3 Extracting Information from Data, 2.4 Using Programs with Data AAP - 3.1 Variables \u0026 Assignments, 3.2 Data Abstraction, 3.3 Mathematical Expressions, 3.4 Strings, 3.5 Boolean Expressions, 3.6 Conditionals, 3.7 Nested Conditionals, 3.8 Iteration, 3.9 Developing Algorithms, 3.10 Lists, 3.12 Calling Procedures, 3.13 Developing Procedures, 3.16 Simulations CR 3 - Develop Understanding of Big Ideas The course provides opportunities to develop student understanding of the big ideas.\nBig Idea 1 - Creative Development The course includes several programming assignments that are completed by the student. Each assignment requires the student to write code that solves a problem and meets an expected structure. Students will also write a reflection for each assignment that discusses their program design process, any problems solved or debugging performed, and resources or assistance used. Current homework assignments are described above in detail. Most assignments fit one or more of these categories:\nSimple calculator program Cash register or purchase simulator HTML website and simple game Decision tree simulator Simple cipher program Grade calculator Random number simulator Big Idea 2 - Data Students in this course explore data in a variety of ways. Students participate in an activity to see how data is represented in binary as integers and floating point, and how those numbers can be translated to text using ASCII, as well as colors and vectors to create images and videos. Another activity has students explore data compression and error checking. Students also participate in an activity to learn how data is used to train a neural network.\nBig Idea 3 - Algorithms \u0026 Programming Students participate in an activity using a deck of cards to learn various sorting algorithms (bubble sort, insertion sort, merge sort, and quicksort). Students also participate in an activity to simulate the random surfer model used by page rank. Students also learn about Turing machines and participate in a simple activity to develop an algorithm for a Turing machine that simulates a Boolean operator, such as “xor” on two binary values.\nIn addition, students perform many guided programming labs and unguided homeworks to further explore algorithms and programming, both in pseudocode as well as Python.\nBig Idea 4 - Computer Systems \u0026 Networks Students participate in an activity to simulate a packet-switched network as part of a number guessing game. Each team chooses a secret number and is assigned a name. Then, teams use a simulated DHCP protocol to be assigned an address, and then they can use a simulated DNS protocol to find the addresses assigned to other teams. Then, teams can send simulated HTTP packets to guess the receiving team’s number, and they respond with HTTP response codes whether the correct number is “higher” or “lower” than the guess. Throughout the activity, students are encouraged to think about how a real network operates, and teachers are encouraged to allow some “packet loss” or even “reset the router” and force teams to re-connect to the network before continuing. This also leads to discussions of how packet-switched networks include fault tolerance.\nIn another activity, students simulate a map-reduce algorithm to count the words in a small poem, learning about parallel and distributed systems.\nBig Idea 5 - Impact of Computing Throughout the semester, students participate in many guided discussions about the impact of computing on the world and in society. Some discussion topics include:\nObserved changes in Computing Technology over the years Algorithms in the world and how they impact us Human-Computer Interaction and UI design The filter bubble Evolution/Impact of Computer Graphics “The Creepy Line” documentary video on ethics CR 4 - CT Practice 1: Computational Solution Design The course provides opportunities for students to develop the skills related to Computational Thinking Practice 1: Computational Solution Design, as outlined in the AP Course and Exam Description.\nStudents will write complete computer programs to solve various homework assignments that must meet a given specification. Students will need to determine the appropriate program structures to be used to solve the problem, and then develop and test their solution.\nThrough many of the in-class activities, students will also explore and discuss various existing ways computer scientists have solved real-world problems, such as the development of search algorithms, sorting algorithms, data compression, and error checking. Students will also evaluate the various methods and discuss their performance and tradeoffs.\nCR 5 - CT Practice 2: Algorithms \u0026 Program Development The course provides opportunities for students to develop the skills related to Computational Thinking Practice 2: Algorithms and Program Development, as outlined in the AP Course and Exam Description.\nStudents will design and implement algorithms to solve a variety of computing tasks. Students will discuss the importance of carefully developing algorithms and using clear, explicit instructions through activities such as the classic “make a sandwich” unplugged activity. In the homework assignments, students will implement algorithms to make change in a transaction, guide users through a decision tree, and use a simple cipher to encode and decode secret messages.\nStudents will also explore a variety of computing concepts in pseudocode, requiring them to think and reason clearly about what the program will do, especially since they have no way to run the program and confirm the result directly.\nCR 6 - CT Practice 3: Abstraction in Program Development The course provides opportunities for students to develop the skills related to Computational Thinking Practice 3: Abstraction in Program Development, as outlined in the AP Course and Exam Description.\nStudents will write several programs that require user input, such as compound interest calculator or cash register simulator. Students will explore how the data input by the user is stored in variables and used to represent various items in the real world.\nIn another homework, students will use a simple cipher to encode and decode secret messages. Students will explore how text is made up of individual characters, and how we can use a randomized or reordered list of characters as a “key” to encode and decode the data.\nCR 7 - CT Practice 4: Code Analysis The course provides opportunities for students to develop the skills related to Computational Thinking Practice 4: Code Analysis, as outlined in the AP Course and Exam Description.\nIn many of the lab assignments, students will complete many exercises that involve reading code and determining what is performed or what output is produced. Students will also participate in several code tracing activities (similar to Python Tutor) in both pseudocode and Python to explore procedure calls, passing arguments and returning values.\nStudents will also be asked to develop a number of test cases for various sample programs in the lab assignments, aiming to achieve either branch coverage or path coverage across code that contains conditional statements or loops.\nCR 8 - CT Practice 5: Computing Innovations The course provides opportunities for students to develop the skills related to Computational Thinking Practice 5: Computing Innovations, as outlined in the AP Course and Exam Description.\nStudents will explore many computing innovations throughout the course, starting with the history of computing and moving to modern advancements such as neural networks, computer graphics, the internet, and big data, among many others.\nStudents will also participate in many discussions in-class and/or online on a variety of computing topics, such as how technology has changed during their lifetimes, the “filter bubble,” observable algorithms in daily life, and more. Students will also explore some of the ethical and legal concerns around social media and cybersecurity.\nCR 9 - CT Practice 6: Responsible Computing The course provides opportunities for students to develop the skills related to Computational Thinking Practice 6: Responsible Computing, as outlined in the AP Course and Exam Description.\nStudents will explore issues related to digital hygiene, such as using secure passwords, avoiding suspicious emails, and combatting social engineering and phishing tactics.\nStudents will also discuss ways that computer interfaces and websites can be built to me more inclusive for users with limited access or ability to interact with the system. Students will also see examples of instances where artificial intelligence can introduce unintentional bias into the results.\nCR 10 - Investigate Computing Innovations The course provides a minimum of three opportunities for students to investigate different computing innovations.\nComputing Innovation 1, Prompt A Students will participate in a guided discussion in class on the development of Web 2.0, the rise of social media, and its impacts on society. Students will explore both their own experiences interacting with social media, how it has impacted society and culture, and review any recent news articles related to the topic. Based on the discussion, students will write reflection papers to address the beneficial and harmful impacts of social media.\nComputing Innovation 2, Prompt B Students will participate in an activity that simulates training an artificial neural network to identify animals. Each student is given a part of a larger image, and then all students vote on whether the overall image contains a cat or a dog. Students who get the answer correct are given more votes, simulating a higher weight in the neural network. This repeats for several iterations until the network is well trained. Students will discuss how the input data affects the quality of the output, and explore case-studies where training a neural network didn’t work well or introduced unintentional bias in the output. Students will use this knowledge to write a short explanation in their own words of how neural networks work and how they are trained.\nComputing Innovation 3, Prompt C Students will learn about how to properly store and secure passwords in an application, involving the use of a hash function and a randomized salt value. Students will respond to prompts asking them to describe the security, privacy, and data storage concerns related to storing user account information and passwords for an application.\nCR 11 - Create Performance Task Students are provided at least 12 hours of dedicated class time to complete the AP Create Performance Task.\nFollowing the completion of the programming labs, students will be given at least 12 hours of class time across multiple class sessions to complete the AP Create Performance task.\n",
    "description": "",
    "tags": null,
    "title": "AP Syllabus",
    "uri": "/z-ap-alignment/01-syllabus/"
  },
  {
    "content": " Notes About This Selection While the creation on Babbage’s Difference Engine #2 was turned down by the government, we get to see this machine which was built in modern times. Babbage had a small prototype which he would demonstrate for party guests and it was clear to those who saw it, that Babbage was incredibly talented and intelligent. This is further proven by the prototype’s modern counterpart. It is astonishing that it was created with such precision using just pencils and paper!\nReference Computer History Museum. “Charles Babbage and His Difference Engine #2”. May 5, 2008. YouTube. Available: https://www.youtube.com/watch?v=KBuJqUfO4-w.\n",
    "description": "",
    "tags": null,
    "title": "Charles Babbage and His Difference Engine #2",
    "uri": "/i-concepts/02-early-computing-machines/04-difference-engine/"
  },
  {
    "content": " Notes About This Selection In this video, we get to see another example of antique computers! Created in 1803, the Jacquard loom used technology that would be a predecessor to the more modern punch cards and in turn, modern computers. As before with the difference engine and the Antikythera mechanism, this was a result of humans trying to automate tasks which required a lot of precision.\nReference The Henry Ford. “How an 1803 Jacquard Loom Led to Computer Technology”. July 27, 2018. YouTube. https://www.youtube.com/watch?v=MQzpLLhN0fY.\n",
    "description": "",
    "tags": null,
    "title": "How an 1803 Jacquard Loom Led to Computer Technology",
    "uri": "/i-concepts/02-early-computing-machines/05-jacquard-loom/"
  },
  {
    "content": " Resources Slides Video Script DeMorgan’s Theorem (Slide 7) So with all these new tools, we needed some new algebraic rules to really deal with them. Thankfully, most of the rules you know, apply quite well, but there’s one rule that needed to be added. In mathematics. When you multiply by negative one, you have to change the signs. Similarly, Augustus DeMorgan came up with a way to deal with the negation of entire Boolean logic statements. So this becomes very similar to how you multiply a statement or a regular mathematical statement by a negative one. I guess system marking came up with a way to deal with the negation of entire Boolean logic statements. The DeMorgan’s theorem essentially states to treat the NOT operator like the negative sign so you’re going to apply the negative to each of the premises or facts and then swap the operators or basically and become or’s and or’s become hands. So let’s take a look at an example. So if we invert our particular statement here where we have a and b, right, so A and B, not a and b becomes not a or not B, so we negated or applied the knot to a and the knots to b and the knot and becomes or similar idea for or not a or b becomes not a, and not B.\nBoolean Algebra(Slide 8) Now, in Boolean algebra, just like when you multiply by a negative one, a lot of the similar rules apply and Boolean algebra just like they do in mathematics. So in general, the OR operator works very much like the plus operator not works very much like negation, like we’ve already seen, and works very much like multiplication.\nThe associative property, also Hold. So we have a and b, and c becomes a and b and c. So if I made the substitutions here, just based off of what we had here, if we had one, and the AND operator works like multiplication, though times two, parentheses, substitute the multiplication symbol and for the end, and then we have three. That is the same thing as saying one times two times three.\nThe commutative property also holds. So again, let’s try to make some substitutions. A and B is the same thing as saying B and A. So that’s the same thing as saying. Two times three is the same thing as Three times two.\nAnd the distributive property also holds. So A and B or C is the same thing as saying a and b, or a and c. So let’s make our substitutions again, let’s substitute again, one four a, so one times to remember, or is like the addition operator plus three is the same thing as saying, we’re going to kind of distribute right as we normally would with math, distribute the one across two plus three. So one times two plus three is the same thing as saying one times two, plus one times three. So we distributed the Want across and we’ll end up with the same exact result. Same idea or Boolean logic if we make each one of these properties, as we seen here, and mathematics applies and works directly with Boolean algebra. So what this really helps you as when you start working with Boolean logic, even when programming you can actually use these properties to simplify a lot of your Boolean logic statements to make them easier to read and easier to program.\n",
    "description": "",
    "tags": null,
    "title": "Boolean Algebra",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/03-algebra/"
  },
  {
    "content": " HealthMap\n",
    "description": "",
    "tags": null,
    "title": "HealthMap.org",
    "uri": "/iii-topics/20-big-data/03-health-map/"
  },
  {
    "content": "Watch through 5:38\n",
    "description": "",
    "tags": null,
    "title": "John McCarthy (1927-2011): Artificial Intelligence",
    "uri": "/iii-topics/18-ai/03-john-mcarthy/"
  },
  {
    "content": " Resources Slides Video Script Another area of cybersecurity that we should discuss is social engineering. Social engineering is all about using techniques to compromise the system by exploiting the users directly instead of the system security itself. And this is a really important concept. There’s an old saying, in computer science that a system is only as secure as the users that use that system. It’s kind of a play off the idea of a system is only as secure as its weakest link. And in most cases, the weakest link is the user itself. And so on the next few slides, we’re going to take a look at some different ways that you can use social engineering, to maybe break into a computer system and what those things look like so that we can defend against those. So a great example of social engineering is trying to get some information from somebody that they don’t want to give. And a great example of that would be a bank account number. So if I wanted to get someone’s bank account number, how do you think I could go about that using social engineering? Take a minute to think about it. So while this example may not work that well in today’s world, because not many people carry around checkbooks. If you have a checkbook, look at your checkbook at the bottom of your checks, and see what’s printed there. Hopefully, you should realize that printed at the bottom of your checks are two numbers. One of them is the routing number that identifies your bank, and the other number is your bank account number. And so I think one of the best ways to do this was actually discovered by Gru in the movie Despicable Me selling cookies. He had his girls sell Girl Scout cookies, and as long as he said, “Oh, I can only accept checks.” A lot of people might not think twice about writing a check for a Girl Scout troop, but that check includes your bank account information. And so with a little bit more work, you could probably use that information very nefariously against the people that wrote those checks. So even though it’s something that we don’t really think about giving out very often, it’s right there out in the open if we know how to get it.\nSo let’s take a look at some examples of social engineering and see what those look like. First and foremost is the idea of pretexting. Pretexting is calling or going somewhere and pretending to be someone else. And you see this a lot of times done in movies where the bad guys will come in and pretend to be exterminators so that they can gain access to the back room of a bank. But you could do it just as easily by calling someone and pretending to be their insurance agent. This happens at K-State all the time. Department offices get calls asking for information, like who’s in charge?, who’s the department head?, who buys your supplies? And then they will call back later and say, Oh, yeah, so and so said that you should buy the supplies from our company. We’re just checking the follow up on the order. Even though no order was made. they now know who’s in charge, who makes the decisions, and they’re hoping that they get somebody else that is like, oh, yeah, that sounds reasonable. And they’ll just approve it. So by pretexting a little bit, you can gain access to systems that may not work very well, otherwise. Of course, pretexting is very closely related to impersonation. Impersonation is calling is simply pretending to be somebody else. So with impersonating, I could impersonate one of my students, I can impersonate somebody else and try and get access to their systems. And this also happens every once in a while. For example, there were a couple of instances in the news where somebody got a call from somebody pretending to be their boss’s secretary, and giving them new instructions for how to transfer money. And as soon as they transferred the money, of course, they were transferring it to the attackers, and the money was gone before they even realized what was going on. And of course, that person immediately realized their mistake called their boss directly to double check on the transfer. And obviously, the boss had no idea what was going on, and the money was already gone. And so impersonation is another really strong attack vector in social engineering.\nThere’s also something called the human buffer overflow. So take a minute and try and read every single word on this page using the color that the word is written in. So it would start with green, red, blue, yellow, blue, black. You have to think about it. And in fact, if you try and go really, really fast, you’ll probably find that you start reading the words instead of saying the colors. This is an example of the human buffer overflow. And so what you can do is by desensitizing people by getting them thinking about other things, you can trick them into saying something or revealing something they wouldn’t normally do. A great way to do this is to have people do a few math problems, such as asking them what’s two plus two? What’s four plus four? What’s eight plus eight? What’s 16 plus 16? And then ask them to name a vegetable. And for a lot of humans, they will immediately answer carrot. Likewise, if you ask them to name a tool, it will probably be a hammer. If you ask them to name a number between five and 12. It will be seven. Seriously try this get some people to do some math problems and get them thinking logically and then ask them some of those random questions. And I think you’ll be really surprised if they don’t take a minute to think about it. Their knee jerk reactions are probably carrots, hammer, seven. It’s worth trying. So that’s one thing you can do.\nAnother one is definitely quid pro quo. This is a ransom attack. Very famously here in Kansas City, the company, Garmin, was recently attacked by ransomware. And so that’s a quid pro quo attack, they took something they encrypted all of their systems, and then basically held it for ransom and said, if you don’t give us money, we will not decrypt the systems. And so quid pro quo is a very, very powerful attack that is gaining a lot of popularity out there. You’ve seen it done to governments, to hospitals, to large companies. It can be really devastating if they don’t have the proper techniques in place to deal with such an attack.\nBut there’s a lot more mundane ways that social engineering can happen to. You can have phishing attacks. This is a phishing attack that I got a few years ago from K-State, or at least it looked like it’s from K state, asking us to send some information. So let’s take a look at this email and see what we think. So first, we see that we got this email from accountupgrade@ksu.edu. It looks pretty legit. It comes from the Kansas State University webmail team. Yeah, that looks right. But then we start reading “due to the congestion in all ksu.edu users and removal of all ksu.edu capital accounts copyright Kansas State University be shutting down”. If you start reading this email, it doesn’t really quite jive. It doesn’t have really good English in it. And then of course, at the bottom, the obvious thing is to ask you for your first name, last name, email address, your username, your password, your password again, just to make sure you got it right, and your eID. And this is kind of interesting. Most people outside of case they don’t even know what an ID is something that’s unique to K-State, but they at least knew to ask for that particular question here. Although the ID, the username, and your email address are all going to be the same thing. So while this is a pretty good phishing attempt, it’s not a great one. But every year these phishing attempts, they can compromise hundreds of casing email accounts every single year.\nLikewise, you get these scams, these are known as 419 scams, but you get these all the time. Usually, it’s something where they say that you have won some large amount of money, and they need some information from you to send it to you. And a lot of times they only ask for a few thousand dollars. They’re called 419 scams, because that’s the section of the Nigerian criminal code that makes these illegal. And a lot of these are at least said to originate from Nigeria. This one is from Ivory Coast. And this also is a real one that I received a few years ago when I put on these slides. And so this is a form of what’s called advance fee fraud. They claim to have a large amount of money that they want to send to you, but they can’t quite do it. And so they need you to send just a little bit of money to them so that they can get your money and send it back. Obviously, all of these are fake. But there are many stories online that you can find people that have been scammed for several thousands of dollars or 10s of thousands of dollars by scams, such as this.\nAnother form of social engineering you might run into is baiting. Baiting is leaving something out there and hoping somebody goes for it. And a great example of this is flash drives. Let’s say you’re walking across campus and you find a flash drive like this laying by the sidewalk. What’s your first instinct? Do you pick it up and take it to the nearest computer and plug it in and see if you can figure out whose it is? Well, if you did that, you might have just infected that computer with a virus that was put on this flash drive. And this is actually a really common form of social engineering. In fact, this has been used as a white hat technique to protect a lot of companies and companies routinely fail this. They put a few flash drives out in the parking lot. A person finds a flash drive. “Oh, I should be a good person and see who this is.” And they immediately infect their company with a virus. And so when you find flash drives like this, especially flash drives that you don’t know where they came from, the best thing you should do is give them to an IT professional and let them deal with it. A lot of times they have systems specifically set up so that they can plug in unknown data devices and make sure that they’re done securely, and won’t infect the system.\nAnd then of course, it’s also important to mention that social engineering does include threats, this XKCD comic once again, does a really good job of describing this. Crypto nerd might think, oh, we’ve got a computer encrypted with a password, let’s build a million dollar cluster to crack it. But in actuality, let’s go get a $5 wrench and just beat this guy over the head with it until he gives us his password. And so you really have to understand tha while there are a lot of very sophisticated systems to protect our computer systems. Sometimes direct threats are something that you have to think about. And that’s something that is really kind of uncomfortable to even think about in the field of cybersecurity. But it’s something to bear in mind that sometimes a direct threat like that is enough to crack a system.\nSo now that we’ve talked about all these different ways that social engineering can happen, let’s talk about some ways that we can combat social engineering. First and foremost is user training. We need to do a really good job of training our users how to spot these scams. And this happens all the time. You have to train them how to watch for phishing scams and email scams. You have to train people to talk on the phone to listen for phone calls that are trying to solicit more information or trying to fake something out. You have to ask them to be questioning if somebody walks in and claims to be an exterminator. Who called them? Do they have an invoice? Do they have an appointment? Are we expecting you? things like that. All of those fall under user training, we also need to have really good security protocols and audits. We need to make sure that if there is something secure, that we keep it secure. And a security protocol could be as simple as if you’re in a building where you have to swipe your key card to walk in the door, you don’t hold the door open for somebody else. That’s a great form of social engineering is standing outside smoking, and then being like, oh, I forgot my badge can you let me in? And if they’re not thinking about the protocol, they’re just like, sure, I’ll let you in, and you’ve just gained access to a secure building. So having those protocols and audits in place is also really important. As we mentioned earlier, as a user, you should always be a little skeptical, you should always be questioning everything. If you get an email that looks weird, a phone call that looks weird, somebody comes in and is acting suspicious, that little bit of questioning and being on guard can really protect you against a lot of social engineering. You can also perform penetration testing, a lot of companies do this where they will send out fake scam emails, and then anybody that responds to that email has to go through a security training. They can hire companies to try to come in as white hats, and try and break into the building, or talk their way in, or do all sorts of these cool things. And so by penetration testing, you can find those weaknesses in your protocols and make sure that you secure those. Finally, you can also work on properly disposing your garbage. Obviously a lot of social engineering can involve dumpster diving. You pull papers and invoices and things out of the trash. And so if you’re not thinking about that, that can be one way that people can gain a lot of information about your company. And so if you’re even at home, you should be shredding your bank statements or credit card statements cutting up your own credit cards, just in case because there’s a lot of information that can be gotten just from a trash bag that’s left outside.\nSo finally, let’s talk a little bit about social engineering in practice. Every year there is a DEF CON cybersecurity convention that’s held every year in Las Vegas. And several years they have done what they call a capture the flag style contest. And the whole idea is contestants at that contest try and gain information about companies via the internet first. And then using that information, they will just call the company headquarters and attempt to gain more information or flags for points. And those five could be as simple as what web browser do you use? What version of Windows do you use to who’s your exterminator company? who’s your catering company? All of these pieces of information can be used to construct a really in depth social engineering attack on a company. And so the report is actually quite staggering how a lot of different companies did really, really poorly at this. Obviously part of DEF CON is they went out and asked these companies for permission. Nobody gave them permission to do this. They did it anyway. That’s kind of how DEF CON works. So if you’re interested, I encourage you to read the report. We will link it after this video. It’s really quite fascinating to see what they were able to learn by doing social engineering.\n",
    "description": "",
    "tags": null,
    "title": "Social Engineering",
    "uri": "/iii-topics/17-cybersecurity/03-social-engineering/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Internet: How Search Works",
    "uri": "/iii-topics/19-search-info/03-how-search/"
  },
  {
    "content": "Watch this trailer for “Tin Toy” for a precursor to the uncanny valley.\nTin Toy Trailer\n",
    "description": "",
    "tags": null,
    "title": "Tin Toy Trailer",
    "uri": "/iii-topics/22-graphics-and-video-games/03-tin-toy/"
  },
  {
    "content": " Resources Slides Video Script Now let’s talk about error checking. What do you think error checking means when we’re talking about sending and retrieving data? And why do you think it would be useful? Well, let’s take a look at an example. When we send data, such as this text, hello there, sometimes the data might get garbled in transmission. When you were a kid, if you played with radios or walkie talkies, or anything like that, you might have had trouble understanding what other people say, Heck, even it happens today, sometimes on cell phone calls. So if there was a way that we could confirm that the data we’re receiving is the data that was actually sent without adding too much overhead to the data, that might be a really powerful tool, a great intuition to think of is squeezing the data into a smaller space, and then using that to check and see if we got the right answer.\nSo if we start with the text, hello there, and we squeeze the kerning, between the characters really narrow, we get this image shown below, that we can use as a little check to make sure that the data that we received was the same thing. So on the receiving end, if instead of receiving Hello, there we see Hello, ghere. If we squeeze that together the same way, we noticed that the squeezed image does not look the same as the squeezed image above. And so by sending the squeezed image above, we would know that we didn’t get the right data. And that squeezed image doesn’t take up a whole lot of space. That’s really the intuition behind error checking, we’re trying to send a little bit more data along with a larger transmission. And we can use that little bit of extra data to make sure the transmission itself was received without errors. That’s the real intuition behind this.\nSo let’s take a look at an example. One of the best ways we could do this is simply adding together the numbers. So if we take the sentence Hello there, and we convert it to ASCII, we see that a capital H is 72, e is 101, L is 108, and so on and so forth. So if we take all of those numbers, we could just add them up, and send all of that ASCII text plus the number 1101. Pretty cool, isn’t it, then on the receiving end, if the T got replaced with a G, obviously, the sum we would get would be different. And we would know that somehow that message got corrupted. Of course, this might be a little bit complex, for example, 1101 doesn’t fit in an eight bit binary number, so we may have to truncate it a bit or use modulo, to reduce it down to a number that fits into an eight bit binary value. Now, of course, this is a very simple form of error checking, and it does have some flaws. So let’s talk about some of these different questions. For example, if we only have the sum that came along with that message, could we use that to recover the original? So if I just gave you 1101? Could you tell me what original message produced that sum? Probably not. It would be really, really difficult to do. So we can’t use it to recover the original.\nHow well does it detect errors? Well, if we change the T to a G, we would probably detect that. But what if we replaced an L with an M and another L with the letter right before L? How well does this detect errors? Well, let’s consider the case where one of the L’s in hello gets replaced with an M, and the other L gets replaced with a K. M is one greater than L. But K is one less than L. And so when we sum those together, we would still get the exact same sum. So it is possible for us to create an error that the sum itself does not catch, that’s not really good. So as we can see, are the areas that cannot detect absolutely, we could swap characters, we could rearrange the characters, they would all still sum up to the exact same value. There’s tons of ways that we could do this. And of course, we talked about this a little bit already, but 1101 is larger than eight bits. How should we handle that? Well, we could use modular division where we divide it by 256. And keep the remainder, which would be the modulo operation that you learn about in your programming courses that would allow that number to fit in just eight bits. But of course, the big question we always ask in this class, can we do better. And I would argue that there are ways that we can definitely do better than a simple addition error checking.\nSo let’s take a look at another example of error checking. In this case, it’s called pinpoint error checking. Here, we’ve received a number 483754. So very large number, and we’ve taken that number and we’ve arranged it in a four by four grid. And then we’ve added a column in a row to the end of the grid that we can use to calculate what we call our checks up, which is the sum that we’re going to create to make sure that these numbers are correct. To create that checksum, what we will do is we will sum up each row and each column and then we will keep just the ones place of that value in this call. So for exam We have 4 plus 8 is 12, plus 3 is 15 plus 7 is 22. So here we would put 2, here we have 5 + 4 is 9, + 3 is 12, + 3 is 18. So we would keep the 8. Likewise, we could go down, we have 4 + 5 is 9, + 2 is 11, + 3 is 14. So we would keep the 4, here we have 8 + 4 is 12, + 2 is 14, + 9 is 23. So we would keep 3. And we could do this all the way through until we got all of these numbers, which we see right here, we see 4306 along the bottom, and 2858 along the side, then when we send the message, we could simply add those numbers in where they go, we see down here are 4837 of our original number, plus this 2 for our checksum 5436, plus an 82256, plus a 53397, plus an 8. And then we have 4306, which is our bottom checksum. So we have a 16 digit number. And we’ve added 8 more digits to it to provide a checksum. So it’s gotten a little bit bigger, it’s about 50%, bigger than it was.\nBut what can we do with this checksum that’s very, very powerful. So here, we’ve received a message. And we have in gray, our original checksum. And then in red, we have the checksum that we calculated from the message that we received. So take a look at this and see if you can figure out exactly where the error is in this received message. All right, let’s see if we can find the error. So we look at our checksum for matches up. 3…, uh-oh, this one doesn’t match up. So we’re going to circle this one. Zero matches up, six matches up, two matches up, eight matches up, uh-oh, here, 5 and the 0 don’t match up, and then the 8 matches up. So if we look at the row and the column, we know that this one is incorrect. Now the big question is, can we use this to restore that value to what it originally was, we know here that this value should be eight larger, or should be five larger, and we know that this value should be there, five larger five smaller. So with this number, if we add five to it, and just keep the ones place, we know that this number should probably have been a two. So let’s look at our original. Uh huh. It was a two. So using this pinpoint checksum by adding a little bit more data to the data that we’re transmitting, not only can we detect an error, but we can actually correct an error. And there are some different ways we can measure this. For example, we can detect a lot of different errors, but we may not be able to correct as many errors as we can detect. And that’s one of the important things to remember about checksum such as this. So now that you’ve seen an example, we’ll have a little quiz after this where you can do another example on your own just to see how this works.\n",
    "description": "",
    "tags": null,
    "title": "Error Checking - Pinpoint",
    "uri": "/iii-topics/15-compression-error-checking/03-pinpoint/"
  },
  {
    "content": " Resources Slides Video Script So we talked briefly about CSS or Cascading Style Sheets before when we introduced html 4.0. But we haven’t actually added anything to our webpage yet. So far, our webpage is completely static and unstyled. So Cascading Style Sheets will allow you to modify things like font colors, background colors, styles, as far as like font types, spacing, layouts, pretty much anything that deals with style or looks, the cascading style sheet or the CSS sheet will be able to accommodate that. So how do we actually add any CSS to our web page? Well, we could actually add it directly into the specific tag that we want by adding a style attribute, just like what we did with h ref, but style instead. But this can be very cumbersome, especially as your website grows and becomes very large.\nTypically, what you’ll see is a separate CSS file that is managed across the entire website. So let’s look at trying to add one of those. So here is our base web page here, I’m going to go ahead and add in my link to my CSS. So the link tag, what that’s going to do is essentially importing content from another file. This goes inside of your page header. So right underneath title, what we need to do is add our link tag, and this is self closing, by the way, so we can add the slash there. But the attributes that we want to add here is indicating that this is a style sheet. And the style sheet that we want to load is indicated by the href tag, this is going to be called fancy dot CSS. And I’m just going to continue this on another line so everyone can see here. But we have href. And then finally, what we have for the last tag is the type the content in this file. My link tag has three attributes: rel - so this is going to say what type of link this is or what this link is. So it’s a stylesheet, the href. So this is the file that’s going to be actually loaded, and then the type or what content is in that particular file. So if we save that out, nothing’s actually going to happen because we haven’t actually created fancy dot CSS yet. So if we create our CSS file here, I am going to name this out as fancy dot CSS, save it as all types here. But let’s go ahead and save that out. And then if we refresh our webpage over here, you see nothing is actually happening.\nSo let’s go ahead and create some basic CSS here to color our webpage a little bit. There’s three types of rules that you’ll encounter with CSS. There are tag level rules and class level rules and identifier level rules. So the first one tag level rules will apply to all tags of that type in the web page. So for example, if I wanted to change the paragraph tag, and then I wanted to change the color of that tag to be, let’s say, purple, and refresh my webpage, you can actually see that my text here is now purple. Or we can change this to pretty much any color RGB works here. The hash colors also work here as well, as well as some of the text base colors. a really easy way to get a color that you want is if you look up a color picker, like on w three schools here, you can pick the specific color that you want. So for example, if I had this light purple here, you can see what it looks like down here and you can copy the hash code Hear. So if we, if we copy the color code over the RGB will also work. But I typically go for the pound sign style here makes it a little bit easier to do. This is hex base number. So the first two are for red, the second two are for green, and the last two are for blue RGB. So if I save that out, go back to my homepage here and refresh. Now you can see that it’s that different color purple.\nNow, there are some issues with CSS, especially when you’re modifying it very frequently. Sometimes your change is not reflected, because your web browser will actually cache the CSS file, so your webpage loads quicker the next time around, if you’ve made the change in your CSS file, but the change has not been reflected on your website, just do a simple history clear for this particular web page. And that should fix it up really quickly. Let’s go ahead and change some other things with our text. Let’s look at a class level roll first. So a class level rule is going to apply to all classes of the same name. Now classes can be added as an attribute to any HTML tag. So for example, I’m going to make a class called bold. Or let’s say let’s say important. And so this class, I’m going to add to the let’s say that item item one and my order list and item two in my unordered list. So once we have that added there, I can switch back to my fancy CSS and add this class level rule here. Now, the class level rule is going to be indicated by a.so dot and then the name of the class. So let’s go ahead and change this, I’m going to add to font weight here. And I’m going to make that bolder. So if I refresh my web page here, you can see now that item one here and item two, the items that had the class important added to it are now bold, it makes things kind of nice to actually do, if I wanted any content of any tag bolded, all I have to do is simply add this class here, and that CSS is copied around to make things a lot easier to work with. So we don’t actually have to make duplicates of that bolded style, we can just add it as the class and everything that has that class gets that bolded style.\nSo the last thing that I want to cover with a CSS level rules is the ID level rules. So are the identifier level rules. So any HTML tag, I’m going to pick on item three here. This is going to be thing, thing three. So any tag can have an ID attribute while you can technically duplicate this across multiple tags, it is very poor style. The idea behind the ID attribute is that the idea itself is unique in a given web page. So make sure you never actually duplicate an ID and any other tag. So if we have an ID here, so thing three, I can do pound. And then you don’t want to do iD iD is the name of the attribute, but we’re going to do the ID itself. So this was thing three, and then we have curly bracket there. And let’s go ahead and change the, let’s say font, size, and I’m going to make this 16 pixels. And then let’s go ahead and also do font style. I’m going to make it metallic. Let’s refresh our webpage here. And now you see that this item here as a font size of 16 pixels and metallic. Now if we increase that, hey, you can see the font size change as I kind of ramp things up right So, pixels is a decent measure of size when you’re dealing with HTML. But there are other things like to em, a sizing mechanism will actually help you become more uniform across the screen resolutions. Because pixels are not nearly as relevant before, when we’re developing with web pages, especially in the 90s. And even the early 2000s, everyone had the same screen resolution. But now that we have a lot of screens that are 4k, or 1080 P, and in varying sizes in between pixels become less relevant, because everyone has a different number of them, so it doesn’t scale the same.\nSo a lot of times we’re getting own, we’re developing things like this, especially with font sizes, or widths and heights, pixels are not always the best way to measure. But let’s take a look at this w three schools website here. Now, when you are working on your HTML project, I’m not going to actually teach you every tag, there’s a lot of them out there. And we can spend an entire course covering just HTML. But since we’ve covered how to add basic HTML tags, along with their attributes to your web page, as well as some of the basic CSS rules, you should be able to make your way through this website fairly easily. So for example, let’s say I wanted to add an image to my webpage, well click HTML here, find images. And voila, here is how to add an image to your web page. So there are lots and lots and lots of different tags and lots of CSS rules out there. And like I said, we can spend and an entire class just covering HTML, CSS, but we don’t have time for that for this particular course. But for your project, looking up a specific tag here should be quick enough to actually add this content to your webpage. So I will be asking you to add some tags to your webpage that we have not yet covered, but are easily looked up here as part of the W three schools website. Likewise, same thing goes with CSS, if you’re trying to do any particular thing, and CSS, like for example, colors, we’ve already talked about that a little bit, but backgrounds as well. So background color, color actually changes the font color, not the background color, so just a small difference there. But this is what you’ll be using as part of your projects. So if you need something to look up, I would just find it here nifty the HTML tab or the CSS tab. But if you can’t find what you’re looking for, please feel free to reach out to us and we’ll help you find either the syntax or how to get that out into your webpage.\n",
    "description": "",
    "tags": null,
    "title": "Basic HTML Part 2",
    "uri": "/ii-internet/13-webprog/03-basic-html-2/"
  },
  {
    "content": "This paper is by Gordon E. Moore.\nCramming More Components onto Integrated Circuits\n",
    "description": "",
    "tags": null,
    "title": "Cramming More Components onto Integrated Circuits",
    "uri": "/i-concepts/08-architecture/04-cramming-components/"
  },
  {
    "content": " Watch through 5:50\n",
    "description": "",
    "tags": null,
    "title": "Enigma Machine - Numberphile",
    "uri": "/iii-topics/16-cryptography/03-enigma-machine/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "J.C.R. Licklider Video",
    "uri": "/ii-internet/11-internethistory/03-jcr-licklider/"
  },
  {
    "content": " Resources Slides Video Script The topmost layer of the seven layer OSI network model is the application layer. In this video, we’ll take a look at some application layer protocols and discuss what they do. These protocols are usually used to send data across two different computers using different programs. For example, there are protocols such as pop, SMTP, and eye map for sending and receiving email. We have HTTP and FTP for sending and receiving files and webpages using the World Wide Web. We have DNS and DHCP for helping us configure and set up our networks. And we can use protocols such as SSH, RDP, or telnet to remotely connect to computer systems all across the globe. So let’s take a look at a few of these application layer protocols and see how they work.\nProbably the most important of the application layer protocols is DNS or the Domain Name System. You can think of DNS like the phonebook for the internet. Earlier in this module, we talked about how each computer on the is assigned a unique IP address, which is kind of like a phone number. However, just like phone numbers, IP addresses can be very confusing and hard to remember, it’s just a random string of numbers that we have trouble associating to anything. So instead, DNS allows us to remember domain names, and then it will associate them with IP addresses that actually are the computers we want to talk to. For example, when we open up a web browser and type in www.ksu.edu, DNS actually looks up the value of ksu.edu in the DNS system and returns an IP address like 129.130.8.41. And it says here, you need to talk to this computer to get the ksu.edu. The same thing happens for Google.com, ibm.com. Any website that you put into your web browser, we use DNS to figure out what the IP addresses of the computer system you want to talk to. The domain namespace itself is actually a hierarchical system. At the very top level, you have the root domain name servers. And then below that you have the top level domain servers for domains such as.org.com, dotnet.edu. Each of those have their own domain name servers. Then below that you can have servers for each individual domain names such as ksu.edu, ibm.com, espn.com, they all can maintain their own servers. And they can even delegate to further sub zones. For example, the computer science department runs its own DNS server at cs.ksu.edu. So we can have our own systems.\nThe process for looking up a domain name using DNS is interesting because it’s recursive. In computer science. We’re very familiar with recursive algorithms. So let’s say we want to look up the IP address for wikipedia.org. We would start by going to a DNS for cursor, which is usually a piece of software on our computer, it would go out and try and contact the root name server and say, Where is www.wikipedia.org and the root name server would say, I don’t know but I know where the .org name server is. Why don’t you try there? So then our recursive would go to the.org name server and say, Hey, where is wikipedia.org? And the.org name server says, Well, I know where Wikipedia is, why don’t you go try there. So then we’ll go talk to the wikipedia.org name server and ask it Where is www.wikipedia.org. And that org name server will say, Aha, I am the authoritative name server for wikipedia.org. And I can tell you that it is at this IP address. So then your DNS cursor will tell your computer Oh, you want to go to wikipedia.org. It’s this IP address. And usually this process happens within just a fraction of a second after you press the Enter key to load a webpage.\nThe next protocol we’ll discuss is the Dynamic Host Configuration Protocol or DHCP. DHCP is what allows a computer to connect to an unknown computer network and get an IP address and get connected without any other configuration needed. Before DHCP was really commonly used bringing your computer to a new office, usually required quite a lot of technical setup. And it made it very hard to have portable computers available like we do today. The Dynamic Host Configuration Protocol consists of four very simple steps that happen whenever a new computer connects to the network. Let’s go through those steps really quick and see what they do. In the first step, the client will send a DHCP discover message, which is basically a shout message that goes to every single system on the network. And it says, Hi, I’m new, I need an IP address. Then, on the network, there’s a DHCP server that is listening for those shout messages. And it will send back its own shot message of a DHCP offer that says Hi, I’m a DHCP server. Here’s an IP address and some configuration information you can use. Then the client once it gets that information, we’ll send a short message that says hey, that’s great. I’d like to use that information. And finally the DHCP server will send back one final shout that acknowledges Okay, good. That’s your information. Good luck. And then it will record that that IP address has been used by that particular computer. Meanwhile, the computer will use that information to configure its network settings so that it can talk to the network. So whenever you come to campus and you bring your computer and you see your wireless icon flashing for a few seconds before it goes solid, the DHCP protocol is actually what’s going on. It is connecting your computer to K-State’s wireless network requesting an IP address and getting connected so that you can use the internet on your mobile device.\nAnother important protocol at the application layer is the hypertext transfer protocol or HTTP. HTTP was developed by Tim Berners-Lee to actually send webpages using the World Wide Web. And it was developed in the late 1980s. And it’s really a revolutionary part of the internet we use today. Here’s what the HTTP protocol actually looks like. It is very interestingly, a text based protocol. So at the top of this image in red, we have the request where we’ve connected to wikipedia.org and we’ve requested to get the main page. So then the web server we’ll respond. And in blue, it responds with the response headers that tell us about the information we’re about to receive, such as the size and different things about it. And then finally, in green, you see the body of the response, which is actually the HTML that makes up the webpage that gets sent. And so if you’re really good, you can use tools such as telnet to browse the web. By typing in these HTML, HTTP requests and getting the response directly from the web server. It’s a really fun activity to try if you’re interested.\nTo make things a little bit simpler HTTP requires several different commands. For example, there is the get command that used to request a webpage, the post command that used to send data back to a web page, the head command, which gets information about the page without actually loading the page itself. And then there are other commands that are less often used, such as put and delete to change pages and delete pages off a web server.\nTo further simplify things, HTTP also defines a set of status codes that the server can respond to With telling more information about the response, the sending the most common response hopefully is 200, which simply means Okay, I received it and I’m sending back data. You can also get responses like 301 moved permanently if a website has been moved, you can get 434 bitten if you try and log into a website that you don’t have access to. And you can get some dreaded errors such as the 404 not found error if that web page can’t be found on the server. Of course, there are other errors, such as the 500 errors, the internal server errors, that means the server itself is having a problem and can’t respond right now. There’s also the 503 error, which means that the service is unavailable, but it might come back soon. As you can see, there are a lot of different application layer protocols that are used on the internet today, and they all serve a variety of different purposes. I hope this has been a really interesting look into the technology behind how the internet works. In the next few modules will actually explore what it takes to build web Websites ourselves.\n",
    "description": "",
    "tags": null,
    "title": "Protocols",
    "uri": "/ii-internet/12-internettech/03-protocols/"
  },
  {
    "content": " Resources Slides Video Script Now that we’ve talked a bit a little bit about the history of software development and software engineering and how it’s evolved over the years, what are some of the key activities that we actually engage with in this process. Now, you’ve already used and worked with a lot of these already, even if you haven’t really made the connection to them yet. Software Engineering overall will come with quite a few different processes along with it. But overall, you can kind of expect these six different stages.\nNow, to begin the process off, we’re going to start with requirements gathering are going to actually go around and collect information about the software that we’re actually being tasked with to develop. So this involves with going and meeting with clients meeting with users meeting with business folks meeting with just about Anybody and everybody that might be a stakeholder or involved with actually using that software or funding that particular kind of project.\nNow, once we have gathered all of the requirements for the software, then we can make the jump into the software design. So here we’re going to start to architect the project and lay it out overall, but we haven’t actually even done any programming yet. That doesn’t actually typically happen until the design has been actually completed. So once we actually start the implementation, then after the code has been finished, or at least a stage of the code has been finished, that code is then split off into the testing phase. Sometimes the implementation and testing phase, you might see done as one as if you’re on a small team or depending on the kind of approach you’re actually taking to the development lifecycle.\nBut after the software has been fully tested, then it gets deployed or installed. And then it goes into like a maintenance mode, right. So a lot of times you get the first Windows updates and various other software updates on mobile apps and games and everything in between. So that’s the maintenance phase, right, where we’re trying to update patch, fix anything that may actually been broken, or things that we didn’t catch during the testing phase. But you see that now I’m back at the requirements gathering.\nMost of the software development life cycles that we actually see an encounter are a never ending cycle. Software is never perfect the first time around that we actually build it. So more often than not after creating what we refer to as a prototype. We’re going to end up going back to the requirements gathering stage, talk to our customers, talk to our consumers, talk to our stakeholders, and give another shot at it. Whether or not whether it’s just a, a simple update, or feature addition, or even a complete rewrite in some cases if we didn’t get it right the first time. But let’s take a look at some of the early software development life cycles that were developed. Now, you’ll notice that these each of the activities that we just talked about before lend themselves very well to a systematic step by step approach, where each activity is followed by the next and we kind of loop back onto this.\nThis is essentially the approach that was developed as a standard strategy for software engineering after the work by Margaret Hamilton in the early 1960s. And over the next few decades, an approach that we call the waterfall model of software development for reasons obvious from the graphic, where each phase flows from the next into a highly linear fashion now In the waterfall development, as I mentioned, right, this is a very linear process. This isn’t like the software development lifecycle that we’ve showcased earlier, where we start with the requirements gathering. And we cycle through each phase. And we end back up at the beginning of the waterfall method assumes that each phase is done in one shot, so there’s no reduce.\nSo we gather the requirements and design the software, implement it, test it, so verification, and then we go into the maintenance mode. So of course, we install and deploy the software in between there. But once we’ve deployed the software and enter maintenance mode, we’re not going to actually be going back and doing more requirements gathering or redesigning anything, it’s just some simple bug fixes at that point. So, it emphasizes the waterfall model emphasizes that the actions are arranged as discrete phases in sequential order, although depending on the model that you actually look at some splashback is acceptable. So if you imagine an actual waterfall, some water gets splashed back up and falls back down. So maybe we get to the implementation phase, but we recognize that our design is severely flawed. So we may bump back up, change the design a little bit, and go back down into the actual coding phase.\nBut here, the entire system, and the waterfall model is implemented, designed and deployed all at once. So planning, scheduling, target dates, budgets, all of those things are set in advance. Most of the time, these are often set by contracts. So there’s really no flexibility there with as far as funding and deployment dates go. A lot of times with the waterfall model, there’s a lot of extensive documentation and very tight control. So this is a very heavily managed process. So this is really useful for processes that require a little A lot of structure. And we’ll talk about some other models here in a little bit that have a lot less structure, and that offer a much more flexible approach to software design.\nAdditionally, during this time, scientific management techniques were adapted for use in the management of software developments. One of the landmark books capturing this evolution was Barry Boehm’s Software Engineering Economics book, where he argued for considering trade offs between adapting existing software and creating new software on economic terms. And so we use statistical analyses to develop equations like this one, seeking to equate development time in main years to the metric of software lines of code, or SLOC. Now, there are there’s a lot of debate around measuring the productivity of let’s say, developers and cost of software based off of the number of lines of code that are actually produced. And there’s a lot of fallacies behind that metric as well. But a lot some people actually some fall into that trap.\nAnother book from that particular time period refutes some of those both some of those arguments as I mentioned, they were very controversial. But this book, the mythical man month, details many software engineering management fallacies. Like, for example, adding more programmers to a late project will absolutely right help it finish sooner, but not so much. In practice, bringing new developers up to speed consumes much of the current team’s time, and overall slows the development. So let’s say you’ve been working on this really big important project for nine months. But you are a couple, maybe a month or two behind schedule. So management comes in brings in new developers to try to help get you back on track. But it actually ends up putting you back farther in your time schedule because you had to stop your productivity to get the new people caught back up to speed.\nAnother fallacy here that is discussed in the mythical man month is the use of crunch time. Crunch Time is typically portrayed as an increase in productivity, right. So, you know, spending, you know, 60 to 80 hours a week to meet that deadline. So, pulling 18-20 hour days, programming all night, I’m sure you have probably done this when studying for a really big exam. Crunch Time doesn’t necessarily increase productivity. Studies have actually shown that a breakeven point for let’s say software development lies around about 35 hours. There’s been research that shows about 30 a year your average limit for a software developer is about 30. 35 hours of programming per week. Beyond that, a fatigue programmers introduce more bugs into their code at a faster rate than they’re actually removed. So that ends up costing a lot more money and time because they’re, you know, fatigued. Developers that have just been coding for too long or going to be more prone to produce bad code. I’m sure some of you some some of us have experienced this as a student, as I mentioned, as you’re studying, you know, when you’re really exhausted, or have had way too much caffeine are way too much coffee. You may not be studying as efficiently or or productive. Your productivity may not increase proportionally to the amount of time that you’re you’re actually spending versus the amount of time you’re spending when you weren’t exhausted.\n",
    "description": "",
    "tags": null,
    "title": "Software Development Life Cycle Part 1",
    "uri": "/i-concepts/09-software-engineering/03-sdlc-1/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Supercomputing and eScience (Eng)",
    "uri": "/iii-topics/14-hpc/03-supercomputing/"
  },
  {
    "content": " Resources Slides Video Script On the previous page in NLS was a very revolutionary system. Unfortunately, it was very hard for the average user to use. And so it really never could gain that mainstream reputation that it wanted. So we had to come up with an easier way to use modern computer systems.\nAnd as the story goes, and engineer one day was staring at the top of his desk thinking about how to solve this problem, and that solution came to be known as the desktop metaphor. What if we build a computer system that looks and acts and feels like the things that we’re used to in the real world, we can have a desktop with different things open on it as we’re working. We can have files and folders full of files that allow us to organize information, and we can move things around quickly and easily to get us different views of the same thing.\nThis is what most modern computer systems were built around, and it was first introduced all the way back in 1970. This picture shown here is from the Xerox star workstation in 1981, which was one of the first real mainstream computers to use the desktop metaphor. Of course, in those days, one of the things that computer companies were really well known for is borrowing or stealing other ideas from other companies. And so Apple stole basically the same desktop metaphor idea for its Macintosh desktop from 1984.\nAnd there’s always been a little bit of discussion about who actually came up with it first, this was actually dramatized in a TV series called The Pirates of Silicon Valley. So let’s take a look at a short clip from that TV show to give you an idea of what things were kind of like at that time.\n",
    "description": "",
    "tags": null,
    "title": "The Desktop Metaphor",
    "uri": "/i-concepts/10-hci/03-desktop-metaphor/"
  },
  {
    "content": " Resources Slides Video Script In the previous video, we looked at binary numbers that are natural numbers, which are whole numbers greater than zero. There are a couple other binary data types that we’re going to look at in this module. The first one would be a signed integer, and assigned integer allows us to have negative values by changing the sign at the front of the number. So just like with decimal numbers, where we put a minus sign in the front to differentiate between positive numbers and negative numbers, we can do something similar with binary numbers by changing a sign bit at the front of the number to determine if it’s positive or negative. But there are a couple of caveats to that. And let’s take a look at that in this video.\nSo to understand negative numbers in binary, let’s start with our positive number again. On the last slide, we saw that the number 101010 in binary is the decimal number 42. In a signed binary number, instead of using this first digit as 128, we’ll use it as our assignments. And we will say by convention that if this bit is zero, it’s a positive number. And if this bit is one, it’s a negative number. So of course, we want an easy way to switch between our positive and our negative numbers.\nSo one of the first ways you can think about negative numbers in binary is what’s called the ones compliments. And so to calculate the ones compliment, we simply invert all of the bits. And so we would say that this number is negative 42, in ones compliments. So as we saw in that example, ones compliment is a very easy way that we can calculate the negative number of a binary number, we just invert all of the bits and declare the first bit to be the sign bit where zero is positive and one is negative.\nHowever, there is a problem with the ones complement method of finding negative numbers in binary, which is why we don’t actually use it in practice. Let’s take a look at what that problem is and see if we can spot it. One of the most important things about binary numbers and any negative numbers, in fact is we should be able to add a positive value and a negative value together and get a logical result.\nSo let’s try some ones complement addition and see what happens. So we’ve already seen the positive value of 42. Before. And previously In this video, we calculated the negative value of 42 using one’s complement. So with these two values, if we add them together, we should get a value equal to zero. And remember, in binary, a value equal to zero is all zeros. So let’s try this addition and see what happens. Since a binary number is just like any other number, addition should work just like we expect. So here we would do zero plus one, and we get one, we do one plus zero, we get one. And very quickly, we’ll realize that since we inverted these values, each place is going to have a different value. So when we do positive 42 plus negative 42. As one’s complement, we get this number that is all ones. So when we add the positive value of 42, and the negative value of 42 using one’s complement, we end up with this number that is all ones.\nSo what is this number? Well, we know that this number is a negative number, because the first bit the sign bit is one. And so to find its positive value, we would invert all the bits. So we would invert all of these ones to zeros. And so we know that this number is zero in decimal. So if this is zero, then this number must be negative zero.\nBut wait a minute, is there such a thing as negative zero? That really doesn’t make any sense? And that is where the problem with one’s compliment lies. If we take the negative value and its positive value, and we add them together using one complement, we end up with this weird number called negative zero, which doesn’t exist. So one’s compliment while it seems to make sense on the surface, mathematically, it really doesn’t work out. And so here’s the result of this example. As we saw, we end up with a number that is negative zero.\nSo we need to come up with a better way for us to calculate a negative number in binary. The answer to that is a process we call two’s complement. Two’s complement is very similar to one’s complement with one extra step. In two’s complement, we will invert all of the bits, and then we will add one to the value of the number. So let’s try that on our example number of 42.\nTo calculate the two’s complement of 42, the first thing we will do is we will invert all of the bits and then we will add the value one to that resulting number. So we have one plus one in binary is a zero and then we will carry the one, then we’ll have one plus zero here, we will get one, and then the rest of this will just carry down. So the value negative 42 in two’s complement looks like this 11010110. There is a shortcut way to do two’s complement, where you start at the end of the number and you find the first one. Everything after that stays the same, and everything in front of that gets invert. So, again we see one zero stays the same, and and everything in front of that one gets inverted. That’s a quick shortcut to do two’s complement. So remember, to perform two’s complement, we first invert all of the bits, and then we add one and we will get this value for negative 42.\nSo now that we’ve calculated the value of negative 42 using two’s complement. Let’s do that same example before we add these two values together and check that our result makes sense. So once again, we want to do our addition example and make sure that this works. So now if we start over at this column, we will have zero plus zero is zero, we will have one plus one will become zero, we will carry a one, then we will have one plus one is zero, carry the one, zero, carry the one, zero, you can kind of see a pattern here where we have zero, carry the one zero, carry the one, zero, and then we will have this one that overflows. And right now, we’re not going to worry about that most math processors just ignore this one. But there is technically a one that does overflow when we do this, but now you’ll notice that we get a number that is all zeros, which in binary is clearly the value zero. So two complement addition works just like we expect it to.\nIf we take 42 plus negative 42, we will get the value positive zero. And once again, here’s the example on this slide completely worked out. So it works. That’s pretty cool. There are, of course, a few other binary values that are important to understand. We know that binary values can be both signed and unsigned. And so what’s really interesting is if we start counting up from zero, the sign values and the unsigned values will be the same all the way up to 127. Then when the first bit becomes one, the sine value and the unsigned value will diverge. At that point, the unsigned value will be 128, but the sine value will be negative 128. And so as we continue to count up in binary, the unsigned value will continue to get larger, whereas the sine value will start to get smaller all the way back down to negative one. This is why we get some really interesting things in the range of these values.\nAnd that particular problem is known as integer overflow. If you’re working with a signed integer, but you’re always counting up, eventually you’ll reach a point where it will overflow and go from the highest possible value to the lowest possible value. And this is really hilariously explained in this XKCD comic, where if you count sheep and you get to 32,767, you will overflow and get to negative 32,768. And you’ll have to start all over again with your sheep going the wrong way over the fence. Because of this eight bit binary numbers have an interesting range and unsigned eight bit binary number can go from the value zero all the way to the value of two to the eighth minus one which is 255. Assigned value, however, can go from negative two to the seventh, which is negative 128 to positive to the seventh minus one, which is positive 127. So So in general, a binary number within bits, if it’s unsigned can go all the way to two to the n minus one, where if it’s signed, it’s negative two to the n minus one to positive two to the n minus one minus one.\n",
    "description": "",
    "tags": null,
    "title": "Twos Complement",
    "uri": "/i-concepts/07-encoding/04-twos-complement/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Electronic Computing (Crash Course)",
    "uri": "/i-concepts/05-universal-computers/04-electronic-computing/"
  },
  {
    "content": " Resources Slides Video Script In these next couple of videos, we’re going to introduce the concept of sorting algorithms. Sorting algorithms are used when we want to arrange sets of data in order either from smallest to largest or largest to smallest in our computer programs. As it turns out, there are many different ways that we can sort our data using different algorithms. And each of those algorithms have unique characteristics that make them suitable for certain types of data in certain situations. To really explore sorting algorithms, we’re going to perform these sorting algorithms using a deck of cards. So if you have access to a deck of cards, I encourage you to go find one and take out maybe 8 or 10 cards in a certain order. I have the cards Ace through 10 here, and you’ll be able to follow along with our examples on these next few videos. Before we get started, I’d like you to take the cards that you have selected, shuffled them up a little bit, and then lay them out in front of you and try and sort them in order from smallest to largest. And while you do that, I’d like you to think in your mind about the exact steps that you’re following. For example, are you looking for the smallest card and moving it to one side, or looking for the largest card and moving it to the other side? Or are you trying to arrange little bits of it at a time and slowly put those pieces together until they form the full sort of deck of cards, it might be really interesting to see how the method that you naturally follow matches up with one of these algorithms that we’re going to take a look at. In particular, we’re going to look at four different sorting algorithms, insertion Sort, bubble sort, merge, sort, and quicksort.\nThe first example is insertion sort. In insertion sort, there’s basically three steps. And you can see in this graphic up above how they work. First, we’ll choose an element from our array, and we’ll place it in the correct place in our destination. So we go through we take the card, we put it where we want, and we repeat until our array is empty and we have completely sorted the cards. So let’s take a look at it. An example of how to do that using a deck of cards. Let’s take a look at how to use a deck of cards to simulate insertion sorts. Here I’ve selected 10 cards out of a deck of cards, and I’ve arranged them in a random order. If you want to follow along at home, feel free to grab either a suit out of a deck of cards, or you can grab just 10 cards in numerical order. In this case, I’m using the ace is one at the low end of the scale. So to do insertion sort, all we have to do is take each value out of our initial array and place it where it would go in the final array. So the first value we’ll have is a nine and we know that that needs to go in the 9th position here. Then we have the 4 we know that the 4 has to go before the 9. Now we have the 8 and we know that the 8 goes between the 4 and the 9. We get a three. It needs to go before the 4. We get to it goes before the three now we get a 5 the 5, does not go here does not go here, but it goes after the four. So we’ll move all of these down and make room for the 5. The ace, of course goes here at the beginning, the 10, we look through, and we see that it goes all the way at the end. Then we have the seven, we see that goes here between the 5 and the 8. And then likewise, the sixth would go there as well.\nSo that’s what insertion sort looks like when we as a person does it. But what if a computer was trying to do insertion sort? Let’s take a look and see what that would look like. So now let’s do Insertion Sort like a computer would do it. Instead of knowing exactly where the cards might go. A computer has to only compare two cards at a time and see what should go. So the computer would start by grabbing the 5 and placing it in our destination. Then the computer would grab the ace and say, does the ace go below or before the 5? It does. So we’ll put the ace before the 5. That’s all the computer does. Next, the computer grabs the three and says, “Does the three go before the ace?” Nope. Does the three go before the 5? Yes. So it would place the 3 before the 5. Then it would do the same thing for the 10. It would see does the 10 go before the ace? No. Does it go before the 3? No. Does it go before the 5? No, it goes at the end. So go ahead and see if you can do insertion sort and keep track of how many times you ask yourself does this card go before this card? Does this card go before this card that will give you an idea of how many steps it would take a computer to do insertion sorts a little bit later, we will analyze what that looks like using some complexity. The analysis with our algorithms doesn’t go there doesn’t go there doesn’t go there doesn’t go there must go at the end. And we can repeat this process for all the rest of these cards by going from the front to the back, and figuring out where each card belongs. That’s an example of how to do Insertion Sort using a deck of cards. See if you can do it yourself and follow along and understand how this algorithm works.\n",
    "description": "",
    "tags": null,
    "title": "Insertion Sort",
    "uri": "/i-concepts/06-algorithms/04-insertion-sort/"
  },
  {
    "content": "Due to the privacy settings, we were not able to embed the following video directly.\nClick here to watch the video\n",
    "description": "",
    "tags": null,
    "title": "The Queen of Code",
    "uri": "/i-concepts/04-programming/03-queen-of-code/"
  },
  {
    "content": " Resources Slides Video Script So now that we have the capability of computing values without human error, once we have that ability, the next important part of the computer is to accept variable input from the user. And as I mentioned before, it’s not just the fact that we can input numbers into the computer. But, what if we could actually reprogram the device? Right? What if we could enable certain features or certain abilities of that computer by just pushing the input?\nCan anyone guess what mechanical device was the first one to accept variable input from a user? It was the Jacquard loom. Not a whole lot of people know about the Jacquard loom, but it was invented in 1801 by Joseph Marie Jacquard, who basically simplified the process of manufacturing textiles. Particularly with textiles that have really complex or shifting patterns or even rounded designs and things of that nature. The Jacquard loom used a series of punch cards to control the thread. While this doesn’t actually perform any calculations, it is very important as this is the first example of a machine responding to different input or programs in the form of punch cards. Now, the car loom wasn’t the first thing that ever used the idea of punch cards. There was a few things before its time, but there’s Jacquard loom was one of the first one that truly automated the process. Although there were still some manual aspects of the Jacquard loom, the majority of it was completely automated.\nThe Difference Engine wasn’t the only computer designed by Babbage. The Analytical Engine, which was Babbage’s true dream: a general purpose computer. Had it been built as Babbage envisioned, it would have been one of the first true modern computers. He previously worked on design of an analytical engine, which was a true multi purpose computer. It would have been composed of several different parts that each performed different functions, allowing it to do many different kinds of calculations, be reprogrammed, store information and all sorts of different things. This was one of the first steps that we have seen, be developing or to developing a true modern multi purpose computer. Analytical Engine used a set of input cards called punch cards to determine what calculations to do and what numbers to use. And so this was greatly inspired by the Jacquard loom. This is very similar to how programs on today’s computers are structured: with a list of instructions on the program or in the program and the data that’s provided by the user.\nBorrowing that idea from the Jacquard loom, the analytical engine was able to use a system of punch cards to accept input and determine the calculations that needed to be done. Babbage’s son remarked once that the Analytical Engine could calculate almost anything, it is only a question of the cards and time. So how many cards it would require and the amount of time it would take to actually operate, speculating that 20,000 cards would not be out of the question. It was a pretty impressive physical mechanical machine. This is very much like how modern computers worked, and even in the 40s and 50s a lot of computers worked off of this punch card system.\nIn the Analytical Engine, there is also the mill. The mill is really the heart of the machine. I was equate this closer to what a modern CPU was. In order to handle the computation done by the machine, Babbage designed this part that was capable of performing all of the basic numerical calculations. This used many of the breakthroughs that Pascal and Leibniz had some 200 years earlier. And so here in this picture on the slide is a very small picture of one part of the mill, which was constructed actually by Babbage’s son in 1910 to show that it was actually possible. The mill is able to perform all the basic arithmetic operations like addition, subtraction, multiplication, division, as well as calculate the square roots of numbers. This is really the first true step towards a modern CPU, which is really exciting. With those two parts in place, the next big hurdle was the ability to store data and output the results.\nThe store was Babbage’s true innovation. The store, which would have been a bank of columns capable of storing up to 1000 numbers up to 40 decimal places each. So that’s pretty high precision for a mechanical device. This was equated to roughly 16 to 17 kilobytes of modern day storage if you want to look at it that way, so quite a bit. Now, while the store was never actually built for the Analytical Engine, much of the design for the store was incorporated into his Difference Engine number two design, which is shown here in this picture. This represents the first time that calculated values could be stored directly in the machine, and recalled at a later time as required by the program.\nThe last thing that our computer should be able to do is output results. Charles Babbage also thought of this, right. As we saw in the video, in our previous lecture, Babbage also designed a printer that would output the results of calculations, not only onto paper, but directly into a plaster panel that could be used to create printing plates. You can imagine using this device to maybe make all of those tables in the back of your mathematic textbook. Which were a pain to do by hand, but now we could have a machine that would actually do the math and print it as well.\nNow what those parts in place the stage is really now set for the coming computer revolution. Unfortunately, it will take an entire world consumed by war before the next major step in the history of computing was made. And we’ll pick that story up in the next couple of lectures.\nThis really leads us back to Charles Babbage, the father the modern day computer, it’s really quite mind boggling to see the Difference Engine, Analytical Engine, the Difference Engine number two, really all of which you only completed a simple prototype during his lifetime. And the fact that he was able to create these devices completely theoretically on paper, and they worked as intended exactly how he designed them is really, really quite amazing. Charles Babbage is known as the father of modern day computer because of these devices that were really truly one of the first examples of a general purpose computer. But if you’re interested in learning more about Charles Babbage, you can read his autobiography titled, “The Passages from the Life of a Philosopher” which is free and available online.\n",
    "description": "",
    "tags": null,
    "title": "What is a Computer (Pt. 2)",
    "uri": "/i-concepts/02-early-computing-machines/06-what-is-a-computer-pt2/"
  },
  {
    "content": " Resources Slides Video Script Logic via Electrical Switches? (Slide 9) With the new tools from Boole and DeMorgan, others began to see where they could be applied in the real world. In 1886, Charles Sanders Peirce noted in a letter that logical operations could be easily simulated by electrical switches. Many others worked on the idea too many to name here, but 51 years later.\nClaude Shannon (Slide 10) In 1937, something happened. In 1937, Claude Shannon, a 21 year old graduate student at MIT was working on this same idea. He wrote a master’s thesis that some of called the most important master’s thesis of all time, titled a symbolic analysis of relay and switching circuits. In it, he showed that you could use electrical switches in Boolean algebra to construct circuits that could show any logical OR numerical relationship that you wanted. It’s available free online and will be linked in Canvas and linked in this video as well if you’re interested, but this is really cool. Kind of what was the gateway to electrical circuits, all of the cell phones and computers and electronic devices that you use today, this was the initial theory behind how all of those devices actually work.\nLogic Gates (Slide 11) So underneath Claude Shannon’s representation as far as translating Boolean algebra and Boolean logic into electrical circuits, we also needed a new representation for that this new representation is called logical gates. So it’s basically the same setup as we had with Boolean algebra and is very similar to if we have a and b, this is equivalent to this right where our two inputs are coming in on these two lines here are the AND operator it’s like a D, and then our output is the line leaving from the operator. similar idea for or so this is a or b we have XOR a XOR B, and not so this is same thing as saying that. Now really with the knot, the really important part is this little knot or this little mini circle at the end here and also note right that all of our Boolean operators here are compound operators, meaning that we have a left hand side and a right hand side, but the NOT operator only has one input. So one fact so just keep that in mind. But we can also apply the NOT operator to all of our other operators as well. So we can have NAND, nor, and x nor a little.at. The end here on the output is really the only part that matters for negating the result of a operation and and or XOR. One of the interesting things though, that it’s really kind of come out of the representation of Boolean logic on electrical circuits. So The work done by Claude Shannon and will continue part of this work and future lectures as well.\nThe Universal Logic Gate (Slide 12) But one of the really interesting things that have kind of come out of this is the idea of a universal logic gate. The idea here is that any electrical circuit can be finished off by just using NAND gates. So all the complex Boolean logic that we could ever think of so any logical statements that we could write in Boolean algebra or Boolean logic can be redone with just using NAND gates or NAND operators, which is a pretty interesting thing and really why this is so important is that it greatly increases the speed efficiency and decreases the cost of manufacturing electrical parts.\n",
    "description": "",
    "tags": null,
    "title": "Logic to Switches",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/04-logic-to-switches/"
  },
  {
    "content": "Discussion of a nanosecond starts at 4:17\n",
    "description": "",
    "tags": null,
    "title": "Nano Second",
    "uri": "/i-concepts/04-programming/04-nano-second/"
  },
  {
    "content": " Resources Slides Video Script The next influential woman in computer science that we’ll talk about here is Margaret Hamilton. Margaret was the director of software engineering at MIT’s instrumentation lab. Margaret Hamilton was also known as the, essentially the creator of the field of software engineering, essentially. But the reason why she is credited for software engineering is that she was responsible for a team that developed onboard flight software for the Apollo space program. During this timeframe, her program actually prevented a mission abort during the Apollo 11 moon landing, which is kind of crazy cool to think about right.\nIn this picture here is, she’s actually standing next to the output of one of the programs that they had actually made. In the video here you’ll see that, you know, programming at this time was completely by the seat of your pants, right? There was no really step by step procedure or best practice of programming pretty much anything. And so the idea that NASA trusted this group of engineers to create the flight software for the Apollo space program was really kind of crazy to think about. And so if you had actually messed up, right, the output of your program would just be you know, feet high instead of just a few pages long, which is this famous picture with Margaret Hamilton here in the slide.\n",
    "description": "",
    "tags": null,
    "title": "Margaret Hamilton",
    "uri": "/i-concepts/04-programming/05-margaret-hamilton/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Software in Space",
    "uri": "/i-concepts/04-programming/06-software-in-space/"
  },
  {
    "content": " Resources Slides Another useful way we can work with dictionaries in Python is by iterating through them. In Python 3.6 and beyond, the items in a dictionary will be presented in the same order that they were added to the dictionary. This isn’t always the case in other languages or older versions of Python\nLoops with Dictionaries - Keys There are two ways we can iterate through a dictionary in Python. Below is an example of the first, and simplest, method:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } for key in dict_3: print(\"{}: {}\".format(key, dict_3[key])) In this method, we are iterating through the entire dictionary using a for loop. However, the dictionary will only store the key for each key-value pair in the iterator variable. So, to access the value associated with the key, we can simply place it in square brackets after the dictionary’s variable name.\nWhen we run this program, we should see the following output:\nAs we can see, it will print each key-value pair in the dictionary, one per line.\nLoops with Dictionaries - Keys and Values The other method we can use when looping through a dictionary allows us to access both the keys and values directly within the loop. Here’s an example of using that method:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } for key, value in dict_3.items(): print(\"{}: {}\".format(key, value)) In this method, instead of iterating through the dictionary itself, we iterate through the items() in the dictionary. When we call the items() function in a dictionary, we are given a list of the key-value pairs that it contains, and each key-value pair is stored as a tuple. From there, we can access each of the elements in the tuple individually using a comma , between two variable names. It is a bit complex, and touches on a few concepts in Python that we won’t cover in this course, but hopefully it makes sense by looking at the code.\nWhen we run this program, we’ll receive the same output as the previous example:\nWhile iterating through dictionaries is not as common as iterating through lists, it is still very important to know that it can be done. Hopefully you’ll find this example useful as you continue to work with dictionaries in Python.\n",
    "description": "",
    "tags": null,
    "title": "Loops with Dictionaries",
    "uri": "/x-cis115-labs/14-dictionaries/02-loops-with-dictionaries/"
  },
  {
    "content": " Resources Slides One great way to work with lists in Python is using a loop. Recall from an earlier lab that a for loop actually iterates over a list itself, and that the range() function is simply used to generate a list that the for loop can use. Likewise, while loops can also be used in a similar way.\nLet’s look at a quick example of how we can iterate through the items in a list using a loop in Python.\nFor loop Consider the following example program in Python:\ndef main(): nums = [3, 1, 4, 1, 5, 9, 2] print(\"The first seven digits of pi are...\") for i in nums: print(i) main() In this example, the for loop will iterate through the values in the nums list instead of a given range. So, during the first iteration, i will store the value $3$, then $1$, then $4$, and so on until it reaches the end of the list. When the program is executed, we should receive this output:\nUsing a list in a for loop is an excellent way to go through each element quickly, and it allows us to build for loops that don’t require the use of the range() function to generate a list that is in some sort of sequential order. We’ll see this pattern used very often in our programs using lists.\nFinally, it is not recommended to edit the contents of the list while inside of the for loop using this method. Since we are only getting the individual values from each list element, we cannot easily make changes to the list itself without causing issues in the loop itself. Instead, if we want to make changes to the list while we are iterating through it, it is highly recommended to use a while loop structure as shown below.\nWhile Loop It is also possible to iterate through a list in Python using a while loop. However, instead of iterating through the items themselves, we can use an iterator variable that references the indexes of the elements in the list. Consider this example program:\ndef main(): nums = [3, 1, 4, 1, 5, 9, 2] print(\"The first seven digits of pi are...\") i = 0 while i \u003c len(nums): print(nums[i]) i = i + 1 main() This program is effectively the same as the one above, except that it uses a while loop to iterate through the items in the nums list. We start by setting the iterator variable i to be $0$, the first index in the list. Then, in the while loop, we use the special len() function, which is used to find the size of the list. Since the list contains seven items, the length of the list is $7$. Another way to think about the length of the list is that it is always one more than the highest index - if the last item in the list is at index $6$, then the length of the list overall must be $7$.\nThen, inside of the loop, we’ll use the iterator variable i inside of square brackets to access each individual element in the nums list and print it to the terminal. We’ll also need to remember to increment i by one each time.\nThis method is very useful if we want to do more with the list inside of our loop, such as edit individual elements or make changes to the overall structure of the list. This works because we can directly manipulate the value in the iterator variable i, and then use it to access individual elements in the list and update them. Also, if the size of the list changes, it will be checked using the len() function after each iteration of the while loop.\nSo, as a general rule, we should use a for loop when we just want to iterate through the list and not make any changes to the list while inside of the loop. If we do need to make changes, it is better to use a while loop and an iterator variable to access the list elements directly.\n",
    "description": "",
    "tags": null,
    "title": "Loops with Lists",
    "uri": "/x-cis115-labs/13-lists/02-loops-with-lists/"
  },
  {
    "content": " Resources Slides For loops can also be nested, just like while loops. In fact, nesting for loops is often much simpler than nesting while loops, since it is very easy to predict exactly how many times a for loop will iterate, and also because it is generally easier to determine if a for loop will properly terminate instead of a while loop.\nA great way to explore using nested for loops is by printing ASCII Art shapes. For example, consider the following Python program that contains nested for loops:\ndef main(): for i in range(3): for j in range(5): print(\"* \", end=\"\") print(\"\") main() Just by looking at the code, can you predict what shape it will print? We can check the result by running the program on the terminal directly. If we do so, we should receive this output:\n* * * * * * * * * * * * * * * It printed a rectangle that is $3$ rows tall (the outer for loop) and $5$ columns wide (the inner for loop). If we look back at our code, this hopefully becomes very clear. This is a very typical structure for nested for loops - the innermost loop will handle printing one line of data, and then the outer for loop is used to determine the number of lines that will be printed.\nThe process for dealing with nested for loops is nearly identical to nested while loops. So, we won’t go through a full example using Python Tutor. However, feel free to run any of the examples in this lab in Python Tutor yourself and make sure you clearly understand how it works and can easily predict the output based on a few changes.\nExample 1 Let’s look at a few more examples of nested for loops and see if we can predict the shape that is created when we run the code.\ndef main(): for i in range(5): for j in range(i + 1): print(\"* \", end=\"\") print(\"\") main() This time, we’ve updated the inner for loop to use range(i + 1), so each time that inner loop is reached, the range will be different based on the current value of i from the outer loop. So, we can assume that each line of text will be a different size. See if you can figure out what shape this will print!\nWhen we run the code, we’ll get this output:\n* * * * * * * * * * * * * * * We see a triangle that is $5$ lines tall and $5$ columns wide. If we look at the code, we know that we’ll have 5 rows of output based on the range(5) used in the outer loop. Then, in the inner loop, we can see that the first time through we’ll only have a single item, since i is $0$ and the range used is range(i + 1).\nThe next iteration of the outer loop will have $1$ stored in i, so we’ll end up repeating the inner loop $2$, or i + 1, times. We’ll repeat that process until the final line, which will have $5$ characters in it to complete the triangle.\nFrom here, we can quickly modify the program to change the structure of the triangle. For example, to flip the triangle and make it point downward, we can change the range in the inner loop to range(i, 5) instead!\nExample 2 What if we want to flip the triangle along the vertical axis, so that the long side runs from the top-right to the bottom-left? How can we change our nested loops to achieve that outcome?\nIn that case, we’ll not only have to print the correct number of asterisks, but we’ll also need to print the correct number of spaces on each line, before the asterisks. One possible way to achieve this is shown in this code:\ndef main(): for i in range(5): for j in range(4 - i): print(\" \", end=\"\") for j in range(i + 1): print(\"* \", end=\"\") print(\"\") main() Here, we have two for loops nested inside of our outer loop. The first loop creates a range using the expression 4 - i, and the second loop uses the expression i + i. So, when i is equal to $0$ during the first iteration of the outer loop, the first inner loop will be executed $4$ times, and the second loop only $1$ time. Then, on the next iteration of the outer loop, the first inner loop will only run $3$ times, while the second loop now runs $2$ times. Each time, the sum of the iterations will be $5$, so our lines will always be the same length.\nWhen we run the code, we’ll get this output:\n* * * * * * * * * * * * * * * Example 3 Up to this point, we’ve just been writing loops to print shapes using ASCII art. While that may seem trivial, understanding the “shape” that will be produced by a given set of nested loops can really help us understand how the code itself will function with other data.\nConsider this example code:\ndef main(): sum = 0 count = 0 for i in range(10): for j in range(i + 1): sum = sum + (i * j) count += 1 print(\"sum: {}, count: {}\".format(sum, count)) main() Before we even try to run this code, can we guess what the final value of the count variable will be? Put another way, can we determine how many times we’ll execute the code in the innermost loop, which will help us understand how long it will take for this program to run?\nLet’s compare this code to the first example shown above:\ndef main(): for i in range(5): for j in range(i + 1): print(\"* \", end=\"\") print(\"\") main() Notice how the code structure is very similar? The outermost loop runs a given number of times, and then the inner loop’s iterations are determined by the value of the outer loop’s iterator variable. Since we know that the first example produces a triangle, we can guess that the program above runs in a similar way. So, the first iteration of the outer loop will run the inner loop once, then twice on the second iteration, and so on, all the way up to $10$ iterations. If we sum up all the numbers from $1$ to $10$, we get $55$.\nNow let’s run that code and see if we are correct:\nAs this example shows, we can use our basic understanding of various looping structures to help us understand more complex programs, and even predict their output without running or tracing the program. This is a very useful skill to learn when working with nested loops.\n",
    "description": "",
    "tags": null,
    "title": "Nested For Loops",
    "uri": "/x-cis115-labs/12-nested-loops/02-nested-for-loops/"
  },
  {
    "content": " Resources Slides In the previous example, we saw a set of linear if statements to represent a Rock Paper Scissors game. As we discussed on that page, the Boolean expressions are meant to be mutually exclusive, meaning that only one of the Boolean expressions will be true no matter what input the user provides.\nWhen we have mutually exclusive Boolean expressions like this, we can instead use if-else statements to make the mutually exclusive structure of the program clearer to the user. Let’s see how we can do that.\nChaining Conditional Statements To chain conditional statements, we can simply place the next conditional statement on the False branch of the first statement. This means that, if the first Boolean expression is True, we’ll execute the True branch, and then jump to the end of the entire statement. If it is False, then we’ll go to the False branch and try the next conditional statement. Here’s what this would look like in a flowchart:\nThis flowchart is indeed very similar to the previous one, but with one major change. Now, if any one of the Boolean expressions evaluates to True, that branch will be executed and then the control flow will immediately drop all the way to the end of the program, without ever testing any of the other Boolean expressions. This means that, overall, this program will be a bit more efficient than the one with linear conditional statements, because on average it will only have to try half of them before the program ends.\nNow let’s take a look at what this program would look like in Python:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") else: if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") else: if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") else: if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") else: if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") and not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") main() As we can see, this program is basically the same code as the previous program, but with the addition of a number of else keywords to place each subsequent conditional statement into the False branch of the previous one. In addition, since Python requires us to add a level of indentation for each conditional statement, we see that this program very quickly becomes difficult to read. In fact, the last Boolean expression is so long that it doesn’t even fit well on the screen!\nWe can make a similar change to the other example on the previous page:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if (p1 == \"rock\" and p2 == \"rock\") or (p1 == \"paper\" and p2 == \"paper\") or (p1 == \"scissors\" and p2 == \"scissors\"): print(\"tie\") else: if (p1 == \"rock\" and p2 == \"paper\") or (p1 == \"paper\" and p2 == \"scissors\") or (p1 == \"scissors\" and p2 == \"rock\"): print(\"player 2 wins\") else: if (p1 == \"rock\" and p2 == \"scissors\") or (p1 == \"paper\" and p2 == \"rock\") or (p1 == \"scissors\" and p2 == \"paper\"): print(\"player 1 wins\") else: if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") and not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") main() Again, this results in very long lines of code, but it still makes it easy to see that the program is built in the style of mutual exclusion, and only one of the True branches will be executed. As before, feel free to run these programs directly in Python or using Python Tutor to confirm they work and that you understand how they work before continuing.\nThe Final Case Now that we’ve built a program structure that enforces mutual exclusion, we’ll might notice something really interesting - the final if statement is no longer required! This is because we’ve already exhausted all other possible situations, so the only possible case is the last one. In that case, we can remove that entire statement and just replace it with the code from the True branch. Here’s what that would look like in Python:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") else: if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") else: if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") else: if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") else: if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: # All other options have been checked print(\"error\") main() In this code, there is a comment showing where the previous if statement was placed, and now it simply prints an error. Again, this is possible because we’ve tried every possible valid combination of inputs in the previous Boolean expressions, so all that is left is invalid input. Try it yourself! See if you can come up with any valid input that isn’t already handled by the Boolean expressions - there shouldn’t be any of them.\nElif Keyword To help build programs that include chaining conditional statements, Python includes a special keyword elif for this exact situation. The elif keyword is a shortened version of else if, and it means to replace the situation where an if statement is directly placed inside of an else branch. So, when we are chaining conditional statements, we can now do so without adding additional levels of indentation.\nHere’s what the previous example looks like when we use the elif keyword in Python:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") elif p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") elif p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") elif p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") elif p1 == \"paper\" and p2 == \"paper\": print(\"tie\") elif p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") elif p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") elif p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") elif p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: # All other options have been checked print(\"error\") main() There we go! That’s much easier to read, and in fact it is much closer to the examples of linear conditionals on the previous page. This is the exact same program as before, but now it is super clear that we are dealing with a mutually exclusive set of Boolean expressions. And, we can still have a single else branch at the very end that will be executed if none of the Boolean expressions evaluates to True.\nA structure of mutually exclusive statements like this is very commonly used in programming, and Python makes it very simple to build using the elif keyword.\nnote-1 Using chained conditional statements like this makes it easy to detect and handle errors in the final else block, since all other options have already been checked. However, some programmers prefer to explicitly check for errors in the input at the start of the code, before any other work is done. This is especially common when working with loops to prompt the user for new input in case of an error, which we’ll learn about in a later lab.\nWhen you are reading code, it is important to check both the start and end of a block of code when looking for possible error checks, since they could be included in either place. Recognizing common coding styles and conventions such as where to check for errors will help us better understand code written by others, and also make our code more readable by others.\n",
    "description": "",
    "tags": null,
    "title": "Chaining Conditionals",
    "uri": "/x-cis115-labs/9-nested-conditionals/02-chaining/"
  },
  {
    "content": " Resources Slides Another type of loop that is commonly used in programming is the for loop. Instead of a while loop, which only uses a Boolean expression to determine if a loop repeats, a for loop is typically used to iterate a defined number of times, either by counting up or by iterating across a data structure such as a list. We’ll learn more about how to use for loops with lists later in this course.\nIn pseudocode, a for loop is used to iterate a specific number of times. The basic syntax for a for loop is shown here:\nREPEAT \u003cn\u003e TIMES { \u003cblock of statements\u003e } In this example, the placeholder \u003cn\u003e is used to represent a number, typically a positive integer, that gives the number of times the loop should be executed. Then, we will execute the statements in the \u003cblock of statements\u003e the given number of times. Put another way, we can say that this loop will execute the \u003cblock of statements\u003e for n times - this is why we call this a for loop.\nCode Tracing Example Let’s look at a quick example program to see how a for loop works in practice. Consider the following pseudocode program:\nPROCEDURE main() { DISPLAY(\"Enter a number: \") x \u003c- NUMBER(INPUT()) DISPLAY(\"Enter a number: \") y \u003c- NUMBER(INPUT()) z \u003c- 1 REPEAT y TIMES { z \u003c z * x } DISPLAY(x \" to the power of \" y \" = \" z) } main() Just like before, take a minute to read this program and see if you can determine how it works before continuing to the description below.\nOnce again, we’ll begin by setting up or code tracing structure as shown here:\nFirst, we’ll find the main() procedure, and record it in the list of procedures.\nThen, we’ll encounter a call to the main() procedure, so we’ll move our execution to the first line of code inside of that procedure.\nHere, the first two lines will prompt the user to input a number, and then that number will be stored in the variable x. For this example, let’s assume the user inputs the string \"5\", so the number $5$ will be stored in the variable x.\nLikewise, we’ll do the same for the variable y. So, let’s assume the user inputs \"3\", which will store the number $3$ in the variable y.\nThe program will also initialize the variable z by storing the number $1$ in it.\nAt this point, we’ve reached the for loop in our code. When we evaluate a for loop, we need to keep track of how many iterations are left. So, the easiest way to do that is to create a new hidden variable that is initially set to the value given for how many times to repeat the loop, and then we can count down using that variable. So, in our list of variables, we’ll create a new variable i to keep track of the loop. It should initially store the same value that is stored in y, so we’ll store $3$ in i.\nNow we are ready to see if we should enter the loop. Since i is greater than $0$, we know that we have at least one loop iteration to go. Therefore, we’ll enter the loop.\nInside the loop, we’ll update the value stored in z by multiplying it by x. So, z will now store the value $5$.\nNow we’ve reached the end of the loop. At this point, we’ve completed a full iteration of the loop, so we can subtract $1$ from the hidden loop counter variable i. This is called decrementing a variable. Once we’ve done that, we can loop back up to the beginning of the loop itself.\nHere, we once again must check to see if we should enter the loop. Since our loop counter variable i is greater than $0$, we know that we can enter the loop again.\nInside the loop, we’ll once again update the value in z by multiplying it by x. So, z now stores $25$.\nThen, we’ll reach the end of the loop, so we must decrement the value in i and jump back to the top of the loop.\nSince i is still greater than $0$, we’ll enter the loop once again.\nWe’ll multiply the value in z by x, which means z will now be storing $125$.\nAt the end of the loop, we’ll decrement i again and return back to the top of the loop.\nAt this point, we see that i is now equal to $0$. This means that we’ve executed the loop the correct number of times, we can now jump to the code after the loop.\nFinally, at the end of the program, we’ll print the result of our calculation.\nNow that we’ve reached the end of the main() procedure, we’ll return back to where it was called from. Since that is the end of the code, the program stops executing. A full animation of this program can be seen here.\nAs we were able to show through code tracing, this program will compute the result of taking the first input to the power of the second input. Since the power operation is simply repeatedly performing multiplication a set number of times, it is easily done through the use of a for loop.\n",
    "description": "",
    "tags": null,
    "title": "For Loops",
    "uri": "/x-cis115-labs/10-pseudocode-loops/02-for-loops/"
  },
  {
    "content": " Resources Slides Python also includes a second type of loop that is very useful, the for loop. Just like in pseudocode, a for loop is used when we want to repeat the steps a certain number of times. However, in Python, we can’t just say that we want to repeat something $10$ times. Instead, we use the built-in range() function in Python to generate a list of numbers that we use in our loop. Then, our for loop will repeat once for each number in the list, and we can even access that number using an iterator variable\nnote-1 We’ll learn more about lists in Python in a later lab. For now, we’re just going to use the range() function to generate them for use with for loops.\nRange Function The range() function can be used in three different ways, depending on the number of arguments given when calling the function:\nrange(stop) - with a single argument, the range() function will generate a list of numbers that begins at $0$ and stops before it reaches the stop value. For example, range(10) will generate a list of numbers from $0$ through $9$. This is great, since there will be $10$ numbers in total, so a for loop using range(10) will repeat $10$ times. range(start, stop) - with two arguments, the range() function will generate a list of numbers that begins at start and stops before it reaches the stop value. So, range(3,8) will generate the list [3, 4, 5, 6, 7]. There will be stop - start numbers in the range. range(start, stop, step) - with three arguments, the range() function will generate a list of numbers that begins at start, increases by step each time, and stops before the stop value. Therefore, range(0, 10, 2) will generate the list [0, 2, 4, 6, 8]. We can also use a negative value for step to count backwards. So, range(5, 0, -1) will generate the list [5, 4, 3, 2, 1]. You can read more about the Python range() function in the Python Documentation\nFor Loops The general structure of a for loop in Python is shown here:\nfor \u003citerator variable\u003e in \u003clist\u003e: \u003cblock of statements\u003e The first time we reach a for loop, we’ll keep track of the \u003clist\u003e that we’ll be iterating over. In general, once you start repeating in a for loop, the \u003clist\u003e cannot be changed.\nIf the list contains at least one item, then we’ll store the first item in the list in the \u003citerator variable\u003e and enter the for loop to execute the code in the \u003cblock of statements\u003e When we reach the end of the block, we’ll jump back to the top and check to see if the \u003clist\u003e contains another item. If so, we’ll store that item in the \u003citerator variable\u003e and execute the code in the \u003cblock of statements\u003e again.\nThis process will repeat until we’ve used every item in the \u003clist\u003e. Then, we’ll jump to the end of the for loop and continue the program from there.\nCode Tracing Example To really see how a for loop works in Python, let’s use Python Tutor to trace through a quick sample program. Consider this Python program:\ndef main(): x = int(input(\"Enter a number: \")) line = \"\" for i in range(x): line = line + \"*\" print(line) main() Before working through the code in Python Tutor, see if you can determine what this program does just by reading it!\nTo step through the code, we can load it into Python Tutor by placing it in the tutor.py file in the python folder on Codio, or clicking this Python Tutor link.\nWe’ll start with the usual default state as shown here:\nThe next two steps will find the main() function in the code and store it in the global frame, and then it will find the main() function call at the bottom of the file. So, once it enters the main() function, we should be at this state:\nThe next line will read the input from the user. For this example, let’s assume the user inputs the string \"5\":\nThis means that we’ll store the number $5$ in the variable x. The program will also create an empty string value in the line variable, which we’ll use to generate output. At that point, we should have reached the beginning of the for loop.\nBehind the scenes, Python will generate a list of numbers based on the range() function. Since the range() function is called with a single argument, we know it will be a list of numbers starting at $0$ and ending before it reaches the value in x, which is $5$. So, the list will contain the numbers [0, 1, 2, 3, 4], and it will cause the for loop to repeat $5$ times. For the first iteration of the loop, Python will store the first number in the list, $0$, in the iterator variable i. In programming, we typically use the variable name i to represent our iterator variable. So, once the program has entered the loop, we should see this state:\nInside of the loop, the first statement will update the line value by adding an asterisk * to the end of the string. So, after this statement is executed, the line variable will store a string containing a single asterisk.\nThe second statement will print the line variable to the output.\nAt this point, we’ve reached the end of the for loop, so our execution pointer jumps back up to the top of the loop. Then, we check to see if the list we are iterating through contains more values. Again, this list isn’t shown in Python tutor, so we have to mentally keep track, but we can see the current value in i, and we know what the list contains by looking at the range() function. So, we’ll update i to store the value $1$, and repeat the loop once again.\nJust like before, this iteration will add an asterisk to the string in the line variable, and then print that to the output before repeating once again.\nThere are still more items in the list, so we’ll update i to the value $2$ and enter the loop:\nIn the loop, we’ll update line to contain one more asterisk, and then print it before looping back to the top.\nThe list still isn’t empty, so we’ll update i to be $3$ this time:\nAnd then we’ll update line and print it.\nBy now, we should have a pretty good idea of what this loop does. There’s one more item in the list, so we’ll update i to be $4$:\nInside the loop, we’ll add one more asterisk to line and then print it.\nFinally, we’re back at the top of the loop. Since there are no more items left in the list, we can jump to the bottom of the for loop and continue the program from there. In this case, there’s no more code left in the main() function, so it will end and the program will terminate.\nLooking at the output, we see that this program will print a right triangle of asterisks that is x lines tall and x characters wide at the bottom.\nA full execution of this program is shown in this animation.\nAs we can see, working with for loops in Python is a quick and easy way to repeat a block of statements a specific number of times using the range() function.\nConverting to a While Loop It is possible to convert any for loop using the range() function in Python to a while loop. This can be done following a simple three-step pattern:\nSet an initial value for the iterator variable before the loop Update the iterator value at the end of each loop iteration Convert to a while loop and check the ending value of the iterator variable in the Boolean expression Let’s look at the main() function from the example above:\ndef main(): x = int(input(\"Enter a number: \")) line = \"\" for i in range(x): line = line + \"*\" print(line) To convert this for loop into a while loop, we can follow the three steps listed above. First, we must set an initial value for our iterator variable i before the loop. Since the first value stored in i is $0$, we’ll set it to that value.\ndef main(): x = int(input(\"Enter a number: \")) line = \"\" i = 0 for i in range(x): line = line + \"*\" print(line) Next, we need to update the value of the iterator variable at the end of each loop iteration. Since we didn’t provide an argument for the step value in the range() function, we know that i will just be incremented by $1$ each time. So, we’ll add a short line to increment i at the bottom of the loop:\ndef main(): x = int(input(\"Enter a number: \")) line = \"\" i = 0 for i in range(x): line = line + \"*\" print(line) i = i + 1 Finally, we can switch the for loop to a while loop. In the Boolean expression, we want to repeat the loop while the iterator variable i has not reached the maximum value. So, we’ll use the Boolean expression i \u003c x in the new while loop:\ndef main(): x = int(input(\"Enter a number: \")) line = \"\" i = 0 while i \u003c x: line = line + \"*\" print(line) i = i + 1 There we go! That’s the basic process for converting any for loop using range() in Python to be a while loop. It’s a useful pattern to know and recognize when it is used in code.\n",
    "description": "",
    "tags": null,
    "title": "For Loops",
    "uri": "/x-cis115-labs/11-python-loops/02-for-loops/"
  },
  {
    "content": " Resources Slides Another important type of conditional statement is the if-else statement. In an if-else statement, we can run either one piece of code if the Boolean expression evaluates to true, or another piece of code if it evaluates to false. It will always choose one option or the other, based on the value in the Boolean expression.\nThe general structure of an if-else statement in pseudocode is shown here:\nIF(\u003cboolean expression\u003e) { \u003cblock of statements 1\u003e } ELSE { \u003cblock of statements 2\u003e } In this structure, the \u003cboolean expression\u003e is any expression that results in a Boolean value. Typically, we use Boolean comparators and operators to construct the statement, along with any variables that are needed. In an if-else statement, unlike an if statement, we see two blocks of statements. The first block of statements, labeled \u003cblock of statements 1\u003e, will only be executed if the \u003cboolean expression\u003e evaluates to true. Similarly, the second block of statements, labeled \u003cblock of statements 2\u003e, will only be executed if the \u003cboolean expression\u003e evaluates to false. So, our program is effectively choosing between one block of statements or the other, based on the value in the Boolean expression.\nTo see how an if-else statement works, let’s go through a couple of code traces in an example program.\nCode Tracing Example - True For this example, consider the following program in pseudocode:\nPROCEDURE main() { DISPLAY(\"Enter a number: \") x \u003c- NUMBER(INPUT()) IF(x MOD 2 = 0) { DISPLAY(\"Your number is even!\\n\") } ELSE { DISPLAY(\"Your number is odd!\\n\") } DISPLAY(\"Thanks for playing!\\n\") } main() This program will accept input from the user, and then determine if the user has input an even or odd number using the modulo operator. Let’s run trace through this program a couple of times to see how an if-else statement works in pseudocode. As always, we’ll start our code trace as shown below:\nJust like always, our “mental model” of a computer will first skim through the code to find all of the procedures, and then it will reach the call to the main() procedure at the bottom of the code as shown here:\nSo, we’ll jump inside the main() procedure, and start running the code that is present there:\nThis first line will simply print a prompt for input to the user, so we’ll add that to the output and move to the next line as shown below:\nOn this line, we’ll read input from the user, convert it to a number, and store it in the variable named x. In this example, let’s assume the user inputs the string \"16\". In that case, we’ll store the number value $16$ in the variable x as shown in this code trace:\nAt this point, we’ve reached the first part of our if-else statement. So, the first step is to evaluate the Boolean expression in parentheses and determine if it is either true or false. In this case, our expression is x MOD 2 = 0, so we need to start by evaluating x MOD 2. Recall that the modulo operation will find the remainder of dividing the first number by the second number. Since $2$ goes evenly into $16$ exactly $8$ times, with no remainder, we’ll get the value $0$. So, this expression is really the Boolean expression 0 = 0, which is true:\nSince the Boolean expression is true, then our program will move to the first block of statements inside the if-else statement, and start executing that code:\nThis line will print a message to the user that the number provided as input was even, so we’ll display that in our output:\nAt this point, we’ve reached the end of that block of statements, so we need to figure out where to go next. Since this is an if-else statement, and the Boolean expression was true, that means we can just skip the second block of statements and go straight down to the first line of code after the if-else statement, as shown here:\nThis line will print our goodbye message to the user, so we’ll show that in our output and move to the end of the main() procedure:\nThis is the end of that execution of our program. The entire process is shown in the animation below:\nCode Tracing Example - False Once again, let’s go back a few steps in the program to the point where it is expecting user input:\nThis time, let’s say the user chooses to input the string \"13\" instead. So, we’ll store the number value $13$ in the variable x as shown in this code trace:\nNow we’re back at the start of our if-else statement, but this time when we evaluate the Boolean expression x MOD 2 = 0, we’ll find out that the remainder of dividing $13$ by $2$ is $1$, since $2$ will only go into $13$ a total of $6$ times, for a value of $12$ with $1$ lefover as the remainder. So, since 1 = 0 is is not true, our Boolean expression will evaluate to false:\nIn this case, our if-else statement will jump down to the second block of statements as shown here:\nThis statement will display output to the user showing that the provided value was odd, as we can see here:\nAt this point, we’ve reached the end of that block of statements. So, just like when we reached the end of the first block of statements, we can now jump down to the first line of code after the if-else statement:\nOnce again, this will print our goodbye message to the user:\nWe’ll reach the end of our program here. A full run of this program is shown in the animation below:\nIf-Else Statement Flowchart Another way to visualize an if-else statement is using a flowchart. Consider the following pseudocode:\nx \u003c- NUMBER(INPUT()) IF(x \u003e= 0) { DISPLAY(x) } ELSE { DISPLAY(-1 * x) } DISPLAY(\"Goodbye\") This pseudocode can also be represented as the flowchart shown below:\nOnce again, we start at the top of the flowchart at the circle labeled “START”. From there, we read an input from the user and store it in the variable x. At this point, we reach our if-else statement’s decision node, represented by the diamond. Here, we are using the Boolean expression x \u003e= 0 to determine which branch to follow. So, if the user inputs a positive value, then we’ll follow the path to the right that is labeled “True”, which will simply print the value of x to the screen.\nHowever, if the user inputs a negative value for x, then the Boolean expression will be false and we’ll follow the path to the left labeled “False”. In this branch, we’ll print the value of (-1 * x) to the screen, which simply removes the negative sign from the value in x.\nFinally, after each path, we’ll merge back together to run the last piece of code, which prints the \"Goodbye\" message to the screen.\nNotice that there is no way to print both x and -1 * x in the same execution of this program. If we follow the arrows through the flowchart, we see that we can only follow one branch or the other, and not both. This is an important concept to remember when working with if-else statements! The control flow of the program can only pass through one of the two blocks of statements, but not both.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode If-Else",
    "uri": "/x-cis115-labs/7-conditionals/02-pseudocode-if-else/"
  },
  {
    "content": " Resources Slides There are also many special operators that can be used to perform operations on Boolean values. These operators are used to along with one or more Boolean values in some way to produce a resulting value. Let’s review the three important Boolean operators in pseudocode.\nAND Operator The first Boolean operator we’ll review is the AND operator. This operator is used to determine if both Boolean values are true, and if so the resulting value will also be true. Otherwise, it will be false. This corresponds to the following truth table:\nVariable 1 Variable 2 Result F F F F T F T F F T T T Here’s an example of using the AND operator in pseudocode:\nx \u003c- true y \u003c- true z \u003c- x AND y DISPLAY(z) When this code is executed, the following output should be displayed:\ntrue OR Operator The next Boolean operator to review in pseudocode is the OR operator. This operator will result in a true value if at least one of the input values is true. If both inputs are false, then the result is false. This corresponds to the following truth table:\nVariable 1 Variable 2 Result F F F F T T T F T T T T Here’s an example of using the OR operator in pseudocode:\na \u003c- true b \u003c- false c \u003c- a OR b DISPLAY(c) When this code is executed, the following output should be displayed:\ntrue NOT Operator Finally, the other Boolean operator we’ll learn about is the NOT operator. This operator is only applied to a single Boolean value, and it is used to negate the value. This means that an input value of true will result in false, and vice-versa. This corresponds to the following truth table:\nVariable 1 Result F T T F Here’s an example of using the NOT operator in pseudocode:\nx \u003c- true y \u003c- NOT x DISPLAY(y) Once again, when this code is executed, we’ll see the following output:\nfalse These three operators allow us to perform the basic Boolean logic operations needed to build more complex programs.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Operators",
    "uri": "/x-cis115-labs/6-booleans/02-pseudocode-operators/"
  },
  {
    "content": " Resources Slides Now that we have the ability to store numerical data in variables in pseudocode, we should also learn how to manipulate that data into something new. To do that, let’s learn about operators. An operator in programming is a special symbol that can be used in an expression to manipulate the data in some way. Most operators are binary operators, which means they perform an operation that uses two values as input and produces a single value as output. In fact, in some programming languages, the operators themselves are implemented as procedures in the language!\nAn expression containing a binary operator typically follows this format:\n\u003cexpression\u003e \u003coperator\u003e \u003cexpression\u003e As before, the \u003cexpression\u003e parts can be any valid expression in the language, and the \u003coperator\u003e part is typically a single symbol, but it can also be a short keyword as well.\nThankfully, these operators should all be very familiar to us from mathematics already, so this is just a quick discussion of how they can be used in programming.\nAddition and Subtraction For starters, we can use the plus + and minus - symbols as operators to perform addition and subtraction in pseudocode, just like in math. For example, we can add two variables together to create a third variable as shown in this example:\na \u003c- 5 b \u003c- 7 c \u003c- a + b DISPLAY(c) When we run this code on our “mental model” of a computer, we should get this result:\n12 Likewise, we can subtract two variables using the minus symbol - as shown here:\nx \u003c- 24 y \u003c- 10 z \u003c- x - y DISPLAY(z) This code should produce this output:\n14 Multiplication and Division In pseudocode, we use the asterisk *, sometimes referred to as the star symbol, to multiply two values together. For example, we can find the product of two values as shown in this pseudocode block:\na \u003c- 6 b \u003c- 7 c \u003c- a * b DISPLAY(c) When we run this code, we should see the following result displayed to the user:\n42 Division is performed using the slash / symbol. A great way to think of division in programming is just like a fraction, since it uses the same symbol between the two numbers. For example, if we execute this code:\nx \u003c- 27 y \u003c- 3 z \u003c- x / y DISPLAY(z) we would see this output:\n9 What if the division would result in a remainder? In that case, we’ll simply use decimal values in pseudocode so that the result is exactly correct. For example, if we try to divide $19$ by $5$, as in this example:\na \u003c- 19 b \u003c- 5 c \u003c- a / b DISPLAY(c) Our “mental model” of a computer would produce the following output:\n3.8 So, as we can see, all of these operators in pseudocode work exactly like their counterparts in math. Even though we aren’t running our code on an actual computer, we should be easily able to use a simple calculator to help us perform these operations if needed.\nModulo Operator There is one other operator that is used commonly in pseudocode - the modulo operator. The modulo operator is used to find the remainder of a division operation. If we think back to math again, we’ve probably learned how to perform long division when dividing two values. At the end, we might be left with a remainder, or a portion of the first number that is left over after the operation is complete. In many computer programs, that value is very useful, so we have a special operator we can use to find that value. In pseudocode, we use the keyword MOD as the modulo operator.\nFor example, if we want to find the remainder after dividing $19$ by $5$, we would use the following code:\nx \u003c- 19 y \u003c- 5 z \u003c- x MOD y DISPLAY(z) When we run this code, we would get the following output:\n4 This is because the value $5$ will fit into the value $19$ only $3$ times, and then we’ll have the value $4$ left over. Mathematically, we are saying that $19 / 5 = (3 * 5) + 4$. Since $4$ is the leftover portion, it is the resulting value when we use the modulo operator.\nIn this course, we’ll only worry about how the modulo operator works when applied to positive whole numbers. In practice, it can be applied to any numerical value, including decimal values and negative numbers, but those values are not really useful in most cases. So, to keep things simple, we’ll only use positive whole numbers with this operator.\nOrder of Operations Finally, just like in mathematics, we must also be aware of the order that these operators are applied, especially if they are combined into a single expression. Thankfully, the same rules we learned in mathematics apply in programming as well. Specifically, operators in pseudocode are applied in this order:\nOperations in parentheses are resolved first, moving from left to right. *, / and MOD are resolved second, moving from left to right. + and - are resolved third, moving from left to right. In most cases, it is best to include parentheses whenever we include multiple operators on the same line, just so the intended interpretation is perfectly clear. However, let’s work through a quick example just to see the order of operations in practice.\nHere’s a complex expression in pseudocode that we can try to evaluate:\nx \u003c- 8 / 4 + 5 * (3 + 1) - 7 MOD 4 Looking at our order of operations, the first step is to handle any expressions inside of parentheses. So, we’ll first start with the expression (3 + 1) and evaluate it to 4.\nx \u003c- 8 / 4 + 5 * 4 - 7 MOD 4 Then, we’ll go right to left and perform any multiplication, division, and modulo operations. This means we’ll evaluate 8 / 4, 5 * 4 and 7 MOD 4 and replace them with the resulting values:\nx \u003c- 2 + 20 - 3 Finally, we’ll perform addition and subtraction from left to right. So, we’ll evaluate 2 + 20 first, and then subtract 3 from the result of that operation. At the end, we’ll have this statement:\nx \u003c- 19 So, we were able to use our knowledge of the order of operations to evaluate that complex expression to a single value, $19$, which will be stored in the variable x.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Operators",
    "uri": "/x-cis115-labs/4-math-operators/02-pseudocode-operators/"
  },
  {
    "content": " Resources Slides So far we’ve only looked at operators that can be used on two numeric values, but there are also a few operations we can perform on strings as well. Let’s look at one important operator that is commonly used with strings - the concatenation operator. In pseudocode, like most other programming languages, we’ll use the plus symbol + to represent the concatenation operator.\nThe term concatenate may be a new term, since it isn’t used very often outside of programming. To concatenate two items, we are simply linking two items together, one after the other. When applied to strings, we can use the concatenate operator to combine two strings into a single string.\nLet’s look at an example:\none \u003c- \"Hello\" two \u003c- \"World\" message \u003c- one + \" \" + two DISPLAY(message) In this code, we begin with the strings \"Hello\" and \"World\" stored in two separate variables, one and two. Then, we create a new variable message, which contains the values of one and two concatenated together, with a space in between. Since one and two are strings instead of numbers, we know the + symbol represents the concatenate operation, instead of addition.\nWhen we run this program on our “mental model” of a computer, we should see this output:\nHello World As we can see, the concatenate operator is a way we can build complex strings from various parts.\nConcatenating Numbers Because the concatenate operator works with strings, we have to add a couple of rules to how our pseudocode language handles data types to deal with this. Here are the most important rules to follow:\nIf both sides of the + operator are strings, then the + operator is treated like a concatenation. If both sides are numbers, then it is treated like addition. The + operator cannot be applied to a string and a number. The concatenation operation always returns a string. This may seem a bit confusing to anyone who has experience with programming, since many programming languages allow us to use the + operator between strings and numbers without any issues. However, in this case we’re going to stick closely with what is allowed in Python, so these are the rules we’ll follow in pseudocode.\n",
    "description": "",
    "tags": null,
    "title": "String Concatenation",
    "uri": "/x-cis115-labs/5-input-strings/02-string-concat/"
  },
  {
    "content": " Resources Slides First, let’s start by introducing some important vocabulary terms:\nstring: A string in programming is any text that is stored as a value. We typically represent strings by placing them inside double quotes \"\" in our code and elsewhere. value: A value is a piece of data that our program is storing and manipulating. In our pseudocode, values consist of either numbers or strings. keyword: A keyword is a reserved word in a programming language that defines a particular statement, expression, structure, or other use. As we’ll learn later, we cannot use these keywords as variable or procedure names. statement: A statement refers to a piece of code that performs an action, but doesn’t result in any value. Most complete lines of code are considered statements. expression: An expression, on the other hand, is a piece of code that, when evaluated, will result in a value that can be used or stored. An expression can even contain multiple expressions inside of it! Now that we have learned a few of the important terms used in programming, we can start to discuss the various statements in pseudocode.\nIn our basic pseudocode, the first and most basic statement to learn is the DISPLAY(expression) statement. This statement will evaluate the expression to a single value, and then it will display that value to the user. In our “mental model” of a computer, this means that the value is printed on the user interface somewhere. The word DISPLAY is an example of a keyword in pseudocode, since it has a special meaning as part of the DISPLAY(expression) statement.\nFor example, the simplest program we can write is the classic “Hello World” program, which simply displays the message \"Hello World\" to the user. In pseudocode, that program would look like this:\nDISPLAY(\"Hello World\") Notice that the expression part of the statement contains \"Hello World\" in quotation marks? That is because \"Hello World\" is text, so we should put it in quotes and make it into a string in our code. Also, since the string \"Hello World\" can be treated like a value, we can also say it is an expression, and therefore we can use it in the expression part of the statement. This may seem pretty straightforward now, but as our programs become more complex it is important to think about what pieces of code can be treated as values, expressions, and statements.\nSo, in our “mental model” of a computer, pretend we are using a blank box as our user interface. It might look something like this:\nNow, we can run our “Hello World” program in our “mental model” and see what it does. After we run that program, our user interface will now look like this:\nHello World Awesome! We’ve just run our first imaginary program! If you look at the output, you might notice something strange - the text on our user interface doesn’t include the quotation marks \"\" that the expression \"Hello World\" contained. When we display text to the user, we’ll remove the quotation marks from the beginning and the end of the string, and just display the text inside. Pretty handy!\nEach time we run our program, we’ll assume we are starting with an empty user interface. This makes it easy for us to make sure any programs we’ve previously run on our “mental model” won’t interfere with the output of the current program. So, anytime we run the “Hello World” program, even if we run it multiple times back-to-back, our user interface will always look like this:\nHello World So, now that we have that part down, let’s look at creating some more complex programs using this DISPLAY(expression) statement.\n",
    "description": "",
    "tags": null,
    "title": "Display Statement",
    "uri": "/x-cis115-labs/2-print-variables/02-display-statement/"
  },
  {
    "content": " Resources Slides Up to this point, we’ve simply written code and expected it to run easily in our “mental model” of a computer. However, many programming languages place one additional requirement on code that we should also follow: all code must be part of a procedure.\nWhat does this mean? Put simply, we shouldn’t place any code in our programs that isn’t part of a procedure. Or, put another way, our programs should only consist of procedures and nothing else.\nBut wait! Didn’t we just learn that our “mental model” of a computer will just skip past procedures when it runs our programs, and it will only execute the code inside of a procedure when it is called? How can we call a procedure if all of our code must be within a procedure? It sounds a bit like a “chicken and egg” problem, doesn’t it?\nThankfully, there is a quick and easy way to solve this. Many programming languages define one specific procedure name, usually main, as the defined starting point of a program. In those languages, the computer often handles calling the main procedure directly when a program starts. Other languages don’t define this as a rule, but many developers choose to follow it as a convention. In our pseudocode, we will follow this convention, since this closely aligns with the Python language we’ll learn later in the course.\nCreating a Main Procedure Let’s see an example. We can update the example on the previous page to include a main procedure by simply placing all of the code at the bottom of the program into a procedure. We’ll also include a call to the main procedure at the bottom of the code, as shown below:\nPROCEDURE foo() { DISPLAY(\"Run \") } PROCEDURE bar() { DISPLAY(\"Forrest, \") } PROCEDURE main() { foo() bar() foo() } main() That’s really all there is to it! From there, our “mental model” of a computer will know that it should start executing the program in the main procedure. Let’s quickly code trace the first part of that process, just to see how it works. As before, we’ll start running our program at the top of the code:\nJust like we saw previously, this line is creating a new procedure named foo. So, we’ll make a note of that procedure, and move on to the next part of the code:\nHere, we are creating the bar procedure, so we’ll record it and move on:\nLikewise, we see the creation of the main procedure, so we’ll record it and continue working through the program:\nFinally, we’ve reached the end of the code, and here we see the call for the main procedure. So, just like we saw before, our “mental model” of a computer will determine that it has indeed seen the main procedure, and it will jump to the start of that procedure:\nFrom here, the rest of the program trace is pretty much the same as what we saw before. It will work through the code in the main procedure one line at a time, jumping to each of the other procedures in turn. Once it reaches the end of the main procedure, it will jump back to the bottom of the program where main is called, and make sure that there is nothing else to execute before reaching the end of the program. The full process is shown in the animation below:\nFrom here on out, we’ll follow this convention in our programs. Specifically:\nAll programs must contain a procedure named main as the starting point of the program. All code in a program must be contained within a procedure, with the exception of a single call to the main procedure at the bottom of the program. These conventions will help us write code that is easy to follow and understand. We’ll also be learning good habits now that help us write code in a real programming language, such as Python, in a later lab.\n",
    "description": "",
    "tags": null,
    "title": "Main Procedure",
    "uri": "/x-cis115-labs/3-functions/02-main-procedure/"
  },
  {
    "content": " Resources Slides Video Script I present to you the German Enigma machine. The Enigma machine was used to encode messages during World War Two. And it was a really interesting piece of equipment. It used several different rotors that were rotated to create a key for the encryption, and used a plug board and a keyboard for inputs. And so as we saw in the video with the Enigma machine, you would set the rotors to a particular key. And then when you press the key on the keyboard, and electrical current would go from that key, through the plug board, through the rotors, back out through the rotors, and then light up a lamp above. And so by pressing that key and holding it down, it would show you the letter that that letter should be encrypted to. Then, you would press the next key, another letter would light up, you press another key, another letter would light up. And each time you press a key, the rotors would advance one click changing the way that things were encrypted. And so of course, if you sat there and kept pressing the same key on the keyboard, you would notice that every single time you did that the letters that it would light up would be different every single time making you think that this is a very, very hard to break cipher. And indeed it was.\nSo as we saw, the Enigma machine consists of several rotors. Each rotor has 26 letters engraved around the outside, and it has 26 pins, each pin representing the input for one letter. And so you’d have a pin on one side, a whole scramble of wires on the inside, and then on the outside, you would have another contact that would go out. And so each pin was paired to one contact, but they were shuffled around randomly, so you really didn’t know how it was set up. And so of course, with just three rotors in the Enigma machine, that means there are over 17,000 possible combinations of three character positions of the Enigma machine rotors. So here’s an exploded view of showing the between the rotors where you have the pins on one side, making contact with the contacts on the other side. And so by sending an electrical current through one of the rotors, it would eventually go through the pins and contacts through each rotor until it would come back out the other side. And then of course, like we talked about, the Enigma machine uses a ratcheting system, very similar to an old analog odometer in an old car. Every single time you press a key, the ratcheting system would advance the outermost rotor, one click. And then of course, once that rotor has made a full cycle, it would advance the second rotor, one click, and then once that outside rotor has made 26 cycles, and the inner rotor has made 26 cycles as well, then the first rotor will be incremented one click. And so like it works just like an odometer, it’s very, very interesting the way they set this up.\nBut probably the most interesting fact is the way that the reflector works. So for example, let’s say you press the letter A on your keyboard. Then, it would go through the right rotor, the middle rotor the left rotor, and it would hit this special plate on the other end called a reflector, which would take that input on one pin and it would output it on another pin. Then it would go back through the rotors using a different path, and then it would hit the letter G and light up that light. But this right most rotor would then advance one position. So the next time you press the letter A, you would get an entirely different combination. You would have A which would go through this path, hit the reflector, come out this path, and then it would light up the letter C. So this makes decrypting messages really, really impossible. You never know what letter you’re going to get out based on the inputs unless you really know everything about how the position is set up. Finally, on the front of the Enigma machine, they included what’s called a plug board. And so what the plug board could do is you could swap the positions of two letters using these little wires. So for example, this system is set up to swap the letter S with the letter O and the letter J with the letter A. And so with this plug board, you can have up to 13 swaps, which gives you 10 million different combinations of keys that you might have to worry about. Of course, it’s interesting to note that the swaps are reflexive, so if J gets swapped with A, then A also gets swapped with J, so the same happens for both letters.\nSo all told, you have all sorts of different ways to set the key for the Enigma machine. You have the choice of the rotors and the ordering of the rotors. We saw three rotors, but toward the end of the war, there might have been as many as eight different rotors available that they could use. Then you have the initial position of the rotors. So the initial three letter key that the rotors were set to. You have the ring setting on the rotors, which shows where the rings go on the rotors, that way, it kind of changes the position a little bit more. And then you’d have the plugboard connections on the front, which are swapping different letters around. And so in theory, to understand how an Enigma machine is encrypting data, you would need to know all four of these things for each Enigma machine that you want to try and decrypt. And that’s a lot of information to keep in mind. Now of course, the other thing that they did is they had a specific operational pattern that they use when they were encrypting data using an Enigma machine. So the first thing they would do is they would set the wheels on the Enigma machine to the key from today’s codebook. The Germans carried around these code books that gave the keys for each day. And unfortunately, throughout the entire war, to my knowledge, not a single codebook was lost. In addition to the key settings, there was a particular way that the Enigma machines were operated. To operate an Enigma machine. First, they would set the wheels to the key from today’s codebook, the Germans used a paper codebook that gave different keys for each day of the year. And to my knowledge, those code books were not ever compromised during the war, they would always be burned or destroyed before any German camps were taken over. Secondly, the operator of the Enigma machine would then choose a unique key for the message. So they would choose a different key consisting of three characters for that message. So then they would use the daily key to encode the message key twice to avoid errors. So the first six characters of the message would be the message key encoded twice, then you would set the wheels to the message key, and start en crypting and sending the message. So not only did each day have a different daily key, but then each individual message used its own message key to send the data, so everything was really scrambled.\nSo if we look at this process, how do you think you’d go about cracking an Enigma machine? Take a minute to think about that. So obviously, the Enigma machine had many strengths. There were many different factors to the encryption, as we saw earlier. There were eight different wheels to choose from by the end of the war. And so depending on how you calculate it, there could be as many as 150 trillion different setups just from the plugboard itself. So altogether, it’s estimated there were 158 quintillion possible keys that you could use to decode an Enigma machine.\nHowever, the Enigma machine came with very, very important weaknesses. The first and most important weakness was a letter would never encrypt to itself, because of the way the reflector worked on the plug boards and on the wheels. If you press the key A, you could press that key 26 times, and never once would the light for a light up because they were on the same circuit. And so with the reflector through the wheels, there was no way the current could come back through the circuit that it was sent out, which means that A would never light up for itself. Secondly, of course, the plug boards were reciprocal. And so by swapping two letters, you’re really just adding a substitution cipher on top of a really complex polyalphabetic cipher so the plug boards really didn’t do a whole lot in terms of making the combinations more complex, it just scrambled the letters a little bit. Another big problem they had was the wheels themselves were not similar enough, the wheels were so different, in fact that using some advanced mathematics, you could determine roughly which wheels were being used, just by the way the letters were distributed in the message that you received. And then of course, there were some poor policies and procedures around the Enigma machine. And one of the worst parts was the fact that they allowed message operators to choose the key. If your message operator in a foxhole during a war, and you’re asked to come up with three random letters all the time, every time you want to send a message, are those letters going to be truly random? Or are you more likely to pick some letters that have specific meaning to you like the initials of your loved one back home or your hometown, and they actually found out that that was a problem. A lot of German message operators were not picking truly random letters for the message keys. And then of course, they were encoding those same letters twice at the beginning of the message. So if you could decrypt the first three letters of the message, you had the message key that you could then use to decrypt the rest of the code. So that was not really that useful. So now let’s take a look at a second part of this video about how to decrypt a message that’s encoded with Enigma machine.\n",
    "description": "",
    "tags": null,
    "title": "Enigma Machine",
    "uri": "/iii-topics/16-cryptography/04-enigma/"
  },
  {
    "content": " Google Trends\n",
    "description": "",
    "tags": null,
    "title": "Google Trends",
    "uri": "/iii-topics/20-big-data/04-google-trends/"
  },
  {
    "content": " Resources Slides Video Script But let’s continue our talk here a little bit more about intelligent behavior and what that means with human behavior as well, and when we’re trying to actually make AI that seems human. And so one of the problems with AI is that it forces the computer to mimic all human behavior, not just intelligence. And so when we start to create an AI for it to truly be human like, right, it has to do all of our own behavior. And so things like slow response times, typos, commonly miss-held conceptions that aren’t true, connecting words like I’m doing right now. All of these things are human behavior that may not be considered intelligent, or clean, or you know “perfect”, but it’s something that a successful AI agent must be able to do in order to pass what we call the Turing test. And we’ll talk about that here in a second. But likewise, an AI must also act, sometimes really, as if it can’t solve some problems that are perfectly well within its abilities to actually be able to solve, but simply because those problems are unsolvable by human intelligence or unsolvable in the amount of time it could take the AI or computer to actually solve. So if you’re trying to make an AI that is trained to behave and act like a human, it needs to do as humans do, and it can’t be perfect.\nSo that is where Alan Turing comes into play. And we’ve already talked about Alan Turing to some degree, especially with the bomb and his work with the Enigma machine, as well as the Turing machine. But he also wrote in a paper, “I propose to consider the question can machines think?” This is a quote from a 1950 paper that he wrote, called Computing Machinery and Intelligence, which he opened with that statement and tried to open up some discussion, right? He was deeply interested in the field of artificial intelligence, but unfortunately, there really was no good way to determine if a system was truly intelligent at the time. And so in that paper, he describes one way to test machines intelligence, which is now known as the Turing test. The basic idea of a Turing test is as follows. You have one person in a room with a computer capable of simple text-based chat, so they’re sitting on a terminal at a computer, and they’re trying to talk in this chat room or to someone else, and that someone else will be a computer or could be a computer that will try to pass itself off as a human by responding to the prompts from the tester. The tester then must determine whether or not he or she is conversing with a computer or a real person. And now there really hasn’t been someone who has truly passed the Turing test completely with flying colors. And the Turing test as a whole is biased, and there’s some problems with it. And so it’s not perfect either. There have been some algorithms that have passed the Turing test to a certain degree, but there are some problems here.\nSo can you think of any of those problems that a Turing test may actually have? Some of those problems are actually exhibited from a variant of the Turing test called the Chinese room. So the Chinese room experiment was proposed by John Seely in 1980, in his paper, “Minds, Brains and Programs”. In this setup, an English speaking person is placed in a room with sufficient supplies and a set of instructions completely written in English, that directs them to accept Chinese language characters as input and output a result or response of Chinese characters. On the other side of the wall as a native Chinese speaker, performing what we refer to as a Turing test. And in this case, the person is convinced that the person on the other side of the wall is indeed a human. However, the computer being a human that only speaks English is completely unaware of the conversation that is taking place in Chinese. So in this case, is the machine, right or the person intelligent, or merely just so advanced at following instructions that it appears to be intelligent? So this is a trick right? Are we just good at giving the computer instructions to mimic human behavior or is it just someone who’s good at following instructions? Now, following instructions, there’s some intelligent behavior involved with that, although not a whole lot, but it’s not exhibiting the full intelligent range, right? So there’s some of the fundamental issues with the Turing test and things like that of trying to truly quantify whether or not an AI is a human or not. But this leads to an endless debate right between strong AI and weak AI.\nWhen you think of an AI in movies, this is usually or typically a strong AI, which is designed to completely mimic or surpass human intelligence. Now, this is most movies, right? And most movies that you watch, they’re going to be AI that can converse perfectly in English and answer all questions, and even look up things that instantaneously that at the moment no machine is actually possible. Iron Man is a perfect example with his AI Jarvis or Friday later on and some of the later movies. And so unfortunately, really at this time, strong AI is just not a reality. And there’s even some debate of whether or not it’s actually possible. Most of the AI that we deal with today is in the form of a weak AI. This is also called narrow AI, which is designed to perform only a subset of intelligent actions. Now, just because something is a weak AI doesn’t mean that it’s not possible of good quality intelligent actions. A lot of times weak AI is extremely good at one particular kind of behavior, but not so great at others.\n",
    "description": "",
    "tags": null,
    "title": "Machine Intelligence",
    "uri": "/iii-topics/18-ai/04-machine-intelligence/"
  },
  {
    "content": " Resources Slides Video Script Welcome back. In this video, we’re going to be taking a deeper look into what kind of queries we can actually ask of Google or searching the web. So we’ve already looked at simple queries like cat, dog, or cat and dog, or cat or dog. But that’s really not as interesting of a question to ask of the internet, right? When we’re wanting to find all of the webpages that are about cats, not just have the occurrences of the word cat, but are about cats. And so how do you know which web pages are more likely to be about cats and webpages that are more likely to be about dogs? And how could you tell the difference? And how would you modify our search algorithm that we had talked about earlier to account for that. So this ranking of the internet becomes a little bit more complicated than our simple straight up text queries.\nBut as we learned in the HTML lectures, pages in the world wide web have structure to them in the form of HTML tags. And so we could add more information about those tags called metawords to our indexing algorithm. And so now we could could re query the index to find specific words in. for example, the title. So in theory, right at a very simple explanation is a article that contained the word cat in the title is probably more likely to be about cats than it is dogs, even though dog was found on that webpage somewhere in the text. But again, this is a very simple approach, right? The metawords help our algorithm, help our searching, but it’s not going to be a pure ranking system, right? Because basing our questions and answers off of just the text, and these tags won’t yield very efficient results. And it won’t yield a very good collection or a very good curated, top 10 list of dogs? And how do we rank them in priority from our search? Because obviously, there’s a lot of cats and dogs on the internet. So how does one webpage about cats come first, early web search engines dealt with. So as the web got larger and larger, it was more and more difficult to find good pages in all of the bad or useless ones.\nOne of the early search engines was actually called AltaVista, it grew very quickly at first. So in 1996, it had five servers, 210 gigs of search engine that was constantly indexing the web, late 90s. So having 500 gigs of storage, and 130 gigs of RAM was big, right? This was a huge, huge set of servers, and very powerful machine in order to index web. And it was able to handle 13 million queries daily. So considering this the late 90s, Internet was still relatively new, but this was also getting very close to the .com era. But as we mature into the .com era, Alta Vista was eclipsed by another. So Yahoo, came in and bought them out in 2003, and then eventually shut them down in 2011. But Alta Vista was one of the first major successful search engines that we had for the internet.\nWe’ll transition into technology that was developed and published in a paper called the Anatomy of a Large-Scale Hypertextual Web Search Engine that provided the answer to our question of how do we rank the internet. They created a new algorithm called PageRank, named after Page himself, that could rank search engine results based off of their authority of the page that was actually found But let’s see how this actually works.\nSo, as you know, the worldwide web is interconnected ith hyperlinks. So if we had two hypothetical web pages here, Ernie’s scrambled egg recipe and Bert’s scrambled egg recipe. And we could analyze those links that are going o and from that page to learn more about it. With our previous indexing algorithm, if we found eggs on both of these pages, so they’re technically about eggs, but which one should come first. Should Ernie’s come first in our search results, or Bert’s? Which one of these do you think would be the top result for a scrambled egg recipe and why? So in theory, right, Ernie’s scrambled recipe, even if it is better than Bert’s, Ernie s recipe only has one other web page that links to it. So this could be a comment, it could be another blogger, whatever it may be, maybe a Facebook post. But there’s only one person that has a link to that webpage. But Bert’s recipe is obviously more popular, or at least more well known, because it has three pages that link to it. So according to the page rank, here, Bert’s recipe has more authority about scrambled eggs, then Ernie as on scrambled eggs. So Bert’s would come first in our search result and Ernie’s would come next, if these were only two web pages about scrambled eggs. But unfortunately, the World Wide Web is not as nicely structured as we like. So it is highly dependent on the actual websites themselves and other things that become a lot more difficult to actually search through.\nBut what about this particular example, which page would be ranked higher? Well, we still have Ernie’s and Bert’s scrambled egg recipe, we have John and Alice here. John’s web page points to Ernie’s and Alice’s points to Bert’s. Ernie’s recipe only tried it once it’s not too bad. Alice is clearly a lot more excited about Bert’s recipe. Bert’s recipe is clearly one of the best recipes. So if we are just basing this off of the text, Alice has more authority or would have more authority than John, if we’re looking at the sentiment or the excitement here. But this becomes a problem if we’re just looking at links, though. Right? One link here, one link here. Which one comes first? How do we break that tie? Well, let’s take a look at it as far as the authority of the pages that actually link to it. So John and Alice both have a link to Ernie and Bert’s scrambled egg recipe.\nSo that’s one and one for both Ernie and Bert. But John is a new blogger; John doesn’t have very many followers so John does not have very much authority. So John has only two links pointing to his web page. But Alice is a really popular blogger. And so she has a lot of different pages, maybe she has 100 different pages that are pointing to that page. And so Alice ends up having more authority. And since Alice has more authority, a link from Alice to Bert’s scrambled egg recipe has far more weight than John linking to Ernie’s scrambled egg recipe. And so in that sense, Bert’s recipe would still come first in our page ranking algorithm over Ernie’s scrambled egg recipe because Alice has more weight, more importance, more authority than John’s page, even though Ernie and Bert have the same number of links to their websites.\nBut sadly, again, right the internet is not a nice tree structure like that either. Sometimes it’s full of these cyclic connections like this. So if we follow for example, A to B to E to A to B, E A to B to E, we get stuck in these cycles. And these cycles are what we call syncs. Okay, so they suck up all of the authority of the internet. Because our algorithm gets stuck So if our indexer is just sitting there out there on the eb following links, it’ll just et stuck in this cycle. It’ll follow that link over that cycle over and over and over and ver and over and over again. And so all of the authority gets consumed by that cycle. So we can’t just simply follow links on the web because we’ll get stuck in those an all other web pages will have no authority whatsoever.\nSo one of the ways that actually Page and Brin suggested is called this random surfer model. So imagining that you are simulating the random surfer, you’re going to start on some web page, totally at random on the internet, and then just start clicking on random links. And you’ll continue on that pattern until at some random point in the future, you teleport to a new page and start surfing again. So start on a page, start clicking links on that web page, and then, and then you’ll eventually get ported off into another web page. And then you’ll start this process over again. And so instead of just selecting each link, in a specific order on a web page, you’re going to randomly select links to actually follow, this will cause you to break out of those cycles. And if you do this enough time, keeping track of the percentage of visits that you made onto a particular web page, you can use those values as the rank of the page. So the randomness here, the more links that you have to a page, theoretically speaking, you are more likely to be randomly surfed to others.\nSo let’s take a look at a example of the random surfer w th PageRank. So here is our sample web that we’re actually crawling here. So we have site A goes to home has an about page, product page, and more on the product page, links to another we site. So site A has these four pages, and then the product page on site a links to site B. Now, let’s say we are just rolling a set of dice, and each of these web pages has a link and that die, the probability the number on that die will would have you either follow that link, or stay on that webpage, right. If multiple links on were, the number that was rolled on the die, depends on which link you actually follow. If you keep on randomly rolling the die, and following links here, which page actually has more authority in this particular example? So if we kept on doing our random page search, so let’s see, if we started at S te A, and we went to home, we could have, we have three different options here. So three outgoing links, and three incoming links. And same thing for about has one, two, three outgoing and three incoming, and so does the more web page. So it has three outgoing and three incoming.\nA couple differences here: home has four incoming links, and product has four outgoing links. And so if we keep on randomly rolling our dice here, this is what the authority would actually look like. So if we went long enough, the about and more page would be identical in authority because due to probability, they’re equally as probable to be visited as the other because they bo h have three outgoing links, and three incoming links. The product page has a little bit more authority than the about and more page because there are three or four outgoing links, and only three incoming links. So they have a few extra inks on here that it can actually follow even though it causes the product page to go to site B. Site B only has one possible way of actually being visited, and so that has the smallest authority. But the homepage has the highest authority among all of the pages on site a because it has four incoming links and three outgoing links. So probability wise, it is more likely to be visited than all of the other pages here. And that’s the idea of the random surfer model, even though we have a cycle here. So from home, the more the product about home more product about. Even though we have cycles, the random surfer model is going to narrow down that cycle regardless of the cycle and narrow down which web page is actually more likely to be visited based off of the links that actually finds.\nAnother way you can do this is by simply generating all possible paths that can be found on the internet. And you can calculate the length of those paths and the percentage of the times that those particular pages show up in those paths. So if we calculate all the different paths that we can actually find here that are less than five, so five sites deep, we actually find that site a occurs more frequently in those past than all others. So this is a little bit different than the random surfer model. So this is a little bit more discreet, meaning that we have a little bit more of an order to things instead of everything being completely random. It does help solve the random surfer model, although we do have to limit the length of our path. So there is some downsides to this technique.\nBut of course, there’s a lot of different problems out there that could get in our way of actually searching data, right? Instead of just those cycles, right? We have a lot of other issues like spam. How do we take into account our all those ads that are on the internet that are just basically plugging the internet, although that’s, you know, how a lot of people make their money online. But how do you avoid spam? How do you avoid ads that you don’t want to search? How do you avoid malicious websites? You don’t want a malicious website to be the number one hit on Google. How do you take into account the size of the internet and reduce computation time? How do you search non textual information? Right? We have a lot of images and videos on the internet now. And audio, how do you take that into account? Structured versus unstructured data and a lot of lots of different other things. And that brings us really into the difference between what we had with web 1.0 to web 2.0. This has a such a major impact on how the world wide web works. And so after the .com bubble burst, no one really knew where the internet was headed. And a lot of different talks were being had about what the internet could be, or what it could be different, right?\nBecause at the time, the internet was a place where companies just push content to their users. But now the internet is a place where users can communicate and share their own content quickly and easily. And eventually, that led to this idea of web 2.0, which we’ve talked about before. But the reason that we bring this back up is that the web is a dynamic place now or the web is a more complicated place now. We have web 1.0. We had static web pages that didn’t change very often. And so that led to search algorithms that were significant easier to do because we were dependent mostly on text. And now we have dynamic web pages where the web page that I visit is entirely different than the webpage you visit even if it’s the same URL, because it depends on who’s logged in. It depends on your browsing history. Now we’re also looking at user generated content. So if you look at a Reddit post, right, Reddit trying to search Reddit, how does that show up in Google? Because new Reddit posts are made every single second. So how do you take that into account? How do you take into account multimedia pages, so things like YouTube videos, audio, songs, images, pictures of cats versus pictures of dogs when you’re trying to search that versus text. And this is an entirely different web that we live in now versus what we had in the 90s when early search engines were about. And so this is something that is going to be a continuous problem as we kind of move forward and as the web grows, but it’s just kind of highlighting the importance of this sophistication of the search engines that we are currently able to use.\n",
    "description": "",
    "tags": null,
    "title": "Ranking",
    "uri": "/iii-topics/19-search-info/04-ranking/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "What Is The Uncanny Valley? | Mashable Explains",
    "uri": "/iii-topics/22-graphics-and-video-games/04-uncanny-valley/"
  },
  {
    "content": "Lab 2 Printing and Variables ",
    "description": "",
    "tags": null,
    "title": "Printing and Variables",
    "uri": "/x-cis115-labs/2-print-variables/"
  },
  {
    "content": " warning-1 The C2 total on the slide at 0:54 - 2:10 is incorrect. The total is 7336 but that value modulo 255 is 196, not 96 as shown in the video.\nResources Slides Video Script Let’s look at an even better way to do a checksum to check and see if our data is correct. This is called Fletcher’s checksum. And here we’re giving a quick pseudocode of the algorithm that is used to generate Fletcher’s checksum. Basically, the way it works is you divide the word into a sequence of equally sized blocks. And we’ll just use the individual characters for this. And we’ll start with two checksums, one of them, C1 starts at zero, the other to also starts at zero, then for every block, we’ll add the value of the block to the first check sum. And then we’ll add the new value of that checksum to the second checksum. And then finally, while we’re done, we will calculate the values of the checksum mod 255 to reduce them to an eight bit binary value. And we’ll return those two checksums.\nSo let’s take a look at an example of how we would do Fletcher’s checksum. We’ll start with our same messages always and divided into blocks where each character is its own block. So the first character, the capital H is a value 72. So we’ll add 72 to the first checksum. And then we will add that checksum value to the second checks up. So after the first character, they’re both the same. The second character, the lowercase E is 101. So we’ll add 101 to the first checksum to get 173. But now we will add this new checksum 173 to the value of 72 and the second checksum to get 245. Likewise, we’ll add 108 to 173 to get 281, then we’ll add 281 to 245 to get 526. And we’ll continue this process until we’ve done all the letters. And then at the end, you’ll see that we still get the same checksum that we found earlier 1101, which becomes 81 when we do mod, and then the second checksum becomes 7336, which is 96 when we do them on. So now we only have to send along two additional numbers along with our text. And that will tell us a lot more about the text in the errors. So let’s take a look at that and see how many errors this can find. Let’s consider the case of just doing these first three characters. So we know that the checksum for 72, 101 ,108. If we look back here should be 281 and 526. So we would have 281 and 526. So let’s look at this first example. We have 72 108 101. Well, that changed the first checksum? No, it’s the exact same value, it will be to 81. However, will it change the 526? Well, we start with 72. And then we will add 72 plus 108, which is going to be eight 180. So the second check sum will be 180. So we’re going to add 180 here, 180 here, which is going to be 252. And then to the 180, we’re going to add 101. So the second checksum is still going to be 281. But if we add 281. Here, we’re going to get 331, we get 533.\nSo in this example, by switching these two characters, the first checksum did not change, but the second checksum definitely changes. And that’s because the order changed. Likewise, when we look at all of these examples, we see that all of them add up to the same set of characters. So the first checksum will always be 281. But the second checksum will be different every single time. And that’s because we’re adding this first checksum to the second checksum every single time so it captures the ordering of the characters as well as the values that they may change based on those different values. So even by adding a zero in there, we would get a different value for that second checksum. So once again, there will be a quiz after this video where you can try a little bit of Fletcher’s checksum just to see how it works.\n",
    "description": "",
    "tags": null,
    "title": "Error Checking - Fletcher's Checksum",
    "uri": "/iii-topics/15-compression-error-checking/04-fletcher/"
  },
  {
    "content": " Resources Slides Video Script So far in this module, we’ve only dealt with whole numbers such as positive and negative whole numbers or integers. But what about numbers that have decimal points in them? How would we deal with those? In mathematics, of course, we call these rational numbers because they can be expressed as a ratio or a fraction. And so in mathematics, one thing that we’ve used for rational numbers would be scientific notation. You may have seen this a few times in your science class, you’ll have numbers like 1.0 * 10^5.\nIn binary, we use a similar system that we call floating point. And the whole idea behind floating point like scientific notation is that the decimal point in the number can float around. And specifically, we can do something really cool where we can express a decimal number as two whole numbers, a mantissa, which is the value and then exponent, which is a power that is used to adjust the location of the decimal point. So this slide right here actually shows an example of what that looks like for scientific notation. And we do something very similar for binary numbers.\nBinary numbers use the system of floating point, which is based on the IEEE754 standard. And in this slide, I’m going to show you the 16 bit or half size example, which uses an exponent bias of 15, which we will understand in a little bit. Also, it’s really important to understand that the leading one of the mantissa is implied. And again, we’ll talk about that in a minute. In most actual computer systems, instead of a 16 bit number, you would have a 32, 64 or 128 bit floating point number, but that gets a little bit hard to do on a simple screen. So we’ll use 16 bits, but the theory is very similar.\nSo let’s see what it takes to convert this floating point number into its equivalent decimal for so this example we have a 16 bit floating point number, and you notice it consists of three parts. The first bit is the assignment, and since the assignment is zero, we know that this is going To be a positive number, the next five bits are the exponent. This exponent is 10100. This exponent is equivalent to a decimal value, where we have one, two, this is four, so we have four 8, 16. So you have 16 plus four is 20. Now the important thing to remember is the exponent has a bias of 15. So when we’re going from this value into its decimal value, we really have to take this binary value 20 minus 15, and we get an exponent of five. This allows us to actually store both positive and negative exponents using a positive binary number. For example, if we want to store the exponent, negative five, we would have negative five here and we would add 15 to it and we would get 10 And so then we will encode the binary value 10, which is 01010 as our exponent. But again, we’re not doing that in this example. So we’re going to erase that. And we know our exponent is five.\nThe next thing we need is our mantissa. And so in the explanation, we saw that there is an implied one here at the front of the mantissa. So this mantissa is really the binary value 1.0101. Now there are two ways to think about this mantissa Of course, we can calculate it directly. And just like with decimal values, where items to the other side of the decimal point are divide our negative powers of that value, so this is two to the zero, so this would be two to the negative one to the negative two to the negative three and so on. So we can actually calculate this value As one plus one fourth plus one 16th. So we can actually calculate this value, one plus one fourth plus one 16th, which is approximately 1.3125. So we have the value 1.3125 times to the fifth. And we know that two to the fifth is 32. So if we take 1.3125 times 32, we will actually get exactly the value 42. So that is the actual decimal value of this floating point number.\nThat may seem a little complicated, but there is actually a much easier way to do this. Recall that we started with the binary number 1.0101. And we know our exponent is five. So before we do any conversion, all we have to do is move this decimal place five places and so we end ended up with the binary value 101010 with the decimal place here at the end. And of course, we know that the binary value 101010 is equal to 42. So in calculating this value, a lot of people find it much easier to move the decimal place first, and then calculate the binary value, instead of calculating the binary value and then multiplying it times two to the fifth or two to the whatever the power is. Either way works, I have found the second way, much, much simpler.\nSo as we saw with this example, we can calculate the value of the mantissa. And we can calculate the value of the exponent to be 1.3125, and five, so the overall value is 1.3125 times to the fifth, which is 42. Or we can take the binary value times two to the fifth and simply slide the decimal place over and we’ll find the binary value 42.\nSo let’s do another example. This time converting a decimal number all the way to a floating point binary number to see what that process looks like. And in this case, let’s do the value 86. We’ve already converted 86 to binary before, which was 1010110 with the decimal point right here, so we need to do two things. The first thing we need to do is move the decimal place all the way forward, so we need to move it 1,2,3,4,5,6 places, so our exponent is going to be six. So to find our actual exponent value, remember we have to add the bias which is 15. And we will get 2121 in binary is going to be 16 plus four, plus one. So we get the binary value 10101. Then to construct our actual floating point number we start with our sign bits. So we have our sign bit right here, this is going to be zero, then we’ll have our exponent which is going to be 10101. And then we will have our mantissa. And remember with the mantissa, we take this value, but we remove this one off of the front, and so the mantissa will be 010110. And then we will fill the rest of it out with zeros until we get to 16. So we have There we go. So the decimal value 86, we can easily convert to a floating point binary number by moving the decimal six places using that six to calculate our exponent of 10101 and then calculating the rest of the mantissa by taking the one off of the value and using the other bits in the mantissa.\nFloating point numbers can have a very, very wide range of values. For example, the 16 bit binary floating point numbers that we looked at today have a range from negative 65,000 to positive 65,000 in whole numbers, but it can actually show values as small as 5.9 * 10^-8 And it also has ways of showing positive infinity and negative infinity by setting the exponent to all ones and setting the mantissa to all zeros. Unfortunately, because it is a rational number, it is inexact. For example, if we want to show the value one third, we would end up with this binary floating point of 0101010101 in the mantissa, which is really just 0.33325, which is not exactly one third, just like one third is a repeating decimal in decimal values. One third is also an infinite repeating binary floating point number as well. So it can’t be exactly shown, but it’s not really Either 0.3325 is actually pretty close to what we want. So what are these numbers look like in a real world computer in most modern operating systems and integer is a standard size of 32 bits, although most normal processors today actually support 64 bit integers by default, but a lot of programming languages are still built around the idea of 32 bit numbers. Likewise, we can have long integers which are 64 bits. And then for floating point we have half size, the single size or float which is 32 bits and the double size floating point which is 64 bits. And here we show that of these 32 bits, eight of them are used for the exponent and 23 are used for the mantissa. Likewise for a double size 11 bits are used for the exponent and 52 bits are used for the mantissa\n",
    "description": "",
    "tags": null,
    "title": "Floating Point",
    "uri": "/i-concepts/07-encoding/05-floating-point/"
  },
  {
    "content": " Man-Computer Symbiosis by J. C. R. Licklider\n",
    "description": "",
    "tags": null,
    "title": "Man-Computer Symbiosis",
    "uri": "/ii-internet/11-internethistory/04-man-computer-symbiosis/"
  },
  {
    "content": " Resources Slides Video Script As we saw in the video, the work of Paul Bran led to the creation of packet switch networks, a packet switch network might look something like this diagram, we have three computers. But we actually have six network devices that are creating a complicated network infrastructure that connects these three devices. So looking at this diagram, can you see some advantages to this network setup. For example, if one node goes down, can we still find a way to get a message to all the other nodes, it looks like we can in a lot of cases. So that makes this network very fault tolerance. In addition, if we want to add more computers to the network, we just have to plug them in at one of these open spots and they’ll be able to communicate as well. So packet switch network is really important. One of the key concepts in packet switch networking is routing. And routing is figuring out a way to create a path in the network to get from point A to point B using the shortest path which means Be the fewest number of hops, it really depends. And so with networking, if any one particular system goes down, our routing can actually figure out a way to get around that problem without any issues.\nWhen we talk about modern computer networking, we can think of it in terms of the seven layer OSI network model, sometimes referred to as the network stack. Each of these layers performs a particular task in turn involved in getting data sent from one computer application to another application on a different computer. The top three layers application presentation and session are usually handled in the software itself. So we’re not going to talk about those too much in this video, but we’ll take a look at the bottom four layers and how they are actually used to get data from one computer to another computer using the modern internets. The big concept here is encapsulation. Each of those layers adds a little bit of data around the data that we want to send, allowing it to get where it needs to go. So we start with data from the application. Then we go down to the transport layer and we add a little bit of data to it. Then we go down to the internet layer, we add some more data. And finally we get to the link layer and add even more data.\nThis may seem really confusing, but let’s use a little metaphor to try and understand it better. For example, think about a letter you’re sending through the postal system. We have the letter, we might put it in an envelope, and that envelope might have a name on it, such as mom and dad, then we can take that nice envelope and put it in another envelope. And that’s the actual mailing envelope that has the address information on the back and the stamp and the return address. And then we put that letter in the mailbox. And when that letter gets picked up by the Postal Service, it might go into a box full of letters going to the same destination making up the frame. Then when the letter gets to the destination post office, it’s taken out of that box, they read the address, it gets to the location where it needs to go. They open the outs envelope, they look at the inside envelope, they see who it’s intended for. And then that person can open that envelope and get their data back out. And so encapsulation is really the important concept around this layered model of networking.\nAnd we’ll take a look at each layer and what it does in particular, just to see a little bit more about how it works. The very bottom layer of the network model is the physical layer. And the physical layer handles the actual sending of individual bits and bytes across the network wires. He uses technologies such as hundred 10, or 1000, base T or gigabit And the important thing about the physical layer is it doesn’t have any knowledge of the packet whatsoever, just the next hop the next destination that it needs to be sent to on the network itself.\nThe next layer up is the data link layer. The DataLink layer or the Ethernet layer deals with different frames of packets and it deals with things such as congestion. One of the most important things that happens at the DataLink layer is Establishing the rules of the road for each packets, it assures that a packet has a location and an address. And so the data link layer really handles the way the data is routed across individual Ethernet cables between different networking devices. You can think of it kind of like working with a zip code.\nNext, we go up to the network layer. And the network layer is the Internet Protocol layer. And this is actually what defines the end points of the packet where the packet starts at one computer and the destination of the packet at the other end. And so in the network layer, we have this packet structure that has a lot of different information in it. But the most important thing that it has is the IP address of the computer that sends it and the IP address of the destination computer that should receive it. You can think of an IP address like a phone number. It’s a unique number that identifies a single computer on the internet itself. And it tells us where it’s coming from and where it’s going to. This is the packet structure for IP version four but it is Quickly being replaced by IP version six.\nLet’s take a look at the difference between IP version four and IP version six. IP version four uses addresses that have 32 bits of data. And so if you think about it two to the 32nd is about 4.2 billion. So really big number. And for a long time, we thought that that was going to be enough IP addresses on the internet. Of course, the internet has become much, much larger of the last few years. And so it’s very easy to imagine that there well more than 4.2 billion devices in the world. I mean, there are over 7 billion people in the world. So we don’t even have enough IP addresses for each person to have just one device. And if you’re anything like me, you probably have multiple devices that you’re using. So we’re looking at moving toward IP version six, which uses 128 bit addresses. It’s four times as many bits but we get to the point where we can have 340 undecillion IP addresses. Another way to think of it is Each atom in the basically each grain of sand on the earth can be assigned its entire ipv4 address space of 4 billion addresses and we’d still have plenty of them leftover. So I’m hoping that ipv6 is probably enough, at least for now. So of course, the network packet at the ipv6 layer looks very similar with just a larger source address and a destination address. And so hopefully this works for a long time to come.\nThis graphic taken from an XKCD comic shows the IP address space as it looked like a few years ago, in 2006, when this comment was written, all of the greenspaces were still available as open IP address space that could be taken on the internet. But of course, it’s all now gone. And so we’re running out of address spaces on the ipv4 internets. One interesting thing to note is originally on the internet, the 256. First octets of IP addresses were originally assigned to individual companies. For example, IBM was the assigned any IP address starting in nine. The K-State IP address range if you’re interested, is 129.130. And so we have one 256 of one square of this particular diagram was assigned to K-State originally.\nThe fourth layer is the transport layer. And the transport layer is where the transmission control protocol or TCP resides. The biggest thing that TCP does is it adds ports to the IP address. And so on a computer we can have many different programs that are all connecting via the internet at the same time, and we need a way to tell which data goes with which program. That’s what the transport layer does for us by assigning ports to programs on a computer. As we receive packets or as we send packets, we can mark them with a certain port that is associated with a certain program that should be able to interpret that data. Computers today use a set of ports, the US 65,535 unique ports. And some of them you might be familiar with. For example, the internet. The World Wide Web uses Port 80 for TCP or for HTTP connections.\nSo there are two different things that operate at the transport layer. There’s TCP the Transmission Control Protocol. And the other protocol at the transport layer is UDP the User Datagram Protocol. And you can see here the UDP packet structure has a lot less information. This is because unlike TCP, UDP has no technology to guarantee transmission of data. As we’ve discussed earlier, TCP relies on verification and retransmission of missing data so that TCP can guarantee every single packet is delivered if possible, whereas UDP does nothing like that. It just sends the packets and hopes they received, but it doesn’t have any way of controlling that. TCP of course is very useful for when we need to make sure every single bit of data gets there, but UDP also has its uses. For example, think of streaming data or store streaming video, or streaming video game data. If you don’t need every particular packet, instead of trying to retransmit those packets that have been missed, UDP will just skip them entirely and keep moving on.\nThis, of course leads to the two worst jokes in the history of computer science. Do you want to hear a TCP joke? I could tell it to you. But then I’d have to keep repeating it until I was sure you got it. Do you want to hear a UDP joke? I could tell it to you. But I’d really never be sure if you got it or not. See what I mean. It’s really two different technologies trying to do two different things. But they all have their very important uses in the internet today.\nSo to summarize, TCP is a connection orientated, reliable protocol that uses acknowledgments to verify the data has been sent and received properly. UDP on the other hand, is a connectionless protocol that is not really reliable, because it doesn’t use that system of acknowledgments to make sure the data has been received properly. These two texts analogies are two of the core technologies that operate at the transport layer on the internet in that seven layer OSI model that allows different computer programs to talk to each other using the internet.\n",
    "description": "",
    "tags": null,
    "title": "Seven Layer OSI Model",
    "uri": "/ii-internet/12-internettech/04-seven-layers/"
  },
  {
    "content": " Resources Slides Video Script Let’s take a look into a few other different methodologies in software development. So this one is in complete contrast to the waterfall model of software development and pretty much all other development methodologies. Because this methodology, there really isn’t anything to it. It’s generally known as cowboy coding or code and fix. Now, this in many ways, is the anti software engineering approach, where planning, testing documentation at pretty much everything, all of that is ignored, or immediately writing code. And predictably, this leads to a lot of what we refer to as spaghetti code. And so it’s just mangled structure that has really no clear way to it at sprinkled with sub optimal algorithms memory leaks, structural issues is just a mess, right? Imagine getting out a box of Christmas lights that were just thrown into a box and in January, and you go back in December, try to put those Christmas lights up. And magically, they’ve aimed together into this big ball that takes hours upon hours to actually unravel. And sometimes it’s just easier to throw it away and start from scratch.\nEven more unfortunately, with this methodology of cowboy coding, this is actually unfortunately very much how most students learn to approach software development and their early assignments. And it’s often carried with them into industry. So the sooner that we can actually start to teach design structure and this process, the better habits that you will develop, especially as you start getting closer to working to working to an internship and into To a full time job.\nBut not surprisingly, issues in software engineering are typically coupled with periods of surging growth for a field of computer science. And so this graph here based off of data collected by a tabulate survey tracks the growth of Bachelor’s of Computer Science degrees since 1966, up through about 2010. Now, you’ll notice the two very clear spikes in this graph, one peaking around 1985 and the second around 2004. That first rise was a big issue here for K state and many other universities that that matter, to and to meet the growing demand of students with the limited faculty available to graduate students taught and many of the undergraduate courses, similar measures were employed at other institutions likely compromising the quality of preparation for an entire generation of software engineers because people were thrown into teaching positions that really weren’t that well qualified to teach those particular topics are experienced enough.\nA similar trend occurred during the second peak, although thankfully not so much with us. But hopefully you can maybe guess what the driving force was behind that growth rates at that time, right. So this peaked around 2004. That was around the.com. Boom. So the first search that we saw began in the early 1980s when the personal computer started to be introduced. And so that spikes the first surge and the demand for computer science degrees, and then the second peak reflects the dot com bubble. So as the internet came out in 1990, we saw a huge burst in the late 90s of companies thinking, Ah, well, we can make it big if we get on the internet. Okay, and so we saw a huge surge In the need for computer science. But after the.com bubble burst, which burst in the early 2000s, we saw a rapid decline in the demand for computer science degrees. But thankfully, over the past few years, we’ve since then we have seen a increase, and the demand for computer science or an increase in the number of degrees awarded in computer science. And we haven’t seen that die off quite yet.\nBut with the growth of the internet, Internet companies and the eventual collapse and the success of all the survivors to underscore the need for a more reactive and flexible style of software development that was possible with the waterfall model. So the dot com boom, sparked a lot of different kinds of needs of technology and software, especially with the invention of the internet, of which we had never actually developed software for something like that before. So the web needed to be what robust, secure and most importantly, scalable. And so that meant cowboy coding couldn’t meet that need either, even though it was super flexible, because we could just start with no planning whatsoever. But that often led to very insecure software and software that really didn’t scale well. So new strategies as a result of the dot com boom, emerged to create more robust software engineering approaches, and these were started to be employed more widely.\nOne of these of course, was just simply prototyping which is especially useful for developing experimental or difficult to estimate systems. And so the idea here right is to build a prototype, establish the base functionality, complexity and worth wildness of the of the specific product right. So this begins with implementation or coding and then leads to other activities, like requirements gathering and software design. So try something out and see if it works. See If the Customer likes it. If they liked Or let’s say they like this, but not that let’s keep things that they like and throw away the stuff they don’t want. So this is pretty much the cowboy coding or the code and fixed process with a more developed and structured approach, right. It’s not just a standalone process. There’s a lot more involved and there’s a lot more structure here.\n",
    "description": "",
    "tags": null,
    "title": "Software Development Life Cycle Part 2",
    "uri": "/i-concepts/09-software-engineering/04-sdlc-2/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re gonna be taking a look at interactive web technologies. And now we’ve talked a lot about these things in the past about Web 1.0 vs 2.0. So going from the static plain HTML Web to Web 2.0, where everything is much more dynamic, interactive, more media, more content, more interactive technology. And so we’re going to take a look at how we can actually use some of these to make our websites a little bit more interesting. Some of the primary ones that we’ll be talking about today are the Document Object Model, which is fundamentally how a lot of the Web 2.0 pages actually are structured and work. JavaScript, Ajax, and JSON, which also helped make our webpages a lot more interactive. First, let’s take a look at the Document Object Model or DOM. So the document object model is really how a web page is actually structured. So you can kind of think of the window here as like a tab in your web browser. So the entire contents of that is your window. And in that window, we have history of that web page. So maybe even things like cookies, past searches, past form information, things like that, location information. But then we have the document itself, which is the actual page that we’ve loaded. So your document or HTML, everything that was between the open and close HTML tags, actually goes here.\nBut this operates kind of like a tree structure here. So the base form here, the base is going to be our HTML tags. And then we can kind of dive deeper down in that way. Like, for example, we have the anchor tags, which are links in our web page. Or we could even have a form like if we’re trying to sign up for a website or making a post on Reddit or something like that. So we have basically everything that we can interact with, or click on or work with on our webpage is contained inside of this document. But this gives us a lot of structure as well. So when we’re actually trying to make dynamic and interactive content, having the Document Object Model allows us to manipulate and work our web page, whether or not that is inserting new elements into our web page, or modifying those elements on our web page. So the the root element here is the document itself. So that’s the top of our tree there. And from our document, we go down into the root, actual HTML tag, and then everything else is kind of contained in between.\nSo before we had the header tag, and if you remember, the header tag doesn’t actually contain information that’s typically displayed on web page itself, but has information that is important to the webpage to render, for example, the title which is shown on your tab inside either Firefox or Chrome. So the head tag contains in this case on this page has a title tag and that title tag has some text. And so that is the actual content of that particular tag. Each tag here is considered an element of the DOM. So each tag is going to be considered an element, each tag contain any number of more tags. And those tags can also contain other types of content, like text. Now, the primary source of content on our webpage was the body tag, if we remember, right. T\nhe body tag is going to contain everything else that we had on our page, like we have a head tag here, for example. The head tag has some text. This a tag those one becomes a little bit more complex. So we have the a tag, which is our element. The a tag can also contain the attribute href, which contains the information on where that link is actually going to. So if it’s a different web page, if it’s a different image, whatever we’re trying to actually navigate to. And then we have the link text as well as part of the a tag. So you can kind of start to imagine how this rigid structure of the actual HTML allows us to navigate this a little bit better. Because without this, an HTML web page is actually just really kind of a jumbled mess.\nSo thanks to the Document Object Model, we have a relative standard that we can use to actually search our web page dynamically in order to insert, add, or change anything as part of our webpage, after the web page has loaded or while the web page is being loaded. So this allows us to have again, right we’re going from a very static webpage that never changes, unless we actually change the webpage by hand on the backend if we upload a different file to our server to Web 2.0 where we’re having a little bit more interaction here and more dynamic content. So now instead of having a plain single web page, my webpage can actually change as it’s being loaded or changed based off of who’s logged in. This adds a lot more purposeful information to our websites. But in this series of videos, what we’re going to start taking a look at is how we can make a tic tac toe game in HTML.\n",
    "description": "",
    "tags": null,
    "title": "The Interactive Web",
    "uri": "/ii-internet/13-webprog/04-interactive-web/"
  },
  {
    "content": "The history of the Intel® 4004\nThe Story of the Intel® 4004\n",
    "description": "",
    "tags": null,
    "title": "The Story of the Intel® 4004",
    "uri": "/i-concepts/08-architecture/05-intel-4004/"
  },
  {
    "content": " Resources Slides Video Script The next algorithm we’re going to look at is bubble sort. Bubble sort might seem similar to Insertion Sort, but it’s actually quite the different algorithm. So in bubble sort, what we will do is we will start by comparing two side by side elements in the list of data. And then if they’re out of order, we will swap them. You can see in the animation above me how those two red boxes move to compare two side by side items. And if they’re out of order, it will swap them just like so. Then we’ll repeat that once we get all the way to the end of the array. We’ll start back over at the beginning, and we’ll go through it multiple times until it is entirely sorted. Or as the algorithm says here, we’ll continue until we go all the way through the array and we don’t make any more swaps. So let’s go take a look at how to perform bubblesort using our deck of cards. The next algorithm we will look at is the bubble sort algorithm as we do bubblesort keep track of how many times you swap to different cards as that will become really important as we analyze these algorithms later on in this module.\nSo to do bubblesort, we start off by looking at the first two cards, the seven and the eight. And we ask ourselves are these two cards out of order, the seven should come before the eight. So we know that these two cards aren’t out of order, so we won’t do anything. Then we will shift one position over and look at these two cards, the eight and the four. And once again, we ask ourselves are these two cards out of order, the eight shouldn’t go before the four. So they’re out of order, and they need swapped. So that’s one swap that we have done so far. Now we’ll look at the eight and the two, we see that those are out of order. So we’ll swap those that’s two swaps. The eight also goes after the ace. So that’s three stops, swaps. Then we have the eight goes after the three, which is four swaps. Now we’re looking at the eight and the 10. And in this case, the eight does go before the 10 so We won’t do anything here.\nNow we’ll look at the 10 and the nine, and we see that those are out of order and need swapped. And likewise, the 10 goes before goes after the six, and goes after the five. And so now we’ve made it all the way through our list of cards. And we noticed that the highest card, the 10, has bubbled to the end of the list. And that’s the really important part about bubblesort. Each time you go through, at least one more card should be bubbled to the correct spot at the end. So once we’ve made it to the end, we’ll start all the way over here at the beginning and try it again. So now we look at the seven and the four. Those are out of order and need swapped. We’ll look at the seven and two. Those needs swaps. The seven in the ACE get swapped the seven and the three gets swapped, but now the seven and the eight don’t get swapped. Likewise the eight and the nine are in the correct order, but the nine in the six are out of order. Needs swapped, and the nine and the five are out of order and need swaps.\nSo now we’ve made it through twice. And we now have two cards, the nine and the 10 that have bubbled to the end of the array been placed in the correct order. So now we’ll repeat this process once again, we see the four needs swapped with the two, the four and the ace needs swapped the four and the three needs swapped, the four and the seven are okay, the seven and the eight are okay, the eight and the six need swapped as well as the eight and the five. So now we have the eight in the right spots. We’ll start over again. We’ll put the ace in the two, the two and the three, right, the three and the four, right, the four and the seven are right, but the seven and the six are out of order. And the seven in the five are out of order. And now we have four cards in the right spot. And if we start over again, we’ll notice the ace and tour Okay, two and three are okay, three and four. Okay, the four and the six are okay, but the six and the five out of order. And now we have five cards in order here. But look, we’ve already got the array sorted even though we still had a few cards that we weren’t sure about.\nWe know that if we went through it again, we would not make any swaps. And that’s one of the powerful features of bubblesort is that once we make it all the way through our list of numbers without making a swap, we know that it’s in the correct order, and we can stop working. See if you can do the bubble sort algorithm on your own using a deck of cards to understand how this algorithm works. And remember, while you do that, keep track of how many times you have to swap two numbers because that will help us in our analysis in the next video.\n",
    "description": "",
    "tags": null,
    "title": "Bubble Sort",
    "uri": "/i-concepts/06-algorithms/05-bubble-sort/"
  },
  {
    "content": " Notes About This Selection This video gives a great insight into what we will cover in this course. Our journey will start with early computation tools, such as the abacus, slide rules, and astrolabe! We see punch cards as a connection between early computing and modern computing.\nReference CrashCourse. “Early Computing: Crash Course Computer Science”. Feb, 22, 2017. YouTube. Available: https://www.youtube.com/watch?v=O5nskjZ_GoI\n",
    "description": "",
    "tags": null,
    "title": "Early Computing: Crash Course Computer Science",
    "uri": "/i-concepts/02-early-computing-machines/07-early-computing-crash-course/"
  },
  {
    "content": " Resources Slides Video Script So what really is programming? Right? We’ve talked about a lot of famous women in computer science so far, that have been very influential in the first computer programmer. Right. So Ada Lovelace, the queen of software, Grace Hopper, and Margaret Hamilton, who really pioneered the idea of software engineering, best practices with computer programming. But, what does that really actually entail? Well, programming itself, right computer programming, is simply the act of designing, writing, debugging and maintaining the source code of a computer program.\nLet’s imagine that we’re writing a program, a very simple program, that takes input from the user, and then prints out a result that is divided by 61. So the user inputs a number and then we divide it by 61 and output it. So what would that program actually look like? Well, in Scratch, right, it would look something like this. This programming language is very English like, right? It’s a block based programming language that is designed to teach young kids, even up through middle school on basically how to program. And it makes it a lot easier for humans to understand. Because even if I showed this to my grandma, she could probably deduce kind of what’s going on here. Ask for a number and wait, and then divide whatever the answer to that question was by 61. And stop, right? Simple enough. So, very easy for a human to understand.\nBut do you really think that a computer is able to understand this language? Probably not, right? My computer has no idea what the idea of a block is, right? Computers really only only care about ones and zeros. That’s it. So how do we get from a block down to something a computer can actually understand? So that’s really going to highlight our language hierarchy here. So our high level languages, so the stuff that humans can understand, so stuff that we can understand is what we pretty much deal with on a daily basis as computer scientists. But, then we can kind of go down our stack right into the assembly, machine code, and then down on the hardware, where the actual physical hardware could actually interpret what we’re trying to talk about. But first off, let’s take a look at more high level languages.\nSo we’ve already showcased Scratch, which is a very human readable. But here is a program written in C or C++. And we’re now starting to get into some stuff that is not so human readable. This in general requires a little bit of training in order to understand, right? Just like if you don’t know Spanish or French, if you are trying to read something in that, in that different language, you need a little bit of training to figure out what was going on. So we have a lot of extra syntax here like printf, right? What does that mean? What is a float? If I, if this is the first time ever reading a programming language, I’d have no idea what some of these things actually are. But again, right, this is the same program: input a number divide it by 61. And then output that result.\nSame thing goes with Java, right? As you can see here, we have a lot more, a lot more fluff, right. So we have a bunch of import statements up here. We have we now have to have a class and we have to have a public static void main string args, whatever the heck that’s supposed to mean, right? And even beginner Java programmers aren’t even introduced to this concept until once you get deeper into that particular course, What’s a scanner? What are we scanning? I don’t know. So again, right requires a little bit of extra training and Java, with it being an object oriented programming language, adds a lot more fluff and syntax and wrapping to our program just for a simple program like this in order for it to work.\nAnd C# isn’t much better. C# is essentially Microsoft’s flavor of Java, but does the same thing right: inputs a number, divides by 61 and outputs it. I would argue that this code here is a little bit easier to understand. But again, right, we have a bunch of extra fluff here that you know, start from scratch is a little bit more difficult to understand without a little extra training.\nNow Python, like Scratch, is generally touted very human readable. So it doesn’t have all of that extra fluff, right? We have no class, or namespace or inputs, or sorry, imports to define here. We just take input, and then convert it to an int, store it and then print out the result, right? Simple enough. So all of this extra fluff that we had here, in C#, I’ve reduced all of this down to two lines in Python. That’s why Python is traditionally used as a scientific language because it’s a lot more accessible to non-computer scientists.\nBut again, right, there’s tons of different programming languages out there and they all have their purpose. They all have their place. Some more human readable than others, right? We’ve talked about COBOL already right with Grace Hopper, Pascal, Visual Basic Perl, fortran which is an old one as well. Basic is another older programming language. There’s way too many of them to list here. But the point is we have a lot of different languages with the various different purposes, but all of them with a trained computer programmer, could use them to communicate their particular idea or task or whatever they’re trying to do to the computer. But again, right, all of those languages can’t be understood by the computer directly.\nThe majority of those languages will have then a compiler associated with them. And compiler or assembly is typically a language that is assembly language is typically still readable by humans, but is much closer to the language a computer would actually understand. And assembly language requires much more training to actually understand what’s going on. And so to go from a high level language to assembly language, we’ll use a program called a compiler, which in its entire purpose is to act as a translator. So the language that we use to write our program and like Python, or Java, let’s say, is then compiled and translated down into an assembly language, which is closer to what the computer can understand. Here’s our C program, the assembly language that’s associated with that after it’s been compiled. This particular part is simply, right, taking a number and dividing it by 61. And this is, this is a heck of a lot more complex, isn’t it? Right? You will eventually, or if you, if you take some of our upper level computer science courses, you will learn how to translate all of this and understand what’s going on here. But the majority of computer scientists aren’t going to need to understand assembly language unless you’re dealing more with things at the operating system level or hardware level and things like that, or even cybersecurity if you’re into cybersecurity, being able to understand some assembly is quite useful. Not directly interpretable by your hardware quite yet.\nOnce we have our assembly language that is going to be then fed into the assembler, the assembler is going to take the assembly language and convert it into machine code, which is then directly read by your computer. The assembly and things like that. Some of this will actually depend on the operating system, the architecture and things like that, that you’re actually running on your computer. While the high level language is uniform, mostly across all machines, the assembly code is not. Likewise, machine language is very specific to the machine that it’s being built for. So, machine language is just simply a set of binary code, all ones and zeros, that tell the computer exactly what to do. And so here’s the machine code for the assembly language that we just saw previously. Theoretically, right? You could translate all these ones and zeros back into the original program. But that’s pretty difficult to do, right? It requires a significant amount of training to be able to try to translate these ones and zeros back into what it was originally.\nAnd so now we’re getting into code that can be interpreted directly by your machines, hardware. Your hardware, really all it cares about is current or no current, right? Electricity is on or the electricity is off. And so this simply refers to the structure of chips and circuits that your computer is made of. And we’ll talk more about that in another lecture. But, and the gist of it here, right, we’re feeding all of our ones and zeros into each of the inputs of our hardware, which is taking those ones and zeros, doing some sort of calculation and outputting the result back to your computer.\nBut overall, right this is kind of the big picture of computer programming, right? We go from a high level language, where we have things like Python, C, C#, Java, JavaScript, all of those languages that you would normally program in, as a, as a software engineer. And those languages are then compiled or taken by a compiler and compiled into assembly language, which is more machine specific, right, depending on operating system, Mac, Apple, Linux, that sort of thing. 64 bit versus 32 bit processor, lots of different things that go into that particular compilation. But that assembly language is then assembled, taken by the assembler and then converted into machine language which is just the ones and zeros that your hardware is going to interpret\n",
    "description": "",
    "tags": null,
    "title": "What is Programming",
    "uri": "/i-concepts/04-programming/07-what-is-programming/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Clip from Pirates of Silicon Valley (Dramatization)",
    "uri": "/i-concepts/10-hci/04-pirates-of-silicon-valley/"
  },
  {
    "content": " Resources Slides Video Script Overview Let’s go through an example of some Boolean logic now that we’ve covered some of the operators and some of the rules that govern the Boolean algebra behind it. A lot of times what you’ll see in computer science, especially when you’re dealing with Boolean logic and complex algorithms, our truth tables, truth tables showcase all the different options for each Boolean variable inside of a Boolean logic statement, as well as what output those particular facts for those variables actually produce. So let’s take a look at an example that we’ve already kind of done with end. So we’ve already explored the statement A and B, and C. You’ve already seen what the Venn diagram for that looks like, but we can also explore what that looks like again here in just a second, but let’s take a look at all possible values that we could actually input for A, B, and C. And if you remember, we’re only going to have two values binary values, either one, or zero or true or false. Now, both work synonymously. And you’ll find both in truth tables. And in fact, what the examples that you’ll be working with, we actually do use ones and zeros for true and false. So if you remember one means true, zero means false. But let’s take a look at how we can actually fill out our truth table here with those particular values. Now, I’m going to go ahead and use T for true and false. But as you could imagine, you could substitute one for true and zero for false and everything would be identical.\nSo what we would actually start with our truth table here as each of our columns here represent each of our variables or each of our facts as part of our Boolean logic statement though For a, what we’re actually going to do here, easy way to fill this out is we’re going to want to fill out all the different possibilities. So if we exhaustively go through each of our variables here, you may find that each one has two possible values. And then if we multiply this out, if it’s powers of two, we have eight possible outcomes or combinations of these values. You’ll notice that I have eight different rows in my truth table. That’s going to represent all of the different combinations that I actually have for this Boolean logic statement. Now generally, when we try to figure out how many different combinations we have the number of options we have for our variable to the power of the number of variables that we actually have, so that in this case would be two to the power of three. So two times, two times To write two times two is four times two is eight. This is the total number of possible combinations of truths or our facts that we actually could get out of this Boolean logic statement.\nFilling in the Truth Table So let’s elaborate on that and fill out our truth table accordingly. The easiest way to start out for our truth table is go down one column first, because there’s kind of a general pattern that you can follow on filling this out. If we just fill half of our rows with false and then half of our rows with true we can work that out. So the column fills out pretty easily. This the pattern that you can kind of follow for the second column works as such, if you just fill in half of the falses, or half of the rows that was false of the first column with true and half of them with false and a similar pattern for the sets of trues down here. So if I make an imaginary line right here in the middle, we can try to fill out all the falses first. So, I want to fill out half of these with false and half of these with true. So let’s start with false first. So false, false, and then True, true. Down here, I’m going to do the same exact thing. false, false, true, true. And I’m going to continue the same pattern where I’m going to fill half of what I just filled in and see with falses, and half of what I just filled in with true. So for this set of falses, here, I’m going to have false true. With the set I’m going to have false true. Now, this pattern doesn’t exactly always hold, especially as you start adding a fourth column But with three variables, it’s pretty easy to fill out using this particular pattern. But if you find yourself filling out a truth table for more than three facts, all we’re actually doing is exhaustively writing out all of the different combinations of true and false values or each set of variables. Now, let’s go through and try to evaluate the output here, or our truth table. This particular statement is fairly easy with a and b, and c. Because we’ve already seen that with an and statement, both sides of the operator must be true for the whole statements to evaluate to true.\nSo in my output here, I’m going to write out what this set of facts this row of facts evaluates to for our Boolean logic statement up above. So I’m just going to kind of put row numbers here 123. And then let’s write our output. Over here, so, false and false and false, is going to evaluate to false because no sides are true and similar ID here, false and false is false. And true. is also False. False and true is False. False and False. False and true. And notice I’m evaluating this from left to right, right, because my statement is a and b, and c, so I’m evaluating the A and B first, and then I’m adding that result with C. So false and true is False. False and true is false. true and false is false, false and false is false. true and false is false, false and true is false. True and true is true. But true and false is false. True and true is true, true and true is true. Now on our truth table, we have a completed evaluation of what our Boolean logic statement A and B and C can actually cover, right, so we have all the different combinations of values, or truth of A, B, and C. And then we’ve also evaluated those truth values as part of our output. So now we know when this statement is true, and when the statement is false.\nVenn Diagram In lecture in the previous video, we saw what the AND operator looked like for our Venn diagram as well. So let’s kind of draw that over here, just so we kind of have what that looks like again, and or the statement just as we kind of had over in our truth table, we’re only going to fill in the spot where a true B is true and C is true, where essentially that means the output of our country table is true. So if I just kind of put a, b and c here, and then we also remember, we have a square on the outside that represents everything that is not A, B, or C. I will be giving you some more examples of this or where I’m going to actually give you the truth table, then you’re going to try to generate the Boolean logic statement and the Venn diagram and even some logic gates.\nLogic Gates But let’s try to draw the logic gates for this as well. And the examples that you’ll be doing our logic gates are written like this. So we have our three inputs A, B, and C. Now if you remember the logic gate for and looks like this. Let’s draw that. So what we want to do is start out by drawing the logic gate for the first part. Have the logical statement, which is a and b. So to do that, you can kind of imagine electrical wires kind of coming off of the sources of A and B, or your individual variable. So I’m going to draw kind of a little wire out over here into my open space on the right from a and then my second input to that statement is B. So I’m going to draw a wire out from there. And I’m going to draw my gate. So it looks like a D, and my output there. Now I can draw the second part of the statement, which is and C. So I’m going to draw a line from C and draw out here and it’s okay if your wires go at a 90 degree angle or a little bit of a curved connect the logic gates together. And now that I have the output from a and b, and the output the input from C, we’re going to join those together with another and gate. So the logic gate drawing of a and b and c can be viewed as that. Now everything that I just did apart from generating your truth table are going to be reviewed and practice in a few examples.\n",
    "description": "",
    "tags": null,
    "title": "Truth Tables",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/05-truth-tables/"
  },
  {
    "content": " Resources Codio Documentation Video Script This course makes extensive use of several features of Canvas which you may or may not have worked with before. To give you the best experience in this course, this video will briefly describe those features and the best way to access them.\nWhen you first access the course on Canvas, you will be shown this homepage. It contains quick links to the course syllabus and Piazza discussion boards. This is handy if you just need to jump to a particular area.\nLet’s walk through the options in the main menu to the left. The first section is Modules, which is where you’ll primarily interact with the course. You’ll notice that I’ve disabled several of the common menu items in this course, such as Files and Assignments. This is to simplify things for you as students, so you remember that all the course content is available in one place.\nWhen you first arrive at the Modules section, you’ll see all of the content in the course laid out in order. If you like, you can minimize the modules you aren’t working on by clicking the arrow to the left of the module name. I’ll do so, leaving the introductory module open.\nAs you look at each module, you’ll see that it gives quite a bit of information about the course. At the top of each module is an item telling you what parts of the module you must complete to continue. In this case, it says “Complete All Items.” Likewise, the following modules may list a number of prerequisite modules, which you must complete before you can access it.\nWithin each module is a set of items, which must be completed in listed order. Under each item you’ll see information about what you must do in order to complete that item. For many of them, it will simply say view, which means you must view the item at least once to continue. Others may say contribute, submit, or give a minimum score required to continue. For assignments, it also helpfully gives the number of points available, and the due date.\nLet’s click on the first item, Course Introduction, to get started. You’ve already been to this page by this point. Many course pages will consist of an embedded video, followed by links to any resources used or referenced in the video, including the slides and a downloadable version of the video. Finally, a rough video script will be posted on the page for your quick reference.\nWhile I cannot force you to watch each video in its entirety, I highly recommend doing so. The script on the page may not accurately reflect all of the content in the video, nor can it show how to perform some tasks which are purely visual.\nWhen you are ready to move to the next step in a module, click the Next button at the bottom of the page. Canvas will automatically add Next and Previous buttons to each piece of content which is accessed through the Modules section, which makes it very easy to work through the course content. I’ll click through a couple of items here.\nAt any point, you may click on the Modules link in the menu to the left to return to the Modules section of the site. You’ll notice that I’ve viewed the first few items in the first module, so I can access more items here. This is handy if you want to go back and review the content you’ve already seen, or if you leave and want to resume where you left off. Canvas will put green checkmarks to the right of items you’ve completed.\nContinuing down the menu to the left, you’ll find the usual Canvas links to view your grades in the course, as well as a list of fellow students taking the course.\n===\nNow, let’s go back to Canvas and load up one of the Codio projects. To load the first Codio projects, click the Next button at the bottom of this page to go to the next part of this module, which is the Codio Introduction tutorial. On that page, there will be a button to click, which opens Codio in a new browser window or tab.\nOnce Codio loads, it should give you the option to start the Guide for that module. You’ll definitely want to select that option whenever you load a Codio project for the first time.\nFrom there, you can follow the steps in that guide to learn more about the Codio interface. The first page of the guide continues this video. I’ll see you there!\n",
    "description": "",
    "tags": null,
    "title": "Navigating Canvas \u0026 Codio",
    "uri": "/00-introduction/02-navigating-canvas-codio/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Early Programming (Crash Course)",
    "uri": "/i-concepts/04-programming/08-early-programming/"
  },
  {
    "content": " Notes About This Selection In this video, Carrie Anne shares the principals of binary numbers and how we use Boolean Algebra to work with binary values. We get to see the truth tables for the basic statements (or, and, not, xor) as well as their respective logic gates. We also get a good primer for working on more complex statements.\nReference CrashCourse. “Boolean Logic \u0026 Logic Gates: Crash Course Computer Science #3 “. Mar, 8, 2017. YouTube. Available: https://www.youtube.com/watch?v=gI-qXk7XojA\n",
    "description": "",
    "tags": null,
    "title": "Boolean Logic (Crash Course)",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/06-crash-course/"
  },
  {
    "content": " Resources Slides Video Script Up to this point in this class, we’ve talked about a certain type of computer called a fixed program computer. However, a fixed program computer has some limitations. A fixed program computer can only perform one task without being completely rebuilt and redesigned for another task. While this may seem very powerful, it is actually very limiting. So examples of fixed program computers would be Babbage’s Difference Engine. It is designed and built for one particular purpose. Of course, Babbage did design another computer, the analytical engine that would have been different it would have been programmable.\nAnd this lies in the modern work of John von Neumann. John von Neumann was a researcher, a mathematician and engineer he was involved in a lot of fields, and his research was directly involved in the Manhattan Project, among other things. His work was also inspired by the work of Alan Turing, and he ended up working on the Edvac which was a successor To the computer. And as he was working on these systems, he started to see a way that he could design a computer that would not only be able to perform tasks based on this wiring, but also it could store program instructions in memory, just like it stores data and use those instructions to change what the computer is doing. This is the idea behind what we call a stored program computer.\nIn a stored program computer, the computer program itself can be stored in memory, just like the programs data. So no longer do we need to have separate bits of memory for storing the code that we’re running on our computer and the data we’re operating on, we can treat them as one in the same and this is a really revolutionary idea because it vastly simplifies the architecture of our computer down to just a few simple parts. We call this type of architecture von Neumann architecture. And in von Neumann architecture, a very simplistic view of a computer looks like this diagram. We need to have Some sort of an input device where we can collect data and input from the user. We have a central processing unit that contains a control unit that keeps track of the instructions we’re executing, and an arithmetic and logic unit that actually performs the calculation. That CPU is connected to a memory unit that stores not only the data that needs to be operated on, but the program instructions that make up the program that it is running. And then finally, the device needs some sort of output so that it can render its output out to the user either through a printout or a monitor or a sound. These parts make up modern von Neumann architecture. And if you think about your modern computers today, they are all built using this same idea. We have input devices, such as mice and keyboards, and speakers and microphones. We have a CPU, we have RAM and hard drives for our memory units. And then we have our output devices, our monitors, our speakers, all the different ways that we get data out of our computer is von Neumann architecture. In fact, there’s a really Bad joke in computer science that asks, Is there anything new in computer science? Yeah, not much since von Neumann. And it actually is kind of true.\nOf course, over time, computer architecture has changed a little bit in some of the details. For example, a lot of older computer systems use what’s called a system bus to connect the CPU, the memory and the input and output devices. So in this case, when the CPU wants to get some sort of data from memory, it sends a command to the control bus that both the memory and input and output are watching. And the CPU can send a control that says I would like data, then in the address bus, it can place the data address that it would like to receive. And then the input or output device or the memory can react to that control and place the data desired into the data bus so that the CPU can receive it. And a lot of different computer systems use this particular setup and it’s really powerful if you want to add more memory are more input and output devices. As long as you can connect them to the system bus. They can all communicate.\nOf course, this particular system might have a flaw, can you see what it is? One major flaw with this system is if the system bus becomes overloaded, or if you have too many devices connected to it, or if the system bus is the slowest part of the computer, it very quickly can become a bottleneck. And so more modern computer designs have changed things a bit, so the CPU and memory are more directly connected, so that we don’t have this system bus that becomes the limiting factor in our computer speed. This also leads to the concept of what we call the computer memory hierarchy. One of the things we have to remember with computer memory is the faster and more powerful the memory is, the more expensive it becomes. And therefore as much as we’d like to fill our computers up with the fastest, most powerful memory available, it would very quickly become too expensive. So instead, we try and we try and create a hierarchy of our memory where we have a little bit of the very, very fast memory Such as your processors registers, and the cash on your processors, usually in the size of a few kilobytes to a few megabytes. And then as we go down, we have some fast memory. But it’s a lot slower than that, such as our Ram or random access memory, where we might have a few gigabytes of that. And then we go further down the capacity where we have larger capacity, but slower. And so your hard drives or SSDs, are usually an order of 40 times as slow as the random access memory, which is again, an order of magnitude slower than the cache and the registers built into the CPU. And so one of the things we deal with a lot in computer science is building programs that can take advantage of this computer memory hierarchy. Can we design a program that acts upon data that’s stored in the processor cache, instead of constantly loading and unloading data from that cache? If you study things such as high performance computing, you’ll deal with this issue very, very often.\n",
    "description": "",
    "tags": null,
    "title": "Von Neumann",
    "uri": "/i-concepts/08-architecture/06-von-neumann/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "DEFCON Social Engineering CTF Report",
    "uri": "/iii-topics/17-cybersecurity/04-defcon/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "How oldschool graphics worked Part 1 - Commodore and Nintendo",
    "uri": "/iii-topics/22-graphics-and-video-games/05-oldschool-graph/"
  },
  {
    "content": " Resources Slides Video Script Differentiation here between strong and weak AI starts to lead to the idea of intelligent agents. Intelligent agents are entities that can perceive things about its environment through sensors and act upon that environment with effectors, hopefully in a way that can be perceived by the actual agent. And so what do you think are some examples of these intelligent agents that you’ve seen in your lives recently? I know for me, I have things like Amazon Alexa or smartwatches. Basically, anything that has a sensor and acts upon its own and its environment is going to be in some form of intelligent agent. Now a lot of these are going to be categorized as weak AI, right? So it’s very good at one thing. A simple example is a thermostat, or even a Roomba. Roombas are really good at vacuuming your floor, but not so great at opening your door for you, or cooking your food or telling you what temperature it is in your house.\nEach robotic agent or intelligent agent is going to have four primary functions. The ability to perceive things from its environment. So what it can sense, although granted, an agent isn’t going to be able to sense everything about its environment. Sensors are really what it can understand. So what it can sense, what it can understand, right, or what it can understand is only what it senses it knows about. Actions- so what it can do on its environment. And really, an agent is only going to be able to know a subset of all possible actions, it’s not going to be able to know all the things that are possible, right? Depending on the kind of AI and use of that particular agent. Some of those actions or environments become extremely complex, even in the game, something like checkers. A simple game overall, but it becomes extremely complex if you’re trying to go through all possible board configurations. The last major function of an agent are its effectors. So how it can do things. Really, and sometimes it may not be capable of doing enough in its environment, but these are the things that it’s actually able to do in its environment, or how it can do those things in its environment.\nNow, this also brings us into discussion of how an AI should act, right? A weak AI, strong AI, whatever you’re trying to talk about here. But this brings us into a discussion on how an agent or an AI agent should be able to act. Now a rational agent, which is what we perceive as intelligent is concerned with doing the right thing, given what it believes, from what it perceives. Given the information that it can gather from its environment, and all of the information that previously knows, it should be concerned about doing the right thing with that information, the act upon that information. But as you can guess it may not know everything, but it will try to do the best it can. Now, we can also measure the utility of an agent by measuring its maximum success. So how good is that? That is what is the right thing? And how do we figure out how well it did that thing? So to understand the effectiveness of artificial agents or intelligence, we have to ask ourselves questions about our beliefs, the uncertainty of knowledge, and how its represented and how we can reason and learn from it. And by studying our own rational behaviors, that is why we as humans do the things that we do, and we can hopefully better understand what goes on into the decision making process and how we can build better rational agents. But in that sense as well, right? If we’re trying to build perfect AI, our human bias gets into the AI that we build. And so one AI, this is why different robotic vacuums behave in sometimes entirely differently, because different humans are building different models of vacuums, or thermostats, or AAA whatever kind of AI you’re looking at. And that is based off of that particular person’s experiences, research and knowledge. And that bias is going to lead into different kinds of utility, different measurements of success, different actions, and different rational behavior.\nA couple of very simple examples here of categories of agents that we may see in weak AI, something like a simple reflex agent, which just simply does an action based off of the things that collects or senses from its environment. This is something as simple as a automatic door so you walk into Walmart, and the door opens for you. Right, awesome magic door that opens for you. There is no one that has to open the door for you. But that is a basic AI right? It is something that can perceive from its environment and act upon it. Now it doesn’t really know what its action does, AAA It does know that the door is open, but it doesn’t know what that actually means for the environment. It doesn’t know that it’s letting humans into the room, and it doesn’t know that it’s, you know, letting energy out, for example, as a basic automatic door. And we could do something a little bit more advanced like a learning agent, which is going to be able to learn from its actions and do better the next time, some form of critic or utility is going to be involved here. Something like a smart thermostat in your home. So a nest thermostat or eco be whatever smart thermostat you may be aware of, but those smart thermostats are going to try to learn your behaviors- when are you out of your house?, the temperature of the environment outside of your house, how comfortable you like to have your house, whether like it colder or warmer, what room you’re in, in the house. So it can make that room more comfortable than the rest of the house. So you save on energy. And those sorts of things are going to start learning your behavior or other types of behavior so it can better its particular results, right? It’s so a lot of these AI are basing their decision based off of the utility. The utility, the measurement of success, that it’s actually been programmed to to look at.\n",
    "description": "",
    "tags": null,
    "title": "Intelligent Agents",
    "uri": "/iii-topics/18-ai/05-intelligent-agents/"
  },
  {
    "content": " Resources Slides Video Script To really understand how big data can be useful, we can look at four different aspects that are usually referred to as the four V’s of big data. These are volume. So how much data there is a variety, how much or how little variety actually exist, velocity, just how fast data is being produced and or received. And veracity. How accurate is that data, there’s also a fifth fee, typically referred to as value. But we won’t actually include that in this particular lecture. But if you are looking at Big Data information online, you might see that fifth V out there called value. But let’s take a deeper dive into each one of these.\nSo volume of data, as I mentioned, deals with the scale of information. So how much is there. And so I was mentioned, this, and this graphic here is from a few years ago, but they mentioned that by 2020, there will be 40 zettabytes of data or 43 trillion gigabytes. That’s an increase of over 300 times more from 2005. And also 6 billion people have cell phones, which is an insane amounts of cellular devices. And if you think about how many of those are smartphones, which are generating a significant amount of information, right? It’s just amazing the amount of information that we are generating nowadays, especially with so many internet connected devices, things like smartwatches, smart cars, and even semi smart cars that aren’t truly self driving, but have electronics in them that generate information. And things like businesses, though, have increased the sheer amount of data that they’re dealing with now, as well, because 2030 years ago, there really wasn’t the means to actually buy one generate this kind of level of data, as well as store and store that type of information as well. So now we just basically store everything. And overall storage has become significantly cheaper than it has been in the past. And we can, technology has gotten a lot better. And we can store a lot more information in a much smaller amount of space.\nVariety of data is really important as well. So what kind of information are we actually generating? And we already saw what happened in a an internet minute earlier in a previous video. So what does that really equate to as well, things like smartwatches, smart devices, internet connected devices, so smartwatches, smartphones, things like your IoT devices inside of your house, internet connected lights, and social media is a huge one, everyone is using some form of social media, whether it be Facebook, Twitter, Instagram, Snapchat, streaming services, YouTube, Twitter, YouTube, Twitch, Netflix, Hulu, all of those sorts of streaming services. And then we even also have health care. So 2030 years ago, healthcare was still all pure pencil and or pen and paper, right? When you went to the doctor’s office, they came in with your file on a clipboard and filled out all of your information. Now, if you go to the doctor’s office, majority of the time, they’re going to come in with a laptop instead of a clipboard. And so all of your information is now digitize your chart, all of your health information is online, or at least digitize instead of being an on physical paper. That’s 150 exabytes. And that was in 2011. Due to our reliance, of technology, and the fact that pretty much everyone is online almost all the time during the day, we’re generating a sheer amount of information in a variety of different contexts. And so that provides a lot more interesting use cases of the Information Network generating online and are in our daily routine.\nThe third V of big data that we talked about is velocity. So velocity deals with essentially the speed right of how we’re actually retrieving that information. So, for example, the New York Stock Exchange deals with one terabyte of trade information during each trading session, and 20. By 2016, there was an estimated amount of almost 19 billion network connections. So that’s almost two as two and a half connections per person on earth. And if we stop to think about how many devices that you can currently have are currently own, that are connected to the internet and at any given point in time, the lot, right? When I was a kid, we might have had one computer that was connected intermittently to the Internet through a dial up connection. But now I have a smartphone, a smartwatch, Alexa devices that are in my house that are always connected online, my TV has a wireless internet connection, your gaming devices have an internet connection. So the number of things that are connected anymore, the number of connections that you have to the outside world, have increased drastically, and so has the speed of which you have your speed of your internet connection is before right with a dial up internet connection, there’s only so much information I can be exchanged on the internet every second. But now with high speed internet access, many more people are able to generate and consume significant amount of more information than we ever have been able to before. And that’s not just typical devices that we experience. We even have things like cars, right cars are generating the sheer, more more amount of information that they ever have as well. Even if you don’t own a smart car, most modern cars come equipped with far more sensors that are actually can actually transmit back to even the manufacturer to tell them information about your vehicle. Or even just tell you more about your vehicle than what information that you would have had before. The last fee in the last fee that we’ll be talking about today is veracity, which deals with the uncertainty of information. And this is a really important one because we have a significant amount of information. And a lot of business revolves around that information as well. So recommender systems online on Amazon, Google searches, your digital footprint that you leave online, all of that information is consumed in some way shape, or form, whether or not be from the company that you actually use a service for and generated that information. Or you personally as a user for things like your your health, so smartwatches Fitbit trackers, that sort of thing.\nIs that data accurate? Is that data valid? That’s where we’re dealing with the veracity or uncertainty of that information. And so this is a really interesting aspect here, one in three business leaders don’t actually trust the information that they use to make valid decisions. A little over a quarter of people done in the survey, were unsure about how much how accurate they’re getting, it actually was. This cost a significant amount of money, as estimated that poor data cost us about three and a half $3.1 trillion a year. So if you think about the number of businesses decisions that are actually made using this data, or the number of services that you use, that rely on big data techniques, or data that has been generated a lot, right, a lot of business revolves around that. And if that data is incorrect, or invalid, that’s money loss. And it can cause a lot of different controversies. And in some cases, and in terms of things like health care, borrows and various other things that can actually cost lives as well. So the veracity or certainty of data is an extremely important aspect of how we actually work with big data, how we store it, how we retrieve it, and how we actually analyze it.\n",
    "description": "",
    "tags": null,
    "title": "The Four V's",
    "uri": "/iii-topics/20-big-data/05-four-vs/"
  },
  {
    "content": " Resources Slides Video Script Let’s go over a couple other error checking methods that you might run across, we’re not going to go into these in too much detail because they are kind of complex at this level. But we’ll give you an idea of what’s out there, just so you can say you’ve seen it. One interesting example is the cyclic redundancy check or CRC. With CRC will have some sort of binary value. And we’ll use a particular checksum to verify it. So we’ll start with this binary value on a checksum. And we will compute the XOR of the checksum, and that binary value. So we start with 1010. And we XOR that with 1011. So we’ll get 1. And this works a lot like long division, we just keep working down the value until we get left with something that is smaller than our checksum. And so with this input 101000001001, we would send along these three bits 011 as our checksum. And then once we’ve received it, we can do this same division again, and make sure that we get the same checksum to know that the error hasn’t been introduced in our code.\nAnother method of error checking is hash codes. And hash codes are really complex. But they basically are a one way algorithm to take any piece of data and convert it into a single value. So for example, we would choose some sort of a hash base like 2 or 10, or 37. And then if we have a whole bunch of numbers, we would calculate the hash as the first number times our base to the value in plus the second number times the base to the power n minus one, and so on, and so forth. So if we have the word 456, if our base is 10, obviously, our hash should be 456. If our base is 100, we get 4056. If our bases, just five, it would be 126. But if we choose some interesting other numbers, we would get different hash codes. Later on, if you start taking programming courses, one of the data structures you’ll learn about is a hash table, sometimes known as a dictionary or a hash map. And to do that, what it does is it takes a piece of data and it computes the hash of that data, and then uses that to store the data in a unique way so that it can be quickly retrieved. But we can also use those hashes to verify data.\nAnother really common use of hashes would be password store. For example, md5 is a commonly used pass password hashing algorithm, or at least it was it’s been cracked since then. But you could take any text and calculate the md5 hash of that text and store that number. Then if anyone tried to input a password, you would simply take their password, re-compute the hash. And if it created the same hash as the actual password, then you know that that user inputed the create the correct password, and you could allow them access. Here’s another quick example of hash codes, just showing what it would look like for some other input data.\nAnother form of error checking you might run into is called a hamming code. And a hamming code is kind of complex. But what it does is it takes the data bits that you want to send and it calculates what are called parity bits for those data bits. A parity bit is basically a bit that’s designed to make all of those data bits plus the parity bit come up to an even number of ones. So if we want to send the data in bits, 3,5,6, and 7, for example, we want to send 0100, we calculate these three Hamming parity bits. The first one is 3,5,7. So we look at 3,5,7, there’s only a single one there. So that parity bit would be a one, the bits 3, 6, and 7 would be 3,6,7. There’s no one so we put a zero there. And then for 5,6,7, there’s a single one, so we need to add one more one to get to an even number of ones. Then to construct the actual hamming code, we have our first parity bit, our second parity bit, so one, zero, then we have our first data bit zero, then our last parity bit one, and then the last three bits of our data Five, six, and seven. It’s a little complex. But the concept behind Hamming codes is to create data words that are so far apart from each other that a single bit error, you can almost just round it to the closest binary value that makes sense for the hamming code that you’re using, and use that as your way to solve different errors. In this module, we’ve covered a lot of different ways that you can compress and do error checking on data that you send and receive or data that you store in your computer’s while a lot of this can be kind of complex and math heavy.\nI’m hoping this opens your eyes a little bit to some of the things that go on behind the scenes on your computer that you might be aware of, but really didn’t understand how they work. We deal with things like zip files and JPEG images all the time. And those are all examples of compression. Error checking is a little bit more behind the scenes, but it’s really the backbone of how we can send and receive data across the internet using these unreliable connections and packets that might be dropped and still be able to recover and understand the data that we receive on the other side.\n",
    "description": "",
    "tags": null,
    "title": "Error Checking - Other Methods",
    "uri": "/iii-topics/15-compression-error-checking/05-other-methods/"
  },
  {
    "content": " Watch through 2:40\n",
    "description": "",
    "tags": null,
    "title": "Flaw in the Enigma Code - Numberphile",
    "uri": "/iii-topics/16-cryptography/05-flaw-enigma/"
  },
  {
    "content": " https://www.kurzweilai.net/memorandum-for-members-and-affiliates-of-the-intergalactic-computer-network\n",
    "description": "",
    "tags": null,
    "title": "Memorandum For Members and Affiliates of the Intergalactic Computer Network - J.C.R. Licklider",
    "uri": "/ii-internet/11-internethistory/05-intergalactic/"
  },
  {
    "content": " Resources Slides Video Script The iterative development process, or the iterative development model breaks down software development into much smaller segments. This allows for a lot more change and variation to the development cycle. So the iterative development process works by working through many waterfalls. And so if you look at each one of these chunks here, each one of these stages, they’re pretty much the waterfall process. And so overall requirements are gathered, then we analyze those requirements develop, implement test, and this is a cycle right? In this case, our waterfall is circular so we can keep on trying Go Go, go, go go. And then we’re going to release a prototype or a version of our product. As we go through this each time a release, we demonstrate that to our customer. And get feedback and then we’ll work that back into our next cycle. And so we just keep on iterating this until we are doing our final release to our customer.\nOne more different developments that we want to talk about this time is actually proposed by Boehm, this combines prototyping and the waterfall development is very similar idea to iterative design. The spiral development model focuses on risk assessment and management by breaking projects into smaller parts, allowing for the evaluation and change as each part is individually finished. And so this works off of four main segments. So you are going to determine the objectives, alternatives and constraints of that particular iteration. So that small part, evaluate alternatives, identify and resolve those risks. So we want to try to match negates the risks because those risks, right, the more risk, the more cost is actually involved with the project. And then you’re going to develop and plan for the next iteration. So as you start to cycle out here, right, so you’re starting small, the center here, you’re going to start with very small projects, right. And as you complete those smaller projects, the base of the foundation of your software that’s going to slowly grow out, and you’re slowly going to introduce more things that are needed in the project, like different models, different prototypes, more testing, and the closer you get to the outside edge of the spiral, the closer you’re going to get to deployment. But this is again, right like iterative design, much more flexible, and overall, much more appropriate to what modern software actually lends itself to.\nBut even more so after this We actually come into something that’s very popular industry today called the Agile process. These methodologies that we’ve talked about so far were to being developed by software engineers and high level planning positions. A new philosophy was emerging from the rank and file developers which, as expressed in this Agile Manifesto, the manifesto reads as we are uncovering better ways of developing software, by doing it and helping others to do it. Through this work, we have come to value individuals and interactions over processes and tools, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan. That is, while there is value in the items on the right, we value the items on the left more. So while agile is often thought of as, as a software engineering process By itself, it’s not. Rather it’s a guiding philosophy that can be applied in conjunction with many other software development approaches. That said, it clearly works better with something like iterative or spiral development or any other reactive styles of software engineering than the more rigid approaches that embodied the waterfall approach. And so as part of the reading, I’m going to actually ask that you go check out the Agile manifesto.org website and honor they have all the principles that are assessed with agile development and kind of embody what agile actually means.\nBut overall in the Agile process, you’ll typically see something like this agile as it stands right is the philosophy behind it as extreme flexibility. In this sense, you work off of mostly what we refer to as sprints. So these small Sprint’s will always have some sort of deliverable. product to the consumer or the customer. So it’s looks very similar to what we see with the software development lifecycle and a lot of the iterative or spiral processes where you brainstorm or gather requirements, you design prototype, develop, you QA. So you test and test and test and test. And then you deploy. And as you deploy, you do a little bit more testing, and you deliver that product to your customer. Or maybe you deliver that to the next person up in your organization. And all that feedback is then worked back into the next iteration into your next sprint. And so typically, what you’ll see with Agile process of the Agile process or Agile software development is that each sprint will focus on one or two small features of the software. And once that feature is actually completed, then the that particular developer will move on To the next sprint with the next development of either that same feature with modifications that were given to them by the consumer, or moving on to after completing that feature moving on to the next.\nAnother improvement that came in the mid 90s was the development of a suite of standardized diagrams for modeling software. The Unified Modeling Language, or UML. UML allowed for complex software systems to be diagram discussed and shared between developers and an easier to interpret form. Because before then there was no standard for documentation or not necessarily, but there was a lot of complex software being developed and each programmer would document and diagram in their own unique way. Just like what we would have, we have our own unique way of speaking and writing. Each developer had their own way. of not only just writing their own code, but also diagramming and and discussing about that code. And so UML offer a standardized way to actually share the overall structure interactions. Things like the activity or sequence or flow of the program among different developers, actually was someone who’s actually been trained with you to interpret and read UML could understand the software at a much higher level, a much deeper level, even without knowing how to actually program. But for now, this is going to conclude our discussion on software engineering, software development. There’s obviously a lot more here that we did not cover. In future classes we’ll take a much deeper dive into the architecture, modeling and development of software.\n",
    "description": "",
    "tags": null,
    "title": "Software Development Life Cycle Part 3",
    "uri": "/i-concepts/09-software-engineering/05-sdlc-3/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video, we’re going to be taking a look at how we might make our Tic Tac Toe game using HTML, CSS, and JavaScript. To start out here, we’re going to make a new HTML page. Now this can go straight back into your index.html that we made in the previous videos. The one I’m going to make for this video is going to be called tictactoe.html. And I’m going to save this as all types. As I mentioned, we can just use the files that we had already previously created. Or we can make a new one, if you are using a previously made file, the only things that you might need to actually add in here is replacing our body tag, or just replacing the content with the new Tic Tac Toe stuff that we’re going to be talking about this time. So anyway, so what we actually had just have here, and if I just simply run this file, all I have is my Tic Tac Toe title. So a lot of what we have actually in the PowerPoint slides are also most of the HTML code that I’m copying over today. So if you need that reference, go and pull up those slides. And you can copy and paste a lot of this code in, or you can type it out by hand for some extra practice. The next chunk of code that I’m going to put in here is the actual word that we’re going to use for the Tic Tac Toe game. So let me come and tidy some of this up here. And again, if you remember the previous videos that we did on HTML, you don’t actually have to have proper white spacing, a lot of the time with HTML tags. I’m including proper whitespace, and tabs in here, just so our code looks nice and neat and clean, and it’s a lot easier for us to read.\nWith this, what our tags that we’re actually having in here today are the table tag. So you’ve already seen the h1 tag that we had before, which is just the header tag. But the new tag that we have not covered before is the table tag, the table tag is going to just as it sounds, create a table just like what you would do in Microsoft Word or even in Excel. Now the table tag has a table body, and the body is actually going to contain the contents of the actual table. Now, inside of the table body and its base form, we have trs, which stands for table row. So the tr tags that’s an open and close tag. And then inside of each row, we have td tags, or our cell tags. These td tags or table data tags are going to represent the content or columns that are contained inside of our table. So let’s go ahead and save this. And I’m going to refresh my web page. And you can kind of see that nothing is actually here, nothing actually shows up. But if we inspect our page, we can actually see that our table is actually there. It’s just super, super tiny and has nothing inside of it. Not yet anyways. So the other step that we can start making to make our table actually visible is adding a little bit of CSS. So what I’ll go ahead and do is I’m going to remake mine. But again, you can reuse the CSS file that we had from previous videos. So I’m going to go ahead and save this out here and I’m going to call this fancy.css. This is going to be all types. Save.\nSo now I have my CSS. And this couple CSS rules I’m going to paste in here. This first one is going to be for our td tags, which is going to add a border that is five pixels thick. That’s going to be solid, so not dashed, and it’s going to be colored black. And then each of our td tags are going to have a width and height of 100 pixels, a font size of 80 pixels. And it’s going to align the text to center and it’s also going to change the font type. So with that if we save, refresh. Ah, now we’re getting somewhere. Our Tic Tac Toe board is starting to look a lot closer to what we would normally expect a tic tac toe game to look like. But we’re still a little bit off as far as our board goes because typically we don’t have full squares here. We just have two vertical lines and two horizontal lines as part of our Tic Tac Toe board. So let’s take a look at some more CSS rules that we can use to make our Tic Tac Toe game a little bit better looking. So this, these CSS rules are also going to be applying to my td or table data tags. But this time around, what it’s going to do is it’s going to start cutting off the borders that we no longer need.\nSo for example, this CSS rule is going to find all td tags. And then for the nth child, so the first for every first td tag that it finds, it’s going to set the border left to be none. So what this is basically equating to is for the first column, right, so the first td tag that we find in each of our rows, we’re going to take off the left border. And so that applies to this cell, this cell and this cell. This CSS rule for every third cell, take off the right border, so that applies to the column on the far right the third column. Then, we do the similar thing for the table row. So this tr, so find all tr tags, so find all rows, and then pick the first one that we find. So I’m going to pick the first row and take off the top border. And then this says, Ah, give me the third row and cut off the bottom border. And so this is picking, these are picking the first and third row. And then within those, that first row and third row, it’s picking up all of the td tags, and then applying either a border top of none or a border bottom of none. And this just shows some more of the advanced CSS tags that we can use for our website.\nSo now we’re pretty satisfied for the most part for how our Tic Tac Toe game actually looks, at least as far as the board goes. But we’re also missing an indication. If we’re going to be playing this as a tic tac toe game, we need to know whose turn it is. So let’s go ahead and switch back over to our HTML file and add in a another piece of HTML. So here, I’m going to add in a div tag, that indicates whose turn it is. And so this is going to go right underneath our head tag. So here, I’m going to say div. And remember ID, the ID attribute should be unique. And I’m just going to call this turn. And it’s going to be first x’s turn that then close div. So the div tag is also new for us. The div tag is going to act more along the lines of a organizing feature in HTML. So div tags are used to gather up or tidy up like content. So let’s say I have a navbar on the left, where all of my website navigation goes. And then we have all the content on the right. So each of those could be a div tag, where we use to organize all the other tags that are contained inside of it. So mostly just used for organizational purposes. But it’s also extremely useful for applying CSS as well.\nSo with that, let’s go ahead and refresh our page here. And we can see X’s turn there. But X’s turn is kind of small. So we need some more CSS here in order to make that a little bit more interesting. And so the rule that we’re going to apply here is going to take the text inside and make it bold. Remember, the CSS selector for ID tags is the pound sign, so pound, and then the ID so turn, font weight to be bold, it’s going to transform the text that’s contained inside of this tag and capitalize it, center it, change it to 16 point font, change the background color, and then set the width of that particular container. So as I mentioned, right divs are used primarily to organize contents of your webpage or act as containers. So if we save that and then refresh our page here, we can now see that it is X’s turn, and we’ve capitalized. Right? Not all caps, but just capitalized the first letter in our div tag. So that would be x, made it bigger, made it bold, and then change the background color. Now, we could make this a little bit lighter of a gray too. And you can kind of play around with those colors a little bit to make it your own as well. But, as I mentioned, we should end up that looks something like this. But this is just our static page. If we click over here, click on any of these cells over here. It’s X’s turn, but no x actually show up in our web page. So here in a little bit we’ll have another video that explains how we might actually make our webpage or Tic Tac Toe game interactive.\n",
    "description": "",
    "tags": null,
    "title": "Starting Tic Tac Toe",
    "uri": "/ii-internet/13-webprog/05-tictactoe-page/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The World Wide Web: Crash Course Computer Science #30",
    "uri": "/ii-internet/12-internettech/05-www-crash-course/"
  },
  {
    "content": " Resources Slides Video Script So now that we’ve seen some examples of historical computer interactions, let’s talk about what it might take to make a good computer interface today. Think about the computer systems that you interact with on a daily basis. What about them makes them easy to use or difficult to use? Would your answer change if you gave that computer system to a toddler, or maybe your grandmother or an elderly person? So really good human computer interaction or good computer interfaces can depend widely based on the needs of the audience. Of course, there are some things that we can think about that make good human computer interactions. For example, we want it to be functional, it needs to do what it says it does. It needs to be reliable, it should always work the way we expect it to. It needs to have a high level of usability. So it’s something we can easily and effectively work with. It should be efficient. We don’t want to have to click 18 times to open up a single web page do we? It also should be maintainable both from the ideas of the user, it should be easy for them to keep their computer up and running. But it should also be maintainable on the software side for the developers that are building these apps. And one of the things that I think is often overlooked in the field of HCI, is it should be portable. We really want the same ideas to work across multiple different devices and even multiple different paradigms. And that’s something we’ll talk about a little bit later.\nTo really develop good HCI we have to follow this iterative design process where we start with an existing device, we analyze that device, we check our requirements, and then we can slowly make things better. It’s really interesting to think how computer systems have developed over time. And there’s some great YouTube videos looking at this, for example, considered the original iPhone design versus what we have in our modern iOS, or consider some of the earlier versions of Windows compared to the modern versions we use today. While those systems are very similar, we can see that there’s been a slow iterative design process that has slowly improved the design over time, based on the changing hardware and our changing understanding of good HCI.\nOf course, good HCI also relates to a lot of different fields. We have to think about things like psychology, such as the fields of memory and perception. How do we remember things? How do we perceive things on our computer? We have to talk about sociology and how interacting with computer changes how we interact with other humans. We look at things like cognitive science, we look at ergonomics, how easy it is for us to use a computer system, we can think of things such as graphic design and interaction design, what colors and shapes and buttons would tell us. We can even think of things like speech language pathology, should our computer refer to itself in the first person or the third person? How should it interact with us? And we can even think of really interesting fields such as phenomenology, the study of consciousness, how do we make things on our computer such as that we are consciously aware of What our computer is trying to tell us. And we’re not just ignoring it and clicking next all the time.\nSo one interesting case study from the field of human computer interaction is the case study of automated adaptive instruction. Automated adaptive instruction is the idea of providing the user with instructions based on what the user has done previously, and what we think are some possible next actions of the user. We’re all familiar with our phones autocorrect system, how it can predict the next words we’re trying to enter. Gmail recently has done this as well. That’s kind of the same idea. But instead of just filling in words, it’s actually telling us how to use the computer system and how to do what we want to do next. This really came about in the 1990s as users were getting used to the personal computer, but they were becoming overwhelmed by the complexity of the technology. And companies such as Microsoft turn this into a very lucrative area of research.\nAnd so probably the most interesting case study from adaptive instruction is the computer program known as Microsoft Bob, hopefully you’ve heard of Bob, but if not, this will be a really interesting thing to talk about. And I get really excited talking about this because when I was young, the first computer my parents bought came with Bob pre installed. And so my first computer interaction was actually with Microsoft Bob. This is what Microsoft Bob looks like. The whole idea behind Microsoft Bob was to take the desktop metaphor to the next level. And instead of having a desktop for our computer, we could mirror an entire house. And so our house would have a whole lot of different rooms, we could have the living room, where in this room we have things such as a Rolodex that represent our address book, we have a money bag that represents our finances. There’s a checkbook sitting on the table that represents our Quicken or our check our money software. And that was really the idea you would have things in your house in Microsoft Bob, that mirrors the things that you would use in the real world. And by clicking on those objects, you would opened the programs that related to that. And then of course, you could have different rooms, you could have a living room with all of this, you could have an office with different things, you could have a kid’s room with all the games in it. And so it was a really neat idea.\nBut of course, the automated adaptive instruction part is the little dog that we see here. This dog is called rover, and rover was there to try and help you navigate Microsoft Bob, it would offer to do things like help you find a program, go to another room, add something changed something, anything you wanted to do, you could interact with rover and rover would help you figure out how to do it. And it was this really neat idea. Unfortunately, I think Microsoft Bob really wasn’t quite ready for primetime. And graphically, it doesn’t look very good. And in fact, most computer users had gotten used to the desktop metaphor. And so the power users weren’t exactly excited about it either. And of course the biggest nail in the coffin was Bob itself wasn’t that great of a piece of software in some ways. It was kind of buggy and did crash a lot. How There are some people that really are big fans of Microsoft Bob even today. And so if you look online, there’s some great videos of people who have installed Bob even on a modern computer just to see how it works.\nOf course, this did lead to some ideas that stuck around. For example, rover became the search assistant from Windows XP. And of course, this is the source of the infamous Clippy office assistant from Microsoft Office 97. Again, it was the same idea. Microsoft Office has a lot of features that most users don’t know how to do, such as mail merge. And Clippy, even though Clippy might have been a little bit annoying, was perfectly capable of helping you figure out how to do that. And so it kind of got a bad name, but it did have some neat ideas.\nThe big lesson learned from these assistive agents is companies were trying to teach users how to use computers, instead of trying to design computer systems that work the way users expect them to. And so in a lot of modern computer design, instead Have all of this instructive bits, you see us trying to more and more build computer systems that act like we expect them to. A great example of that is on your phone. If you scroll up at the top of a web page, it tries to refresh the webpage. This is especially notable on social media sites like Twitter or Facebook, you’re scrolling up looking for new content. And so it immediately reacts to that and does what it expects you to think it wants to do.\nSo of course, there are a lot of virtual assistants out there today we have Clippy. In 2011, we had the release of Siri on Apple devices. We’ve had Google and Cortana. And now we have other devices such as Alexa. And so we’re really into the smart, the age of the smart assistant where almost every home has a smart assistant in it. Almost every device has the capability of using one. And so we’re really seeing this come into its prime today. So what were the big lessons learned? Well, of course, this led to a lot of different ideas, such as searches on Google, if you’ve ever searched for something on Google, and you get that Searching? Are you sure you didn’t mean X? That’s an example of adaptive instruction. It’s telling you how to do things on Google.\nWe also see context clues on our touch interfaces, where if we swipe left and right, when there’s nothing there, it will still let you swipe and show you that there’s nothing over there to be able to swipe to. And so like we talked about earlier, the big legacy here is, instead of trying to change human behavior, we want to try and change the program to fit the expected behavior of the human. Or to put it more concisely put things where people expect them to be.\n",
    "description": "",
    "tags": null,
    "title": "What is Good HCI?",
    "uri": "/i-concepts/10-hci/05-good-hci/"
  },
  {
    "content": " Resources Slides Video Script So far, we’ve looked at two different algorithms for sorting decks of cards, Insertion Sort, and bubblesort. So let’s take a minute and try and decide which of those algorithms do you think is faster for a computer? a better question might be, which of those two algorithms was faster for you as it person to perform? Those are really tough questions to answer, aren’t they? And so we need some way that we can analyze our algorithms and compare them apples to apples to see exactly which algorithm might be faster or more efficient on a computer. To do that, we use something called Big O notation. Unfortunately, when I refer to big O notation, I’m not talking about the giant robot anime from the early 2000s. Instead, I’m talking about the notation that we use to express the complexity of an algorithm. And specifically when we talk about complexity, we’re talking about the number of steps required to perform the algorithm based on the worst case size of the inputs.\nTo understand worst case, let’s consider the instance of bubble sort. So here are five different lists of cards that we could give as input to bubble sort. And let’s say we want to sort them from two all the way on the far side to the ace over here on the near side. So the final order would be 2,3,4,5,6, all the way up to 10, jack, queen, king, ace. Looking at these five inputs, which one do you think would be the worst case for bubble sort. So of course, we can analyze this. And if we count the steps required to perform bubble sort, we’ll find that the fourth input is the worst case. And if we look closely at that output, we see something very unique. It turns out that that output is actually the deck of cards sorted completely backwards. And so that means that every step it would need to swap two cards that are out of order. So the first time through is bubble sort. We will bubble the ace all the way up to the end, which will require 12 swaps. Then the king which will be 11 swaps, then the queen, which will be 10, then nine, then eight, so on all the way until we get it sorted. And if we add that all up, it turns out that we make 78 swaps in order to sort that deck of cards.\nSo the important part of big O notation is not finding that for a specific input, but finding that answer for a number of inputs and then graphing them. So this is a graph that shows along the bottom the size of the input in terms of the number of cards, and on the side, we have the number of steps that it takes to perform bubblesort. And so if we look at that graph, where there is 13 at the bottom, which is one suit of cards, we can go up and we see that 78 is about where that is. So if we look at this line, what sort of a function would we use in mathematics to create this line. As it turns out, this line follows the polynomial x^2. So we would say that insertion sort and bubblesort both run in big O of n^2. That means that for every n inputs, we expect it to take around n squared steps in order to solve the problem. Now you’ll notice that there are two more algorithms on this slide that we haven’t talked about yet. mergesort and quicksort.\nDo you suppose that there is a way that we can sort a deck of cards that is faster than big O(n^2)? A good way to think of n^2 is n^2 means that we would take every card and compare it to every other card in times in which is n squared. Can we do that faster? Let’s take a look at mergesort and quicksort. And see if that’s possible.\n",
    "description": "",
    "tags": null,
    "title": "Complexity",
    "uri": "/i-concepts/06-algorithms/06-complexity/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 3 - Page Rank\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 3 - Page Rank",
    "uri": "/iii-topics/19-search-info/05-9algs-ch3/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 1 - Nuts and Bolts.\n“The Pattern on the Stone: The Simple Ideas that Make Computers Work” by W. Daniel Hillis. ISBN 046502596X, newer version is also available and will work fine\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/01-what-is-computing-science/05-pots-reading/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The First Programming Languages (Crash Course)",
    "uri": "/i-concepts/04-programming/09-first-languages/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Imitation Game",
    "uri": "/i-concepts/05-universal-computers/05-the-imitation-game/"
  },
  {
    "content": " Resources Slides Video Script Example 1 (Slide 13) So let’s take a look at example one. And the best way to start this is where the output is actually true. So if we examine this line here, this line and this line, we can see that when B and C are true, output is True. When a and c are true, the output is True, or when all three are true, the output is also true. So a really good way to start is just by coloring in these three facts.\nVenn Diagram So when B and C are true, that’s this little square here. Then when a and c are true, that’s this little portion of the Venn diagram. And then when a, b, and c are so when all three are true, And that’s this little center part of the diagram. And then all other rows of the truth table are all false or zero. So we’re not going to fill in anything else in the Venn diagram here. So this is the full output of or the full expression represented as a Venn diagram.\nExpression So let’s tackle this as a Boolean expression. And so we’ve already talked through parts of what the Boolean expression would actually be. So this can start here with a and c, when a and c are true, the statement is true. So let’s write a and see us as one portion of our Boolean expression. So I’m going to write that using parentheses, and then we have B and C. So I’m going to kind of write this over here, B and C. What that’s the other part of the truth in our Boolean expression, but we can’t just write them side by side, right, we need to join the middle because we also need the center portion. So it’s either a and c are true, or either A and C or B and C. So enter a or operate in between. So if A and C are true, or B and C are true, so that’s this portion right here. So when a and c, or B and C are true, and our expression is true, this will represent our Boolean logical statement. But there are alternative ways to write this. And these aren’t just the only ways another way you could have wrote this would be C, right? Because in all three cases, C is always true. So C, and a or b.\nLogic Gates So let’s take a look at what the logic gates look like. So the logic gates and I’m going to write the logic gates for my top statement here. So this one right here, we need to write the left and right hand side of the OR operator first, and the OR operator is going to join these two at the end. The lines here represent the inputs of A, B and C. So I’m going to draw out the input of a because in this case, we have a and c. And those are connected together with the AND operator. And that gives an output and we have the same thing with B and C. So we have B, C, those are both connected together with an AND operator and both of those are joined together using or. So this would be the logic gate for this particular statement here.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/07-worked-example/"
  },
  {
    "content": " Resources Slides Finally, let’s briefly look at how dictionaries operate when used as parameters to functions in Python. As we can probably guess from the earlier example in Python Tutor, dictionaries also use call by reference, just like lists.\nHere’s a short example program in Python that demonstrates the use of dictionaries with functions.\ndef add_score(scores): name = input(\"Enter a name: \") score = int(input(\"Enter a score: \")) scores[name] = score def average_score(scores): total = 0 for key, value in scores.items(): total = total + value return total / len(scores) def main(): scores = {} for i in range(4): add_score(scores) print(average_score(scores)) main() Let’s take a look at this program using Python Tutor to see how it works. As always, you can copy and paste this code into the tutor.py file on Codio, or click this Python Tutor link in the lab to open it in a web browser.\nFirst, Python Tutor will iterate through the code and record all of the functions in the objects area. Once it reaches the call to the main() function at the bottom, it will jump to the code inside of that function. At that point, we should see this state:\nThe first thing that this program will do is create an empty dictionary in the scores variable. So, after executing that line of code, we’ll see a new dictionary in the objects area in memory as shown here:\nNext, we’ll reach a simple for loop that will iterate $4$ times, so we’ll enter that loop:\nInside of the loop, we are calling the add_score() function and providing the scores dictionary as an argument. So, when Python Tutor jumps to execute that function’s code, we’ll see it create a new frame for the function and populate that frame with the arguments provided as part of the function call:\nSince dictionaries in Python also use call by reference, we’ll see that the scores parameter in the add_score() function’s frame is just a reference back to the same empty dictionary that was created earlier. The scores variable in the main() function’s frame also points to the same object in memory.\nThe add_scores() function will prompt the user to input a name and a score. So, if we assume that the user inputs the string \"Name\" as the name, and \"95\" as the score, we should see this state in Python Tutor:\nThe last line of the function will add a new key-value pair to the dictionary, with the name used as the key and the score as the value. So, when the function is ready to return, we should see this state:\nAt this point, the control flow will return back to the main function, so our frame for the add_score() function will be removed. Thankfully, we can see that the new item we added to the dictionary is present in the one dictionary object in memory, which is also referenced from the main() function’s frame. So, once we are back in the main() function, we’ll see this state:\nAs we can see, dictionaries properly follow call by reference, so if we modify a dictionary that is passed to a function as an argument, we don’t have to return it back if we are just working with the same object.\nAt this point, the program will repeat that process three more times. We’ll skip ahead a bit to the end of the for loop in the main function, which will be this state:\nHere, our program will call the average_score() function to get the average of all of the scores in the dictionary. So, we’ll jump up to that function and provide the current dictionary as an argument, as shown here:\nThis function is very straightforward. However, let’s skip ahead a bit to when we are inside of the for loop, just to see what that looks like:\nIn our code, we are using the items() function of the dictionary to allow us to iterate over a list of the key-value pairs in the dictionary. So, inside of that for loop, we see both a key and a value variable, and they are populated with the first key and value from within our dictionary.\nOnce we’ve iterated through the entire dictionary, we’ll be at this state:\nWe’re ready to return from the function, and we’ve computed that our return value will be $92.5$, as seen the frame for the average_score() function. Once we are back in the main() function, we’ll simply print that value to the output:\nAs we’ve seen in this example, working with dictionaries and functions in Python is practically identical to what we saw with lists - both data structures use call by reference when they are passed as arguments to a function. So, as long as we understand how Python is storing the data in memory, we can effectively build programs that operate the way we expect them to.\n",
    "description": "",
    "tags": null,
    "title": "Dictionaries and Functions",
    "uri": "/x-cis115-labs/14-dictionaries/03-dictionaries-and-functions/"
  },
  {
    "content": " Resources Slides Earlier in this lab, we saw Python Tutor create a list variable within the frame of a function, but that variable actually pointed to a list object that was stored in the global objects list. As it turns out, this seemingly minor distinction is a very important concept to understand how lists and functions interact with each other.\nTo demonstrate what is going on, let’s explore a program that contains multiple functions that operate on lists using Python Tutor once again. For this example, consider the following Python program:\ndef increment_list(nums): i = 0 while i \u003c len(nums): nums[i] = nums[i] + 1 i = i + 1 def append_sum(nums): sum = 0 for i in nums: sum = sum + i nums.append(sum) def main(): nums = [1] for i in range(4): increment_list(nums) append_sum(nums) print(nums) main() Before we go through the full example, take a minute to read through the code and try to piece together how it works. For example, notice that the increment_list() and append_sum() functions do not return a value! Since they don’t return a value, will they really have any impact on the program itself?\nTo find out, let’s run through this program in Python Tutor. As always, you can copy the code to the tutor.py file in Codio, or click this Python Tutor link to open it in a web browser.\nPython Tutor begins by adding all of the functions to the global frame, and then entering the main() function when it is called at the bottom of the code. Once the program enters the main() function, we should see this state:\nThe main() function begins by creating a single list in the nums variable, which initially stores a single element, the number $1$. So, we’ll see the nums variable added to the main() function’s frame, with a pointer arrow to the list itself in the list of objects to the right:\nNext, we’ll reach a for loop that will iterate $4$ times. So, we’ll store the first iterator value, $0$, in the iterator variable i and enter the for loop:\nInside of the for loop, the first step is to call the increment_list() function, which accepts a single parameter. So, we’ll provide the nums list as an argument to that function call. Just like always, Python Tutor will create a new frame for the increment_list() function when we call it, and it will populate all of the parameters for that function with the arguments that are provided, as shown here:\nIn this state, we see something interesting. In the increment_list() frame, we see the parameter nums is also a pointer to a list, but notice that it points to the exact same list object that the main() frame points to. This is because we are only sending the pointer to the increment_list() function so it knows where to find the list in the objects in memory, but it doesn’t actually duplicate the list.\nIn programming, we call this method of dealing with parameters call by reference, since we are simply passing references, or pointers, to the various objects but not the objects themselves. In technical terms, we’d say that the list is a mutable, or changeable, object, so we’ll use call by reference instead of the usual call by value process.\nThe next step will be to enter the increment_list() function itself:\nIn this function, we are getting ready to use a while loop to iterate through the nums list. Since we’re going to be editing the values stored in the list, we should use a while loop instead of a for loop. So, we’ll start by setting the initial value of our iterator variable i to $0$, and then we’ll reach the while loop in code:\nWhen we’ve reached the while loop, we’ll need to make sure that our iterator variable is less than the size of the list. Since i is currently storing $0$, and our list contains at least one item, this Boolean expression is True and we’ll enter the loop:\nInside of the loop, our goal is to increment each item in the list by $1$. So, we’ll use the iterator variable i inside of square brackets to both access the item in the list currently on the right-hand side of the assignment statement, and then we can also use it as the location we want to store the computed value, which is on the left-hand side of the assignment statement.\nThen, we’ll increment our iterator variable i by $1$, and then jump back to the top of the loop:\nAt this point, we must check our Boolean expression again. This time, our iterator variable i is storing $1$, but the length of the list is also $1$, so the Boolean expression is False and we should skip past the loop. Since there is no additional code in the increment_list() function after the loop, the function will simply return here.\nNotice that the function itself is not returning a value. Since Python uses call by reference, we don’t have to return the nums list back to the main() function even though we updated it, because the main() function still has a pointer to that exact same list object in memory. So, once the function returns, we’ll end up back in the main() function as shown here:\nNotice that the frame for the increment_list() function is now gone, but the changes it made to the list are still shown in the list object to the right. This is why working with lists and functions can be a bit counter-intuitive, since it works completely differently than single variables such as numbers and Boolean values. A bit later in this lab, we’ll discuss how string values can be treated as lists, even though they are technically stored as single variable values.\nThe next step in this program is to call the append_sum() method, using the same nums list as before. So, we’ll create a new frame for that function and populate it once again with a pointer to the nums list in memory - the very same nums list that the main() function is using:\nIn the append_sum() function, our goal is to sum up all of the values currently in the list, and then append that value to the end of the list. So, we’ll need to create a sum variable to keep track of the total, which will initially store $0$:\nThankfully, since we are not going to update the list from within our loop, we can use a simple for loop to iterate through the list. So, we’ll start by storing the first value in the list, $2$, into our iterator variable i, and then we’ll enter the loop.\nInside of the loop, all we are doing is adding the value currently stored in i to the sum variable. So, we’ll store $2$ in sum and jump back to the top of the loop.\nAt this point, we’ve used every element in the list in our loop, so the loop will terminate and we’ll jump down to the code directly below the loop as shown here:\nFinally, the last line of code in this function will append the value of sum to the end of the list.\nAt this point, we’ve modified the list to contain a new element. However, in Python Tutor we can clearly see that this item was just added to the existing list object in memory. So, when we get back to the main() function, we’ll be able to access the existing list, which will now include this new element as well.\nBack in the main() function, the last step in the loop is to print the current contents of the list to the terminal. So, after we execute that line, we should see some output in our print output box at the top right of the screen:\nThere we go! That’s one whole iteration through the loop in the main() function. This process will repeat $3$ more times. Each time, we’ll first increment the elements in the list using the increment_list() function, as shown here:\nThen, we’ll sum up the existing elements in the list and append that value to the end of the list, which will result in this state:\nFinally, we’ll print the contents of the list at that point, and jump back to the top of the loop:\nEach time, the list will be updated by the various functions that the main() function calls. Thankfully, since Python uses call by reference, each function is able to update the same list object in memory, making it quick and easy to work with lists and functions in Python. At the end of the entire program, we’ll see this state:\nA full animation of this program, with some steps omitted, is shown here:\nFunctions that use lists as parameters are a very common technique in programming, and it is very important to understand how they work. If we aren’t careful, it is very easy to make a change to a list inside of a function call, and then later assume that the original list is unchanged. Likewise, if we pass a list as an argument to a function that works differently than we think it should, it could end up changing our data without us even noticing it. Hopefully this example makes it very clear how Python functions handle lists as parameters.\n",
    "description": "",
    "tags": null,
    "title": "Lists and Functions",
    "uri": "/x-cis115-labs/13-lists/03-lists-and-functions/"
  },
  {
    "content": " Resources Slides Testing nested loops can also be very tricky, especially because they can make our program’s control flow even more complex. So, let’s briefly go through an example to see how to determine what inputs we can use to test nested loops.\nConsider the following example program:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def main(): x = positive_input() y = positive_input() while y \u003c= x: for i in range(x - y): print(\"*\", end=\"\") y = y + 2 print(\"\") print(\"Complete!\") main() Let’s work through the process of generating some test cases for this program to see if it runs without any errors. As always, our biggest concern is to make sure that we don’t reach a situation where the program enters an infinite loop, and that we also try to provide inputs that will enter each loop at least once, and also bypass each loop if possible.\nInput Loop First, we see that the positive_input() function uses a loop to make sure the user inputs only positive values. So, some of our first test cases could involve trying values such as $-1$, $0$ and $1$ to check the edge cases of that while loop’s Boolean expression. When we run the program and provide those inputs, we should see it enter the loop in that function at least once.\nWe can also bypass that loop by simply making sure we enter a positive integer each time. So, we know we have a few test cases available that will achieve branch coverage for that loop.\nOuter While Loop Next, let’s consider the outermost while loop in the main() function. That loop uses the Boolean expression y \u003c= x to determine if the loop should be entered or not. So, we want to come up with a few tests that check the edge cases of that Boolean expression. We can start by choosing a value to use for x, such as $5$. Then, the edge cases of that Boolean expression would be when y is either $4$, $5$, or $6$.\nIf y is $6$, the Boolean expression would be False and it should bypass the loop. We can easily test this to make sure that is the case:\nLikewise, if y is $4$, we know that it should enter the outermost loop. Inside, we see a for loop that will iterate based on the expression x - y. Effectively, it will compute the difference between x and y and then iterate that many times. So, if x is $4$ and y is $5$, the difference between those values will be $1$. So, we’ll enter the innermost for loop at least once. When we run the program with these inputs, we’ll see the following output:\nWhat if we set both x and y to be the same value? We know that the inner for loop will run x - y times, so if both x and y are the same value, this would be a way to bypass that loop, while still entering the outermost while loop since y \u003c= x will be True. However, when we try to run the program with these inputs, we’ll see something interesting happen:\nOur program will quickly start printing blank lines of output to the terminal. So quickly, in fact, that it is hard to even see what happens. As it turns out, we accidentally caused our program to enter an infinite loop! When this happens, the only way to stop the program is to close the terminal window it is running in, or use the CTRL+C keyboard command to interrupt it. So, let’s see why this infinite loop is occurring, and figure out how we can fix it.\nInfinite Loop Did you spot the infinite loop when you first read the program’s code? It can be really tricky to find, which is why we have to be very good about choosing test cases that will explore many different ways to run the program.\nIn this case, the infinite loop is caused by the interaction between the two loops. In the outermost while loop, we have the Boolean expression y \u003c= x to enter the loop. However, inside that loop, the for loop will only execute x - y times, which also happens to be the loop variant for the outer while loop. The key to the infinite loop lies in the fact that the only line inside of the outer while loop that will change the value of either x or y is also inside of the inner for loop. So, if we don’t execute the for loop’s code at all, then the value of x and y won’t change either, and we’ll continually repeat the steps of the outermost while loop.\nThere are many ways to fix this problem, but the simplest would be to change the Boolean expression of the outermost while loop to be y \u003c x. That will ensure that there is at least one iteration of the innermost for loop, and the infinite loop condition will be avoided.\nSo, as this example shows, testing nested loops is just like testing regular loops - we want to try and find inputs that will enter the loop at least once, as well as inputs that will bypass the loops if possible, just to make sure there aren’t any strange situations that may arise. While this won’t find all errors that are present in code containing nested loops, it is a great way to start testing your programs.\n",
    "description": "",
    "tags": null,
    "title": "Testing Nested Loops",
    "uri": "/x-cis115-labs/12-nested-loops/03-testing-nested-loops/"
  },
  {
    "content": " Resources Slides One of the most powerful features of loops is to deal with invalid user input. For example, if we want a user to input a positive number, but they accidentally input a negative number instead, what should our program do? Previously, all we could do was print an error and ask the user to run the program again, but that isn’t very user friendly or efficient. Instead, we can use a loop to repeatedly prompt the user for input until we receive a valid input.\nLet’s look at an example to see how this works. Consider the following pseudocode procedure:\nPROCEDURE positive_input() { DISPLAY(\"Enter a positive number: \") x \u003c- NUMBER(INPUT()) REPEAT WHILE(x \u003c= 0) { DISPLAY(\"Invalid Input!\\n\") DISPLAY(\"Enter a positive number: \") x \u003c- NUMBER(INPUT()) } RETURN x } This procedure will prompt the user for input, and then store whatever is received in the variable x. However, if the user inputs a number that is less than or equal to $0$, it will print an error message and prompt the user for input once again. Let’s quickly code trace through this procedure to see how it works.\nCode Trace When code tracing a procedure, we simply start as if we are calling the procedure from somewhere else. So, our setup will look like this:\nThis program begins by prompting the user for input, and then storing the input as a number in the variable x. So, let’s assume that the user input the string \"-5\" when prompted. So, that will store the value $-5$ in the variable x.\nAt this point, we’ve reached the beginning of our loop, so we need to determine if the Boolean expression evaluates to true or false. Since the value stored in x is less than or equal to $0$, the Boolean expression is true and we should enter the loop.\nInside the loop, we know that the most recent input from the user was invalid. So, we’ll print an error message, followed by a new prompt for input, and then we can read a new value from the user. This time, let’s assume the user has input the string \"0\", so we’ll store the value $0$ in the variable x.\nNow we’ve reached the end of the loop, so we must go back to the beginning of the loop and start over.\nHere, we can check the Boolean expression once again. Since x now stores the value $0$, it is still less than or equal to $0$, so we should enter the loop again.\nJust like before, we’ll print an error and then prompt the user for new input. This time, let’s assume the user inputs the string \"7\", so we’ll store the value $7$ in the variable x.\nWe’re at the end of the loop once again, so now we’ll jump back to the beginning of the loop.\nHere, we can test the Boolean expression yet again. This time, however, since x is not less than or equal to $0$, the Boolean expression is false and we can jump past the loop.\nAt the bottom of the procedure, we are returning the value we received as input from the user. So, the value returned by this procedure will be $7$, which is a valid input that we received from the user itself. A full animation of this procedure is shown here.\nReading Input Once we’ve created a procedure such as this in our programs, we can easily use it to read input from the user and verify that it meets the requirements we need. For example, consider this main() procedure that uses the positive_input() procedure we created above:\nPROCEDURE main() { a \u003c- positive_input() b \u003c- positive_input() c \u003c- (a + b) / 2 DISPLAY(\"The midpoint is \" + c) } This program will simply find the midpoint between two positive numbers. All of the code for handling user input is in the positive_input() procedure, and we can call it multiple times to get multiple different inputs from the user.\nThe positive_input() procedure is a great example of a simple design pattern that is commonly used in programs. A design pattern is simply a structure in code that is used to solve a particular problem, usually one that comes up often in many different programs. If we learn to solve these little problems by using these common programming structures, or patterns, it makes it much easier for others to read and understand our code. In addition, by learning these design patterns ourselves, it makes it much easier for us to solve common problems in our code - we can simply apply the relevant design pattern instead of trying to create a new solution from scratch. So, feel free to make use of the positive_input() procedure shown here, or adapt it as needed, anytime you need to read input from a user.\n",
    "description": "",
    "tags": null,
    "title": "Input with Loops",
    "uri": "/x-cis115-labs/10-pseudocode-loops/03-input-with-loops/"
  },
  {
    "content": " Resources Slides Loops in Python are also a great way to handle situations where a user must input a value that meets certain criteria. Previously, we used an if statement to determine if the input was valid, but if it wasn’t valid all we could do was print an error and end the program. If we use a loop instead, we can prompt the user to provide additional input until we receive a valid value.\nTo make this process easy to use, we can develop a function just to handle input from the user. For example, if we want the user to input a percentage, we could use a function similar to this one:\ndef input_percentage(): x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) return x This function starts by prompting the user to input a number, and stores it as a floating-point value in the variable x. Then, it will reach the start of the while loop. The Boolean expression will check to see if the value provided is not a percentage, so if it is less than $0$ or greater than $1$ it is considered invalid.\nIf the input is invalid, we’ll print an error and prompt the user for input again. We’ll keep repeating this process until the user provides a value between $0$ and $1$, at which point the loop will terminate. The last line in the function will return that value back to where it was called from.\nReading Input With a function such as that in our program, we can use it in another function such as the main() function to actually read input directly from the user. For example, we can write a quick program to calculate a weighted average of exam scores as shown below:\ndef input_percentage(): x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") 1. x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) return x def main(): print(\"This program will compute weighted average for three exam scores\") print(\"Enter the first exam's score\") exam1_score = input_percentage() print(\"Enter the first exam's weight\") exam1_weight = input_percentage() print(\"Enter the second exam's score\") exam2_score = input_percentage() print(\"Enter the second exam's weight\") exam2_weight = input_percentage() print(\"Enter the third exam's score\") exam3_score = input_percentage() print(\"Enter the third exam's weight\") exam3_weight = input_percentage() total = exam1_score * exam1_weight + exam2_score * exam2_weight + exam3_score * exam3_weight print(\"Your total score is {}\".format(total)) main() A quick execution of this program is shown here:\nTake a minute to confirm that the program works by running it yourself, either in Python Tutor or directly in Python. You can even adapt this program to help calculate your final grade in this course!\nLearning to how to create building blocks of larger programs, such as the input_percentage() function described here, is a great way to develop our programming skills. If we can learn to take a large program and break it down into smaller, repeatable chunks, then the entire program becomes much easier to develop and maintain.\n",
    "description": "",
    "tags": null,
    "title": "Input with Loops",
    "uri": "/x-cis115-labs/11-python-loops/03-input-with-loops/"
  },
  {
    "content": " Resources Slides We’ve already seen how we can chain conditional statements by placing a new conditional statement inside of the False branch of another conditional statement. If we think about that, however, that implies that we probably should be able to place conditional statements inside of the True branch as well, or really anywhere. As it turns out, that’s exactly correct. We call this nesting, and it is really quite similar to what we’ve already seen in this lab.\nUsing nested conditional statements, we can really start to rethink the entire structure of our program and greatly simplify the code. Let’s take a look at how we can do that with our Rock Paper Scissors game.\nNesting Conditional Statements In our Rock Paper Scissors game, we are really checking the value of two different variables, p1 and p2. In all of our previous attempts, we built complex Boolean expressions that checked the values of both variables in the same expression, such as p1 == \"rock\" and p2 == \"scissors\". What if we simply checked the value of one variable at a time, and then used nested conditional statements in place of the and operator? What would that look like?\nHere’s an example of a Rock Paper Scissors game that makes use of nested conditional statements:\nHere, we begin by checking if the value in p1 is \"rock\". If it is, then we’ll go to the True branch, and start checking the values of p2. If p2 is also \"rock\", then we know we have a tie and we can output that result. If not, we can check to see if it is \"paper\" or \"scissors\", and output the appropriate result. If none of those are found, then we have to output an error.\nIn the False branch of the first conditional statement, we know that p1 is not \"rock\", so we’ll have to check if it is \"paper\" and \"scissors\". Inside of each of those conditional statements, we’ll also have to check the value of p2, so we’ll end up with a significant number of conditional statements in total!\nLet’s see what such a program would look like in Python:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if p1 == \"rock\": if p2 == \"rock\": print(\"tie\") elif p2 == \"paper\": print(\"player 2 wins\") elif p2 == \"scissors\": print(\"player 1 wins\") else: print(\"error\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") elif p2 == \"paper\": print(\"tie\") elif p2 == \"scissors\": print(\"player 2 wins\") else: print(\"error\") elif p1 == \"scissors\": if p2 == \"rock\": print(\"player 2 wins\") elif p2 == \"paper\": print(\"player 1 wins\") elif p2 == \"scissors\": print(\"tie\") else: print(\"error\") else: print(\"error\") main() In this example, we have an outer set of chained conditional statements checking the value of p1, and then each of the branches will check the value of p2 and determine which output is correct. It is very similar in structure to the chained conditional example on the previous page, just laid out a bit differently. As before, try running this program yourself in either Python or Python Tutor to make sure it works and you understand how it is structured.\nRemoving Duplicate States Looking at this code, one thing we might quickly notice is that we now have four places that print \"error\" instead of just one. This is because we now have to check the values of p2 in three separate places, and can’t simply assume that the final else case in the outermost conditional statement is the only case where an error might be found.\nOne way we can simplify this code is by including a specific conditional statement just to check for any error situations, and handle those upfront before the rest of the code. So, we can rewrite this code as shown here to accomplish that:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") else: if p1 == \"rock\": if p2 == \"rock\": print(\"tie\") elif p2 == \"paper\": print(\"player 2 wins\") else: print(\"player 1 wins\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") elif p2 == \"paper\": print(\"tie\") else: print(\"player 2 wins\") else: if p2 == \"rock\": print(\"player 2 wins\") elif p2 == \"paper\": print(\"player 1 wins\") else: print(\"tie\") main() By confirming that both p1 and p2 only contain either \"rock\", \"paper\", or \"scissors\" first, we can then make some pretty handy assumptions later in our code. For example, now the outermost conditional statement only explicitly checks if p1 contains \"rock\" or \"paper\", and then the third block is simply an else clause by itself. We can do this because we already know that \"scissors\" is the only other possible value that can be stored in p1, so we don’t have to explicitly check for it. We can make similar changes to the nested conditional statements as well. So, just by adding one complex Boolean expression and conditional statement to our program, we were able to remove 4 that we no longer needed!\nFurther Simplification In fact, we can even take this one step further. Now that we know that both p1 and p2 only contain valid values, we can easily determine if that match has ended in a tie by simply checking if the variables contain the same value. So, with a bit of restructuring, we can simplify our program as shown here:\ndef main(): p1 = input(\"Enter 'rock', 'paper', or 'scissors' for player 1: \") p2 = input(\"Enter 'rock', 'paper', or 'scissors' for player 2: \") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") else: if p1 == p2: print(\"tie\") elif p1 == \"rock\": if p2 == \"paper\": print(\"player 2 wins\") else: print(\"player 1 wins\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") else: print(\"player 2 wins\") else: if p2 == \"rock\": print(\"player 2 wins\") else: print(\"player 1 wins\") main() This code presents a clear, easy to read version of a Rock Paper Scissors program. At the top, we receive input from the users, and then the first conditional statement is used to determine if the input is valid. If not, it will print an error.\nIf the input is valid, then we can make some assumption about the various possible inputs in our program’s logic, which greatly reduced the number of conditional statements. We are also checking for ties at the beginning, so in the False branch of that conditional statement we can also assume that the values in p1 and p2 are different, further reducing the number of items we have to check.\nWe’ll revisit this example later in this course to show how we can convert the first conditional statement into a loop, which will prompt the user for new input if an invalid input is provided. This will make our program even better and easier for anyone to use.\n",
    "description": "",
    "tags": null,
    "title": "Nesting Conditionals",
    "uri": "/x-cis115-labs/9-nested-conditionals/03-nesting/"
  },
  {
    "content": " Resources Slides Another powerful feature of pseudocode are the comparator operators, which can be used to create Boolean values by comparing string and number values in an expression. These comparators are a powerful way to build programs that can perform different actions based on data received from the user, as we’ll see later in this lab. Let’s review the commonly used comparators in pseudocode.\nEqual The equal comparator = is used to determine if two values are equivalent. This operator can be used between any two values, and it will either result in a value of true if both values are equivalent, or false if they are not. Here are some rules to keep in mind:\nWhen comparing strings, the strings must be exactly identical to be equivalent. This means that capitalization, punctuation, and other special symbols must all be exactly the same in both strings. Strings and numbers will never be equivalent, even if the string contains text that would convert to the same numeric value. The same applies to strings and Boolean values. For example, we can use the equal comparator to check if two numeric values are equivalent, as shown in this example:\nx \u003c- 5 y \u003c- 3 + 2 DISPLAY(x = y) When executed, this code will display the following output:\ntrue We can do the same for two strings:\na \u003c- \"Hello \" + \"World\" b \u003c- \"hello \" + \"world\" DISPLAY(a = b) This time, the output will be:\nfalse This is because the two string values are not identical - one has capital letters, and the other one does not.\ntip-1 In most other programming languages, the equality comparator is represented by two equals signs == instead of a single one =. This is because the single equals sign is used in assignment statements in most languages, so we use a double equal as the equality comparator to avoid any confusion between the two.\nIn pseudocode, we use the arrow symbol \u003c- for assignment statements, so we can use the single equals sign for equality. However, it is important to remember that this only works in pseudocode, and will cause issues if used in other languages such as Python.\nNot Equal The next comparator is the not equal comparator, which is typically written as != in pseudocode. Sometimes, we may also see it formatted as the special character ≠, but we won’t use that character in our pseudocode.\nThe not equal comparator is exactly what it sounds like - it will return true if the two values being compared are not equivalent, or false if the two values are equivalent. So, the statement a != b is the same as saying NOT (a = b).\nHere’s an example of using this comparator in pseudocode:\nx \u003c- 5 y \u003c- 5 + 0.000001 DISPLAY(x != y) When executed on our “mental model” of a computer, we should get the following output:\ntrue This is because the values $5$ and $5.000001$ are not exactly the same value, even though they are very similar.\nLess Than and Greater Than The last four comparators are all similar, so we’ll cover them all as a group. These comparators are specifically used to compare the relationship between two values, determining an ordering between the two. We should already be familiar with these operators from mathematics:\n\u003c less than \u003c= less than or equal to (sometimes written as ≤ in text) \u003e greater than \u003e= greater than or equal to (sometimes written as ≥ in text) When these comparators are applied to numeric values, they’ll compare the two values just like we’d expect from math. For example, we can see these comparators in action in this pseudocode:\na \u003c- 5 b \u003c- 6 DISPLAY(a \u003c b) DISPLAY(\"\\n\") DISPLAY(a \u003e b) When we run this code, we’ll see the following output:\ntrue false These comparators are a bit more confusing when applied to string values. In that case, they will look at the lexicographic order of the two strings, which is similar to alphabetical order but also includes capitalization, punctuation, and other special symbols. We won’t cover that in too much detail here, but in most computer programs the letters are sorted according to their order in the ASCII encoding standard.\nFor example, we can compare two strings as shown in this example:\nx \u003c- \"test\" y \u003c- \"tent\" DISPLAY(x \u003c y) When we run this program in our “mental model” of a computer, we’ll see this output:\nfalse This is because the string \"test\" does not come before \"tent\" when placed in alphabetical order, since s comes after n. So, we would say that the string stored in x is not less than the string stored in y, and therefore the result should be false.\nOrder of Operations It’s also important to note that there are many situations where Boolean operators and mathematical operators are used in the same expression. In those cases, the mathematical operators are all resolved first, and then the Boolean operators in this order, going from left to right:\nBoolean comparators NOT operator AND OR As always, it is considered good practice to include parentheses in any complex expressions to make sure that the intent is clear, regardless of the order of operations.\nLet’s look at a quick example in pseudocode:\nx \u003c- 4 \u003c 5 AND 3 * 5 \u003e 12 OR NOT 7 MOD 3 = 1 This expression includes many mathematical operators, as well as Boolean operators and comparators. To evaluate this expression, we must first resolve all mathematical operations first, so we’ll evaluate 3 * 5 and 7 MOD 3 and place those results in the expression:\nx \u003c- 4 \u003c 5 AND 15 \u003e 12 OR NOT 1 = 1 Next, we’ll resolve any comparator operators, moving from left to right. This will convert any remaining numbers into Boolean values. So, we’ll evaluate 4 \u003c 5, 15 \u003e 12, and 1 = 1 and replace those expressions with the resulting Boolean values:\nx \u003c- true AND true OR NOT true Once we’ve done that, the next operator to evaluate is the NOT operator. So, we’ll evaluate NOT true to the resulting value false and place it back in the expression:\nx \u003c- true AND true OR false Then, we’ll handle the AND operator, so we’ll evaluate true AND true to the value true:\nx \u003c- true OR false Finally, we’ll evaluate the rest of the statement true OR false to the value true, which will be stored in the variable x:\nx \u003c- true As we can see, the order of operations allows us to work through a complex expression like this example. However, in practice, it is always best to include parentheses where needed to make sure the expression is evaluated like we intend it to be.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Comparators",
    "uri": "/x-cis115-labs/6-booleans/03-pseudocode-comparators/"
  },
  {
    "content": " Resources Slides One important concept to understand when writing if statements and if-else statements is the control flow of the program. Before we learned about conditional statements, our programs had a linear control flow - there was exactly one pathway through the program, no matter what. Each time we ran the program, the same code would be executed each time in the same order. However, with the introduction of conditional statements, this is no longer the case.\nBecause of this, testing our programs becomes much more complicated. We cannot simply test it once or twice, but instead we should plan on testing our programs multiple times to make sure they work exactly the way we want. So, let’s go through some of the various ways we can test our programs that include conditional statements.\nExample Program First, let’s consider this example pseudocode program:\nPROCEDURE main() { DISPLAY(\"Enter a number: \") x \u003c- NUMBER(INPUT()) DISPLAY(\"Enter another number: \") y \u003c- NUMBER(INPUT()) IF (x + y \u003e 10) { DISPLAY(\"Branch 1\") } ELSE { DISPLAY(\"Branch 2\") } IF (x - y \u003e 10) { DISPLAY(\"Branch 3\") } ELSE { DISPLAY(\"Branch 4\") } } main() We can represent the two if-else statements in this pseudocode in the following flowchart as well:\nBranch Coverage First, let’s consider how we can achieve branch coverage by executing all of the branches in this program. This means that we should test the program using different sets of inputs that will run different branches in the code. Our goal is to execute the code in each branch at least once. In this example, we see that there are four branches, helpfully labeled with the numbers one through four in the DISPLAY() statements included in each branch.\nSo, let’s start with a simple set of inputs, which will store $6$ in both x and y. Which branches will be executed in this case? Before reading ahead, see if you can work through the code above and determine which branches are executed?\nIn the first if-else statement, we’ll see the x + y is equal to $12$, which is greater than $10$, making that Boolean statement true. So, we’ll execute the code in branch 1 this time through. When we reach the second if-else statement, we’ll compute the value of x - y to be $0$, which is less than $10$. In this case, that makes the Boolean statement false, so we’ll execute branch 4. Therefore, by providing the inputs 6 and 6, we’ve executed the code in branches 1 and 4.\nSo, can we think of a second set of inputs that will execute the code in branches 2 and 3? That can be a bit tricky - we want to come up with a set of numbers that add to a value less than $10$, but with a difference that is greater than $10$. However, we can easily do this using negative numbers! So, let’s assume that the user inputs $6$ for x and $-6$ for y. When we reach the first if-else statement, we can compute the result of x + y, which is $0$. That is less than $10$, so the Boolean statement is false and we’ll execute the code in branch 2. So far, so good!\nNext, we’ll reach the second if-else statement. Here, we’ll compute the result of x - y. This time, we know that $6 - -6$ is actually $12$, which is greater than $10$. So, since that Boolean expression is true, we’ll run the code in branch 3. That’s exactly what we wanted!\nTherefore, if we want to test this program and try to execute all the branches, we only have to provide two pairs of inputs:\n$6$ and $6$ $6$ and $-6$ However, that’s only one way we can test our program. There are many other methods we can follow!\nPath Coverage A more thorough way to test our programs is to achieve path coverage. In this method, our goal is to execute all possible paths through the program. This means that we want to execute every possible ordering of branches! So, since our program has 4 branches in two different if-else statements, the possible orderings of branches are listed below:\nBranch 1 -\u003e Branch 3 Branch 1 -\u003e Branch 4 Branch 2 -\u003e Branch 3 Branch 2 -\u003e Branch 4 As we can see, there are twice as many paths as there are branches in this case! We’ve already covered ordering 2 and 3 from this list, so let’s see if we can find inputs that will cover the other two orderings.\nFirst, we want to find a set of inputs that will execute branch 1 followed by branch 3. So, we’ll need two numbers that add to a value greater than 10, but their difference is also greater than 10. So, let’s try the value $12$ for x and $0$ for y. In that case, their sum is greater than $10$, so we’ll execute branch 1 in the first if-else statement. When we reach the second if-else statement, we can evaluate x - y and find that it is also $12$, which is greater than $10$ and we’ll execute branch 3. So, we’ve covered the first ordering!\nThe last ordering can be done in a similar way - we need a pair of inputs with a sum less than $10$ and also a difference less than $10$. A simple anwer would be to input $4$ for both x and y. In this case, their sum is $8$ and their difference is $0$, so we’ll end up executing branch 2 of the first if-else statement, and branch 4 of the second if-else statement. So, that covers the last ordering.\nAs we can see, path coverage will also include branch coverage, but it is a bit more difficult to achieve. If we want to cover all possible paths, we should test our program with these 4 sets of inputs now:\n$6$ and $6$ $6$ and $-6$ $12$ and $0$ $4$ and $4$ There’s still one more way we can test our program, so let’s try that out as well.\nEdge Cases Finally, we should also use a set of inputs that test the “edges” of the Boolean expressions used in each if-else statement. An edge is a value that is usually the smallest or largest value before the Boolean expression’s output would change. So, an edge case is simply a set of input values that are specifically created to be edges for the Boolean expressions in our code.\nFor example, let’s look at the first Boolean logic statement, x + y \u003e 10. If we are simply considering whole numbers, then the possible edge cases for this Boolean expression are when the sum of x + y is exactly $10$ and $11$. When it is $10$ or below, the result of the Boolean expression is false, but when the result is $11$ or higher, then the Boolean expression is true. So, $10$ and $11$ represent the edge between true values and false values. The same applies to the Boolean expression in the second if-else statement.\nSo, to truly test the edge cases in this example, we should come up with a set of values with the sum and difference of exactly $10$ and exactly $11$. For the first one, a very easy solution would be to set x to $10$ and y to $0$. In this case, both the sum and the difference is $10$, so we’re on the false side of the edge. Our program will correctly execute branches 2 and 4.\nFor the other edge, we can use a similar set of inputs where x is $11$ and y is still $0$. In this case, both the sum and difference is $11$, so each Boolean expression will evaluate to true and we’ll execute branches 1 and 3.\nWhy is this important? To understand that, we must think a bit about what was intended by this program. What if the program should execute branches 1 and 3 if the value is greater than or equal to $10$? In that case, both of our chosen edge cases should execute branches 1 and 3, but instead we saw that the edge case $10$ executed branches 2 and 4 instead. This is a simple logic error that happens all the time in programming - we simply forgot to use the greater than or equal to symbol \u003e= instead of the simple greater than symbol \u003e in our code. So, a minor typo like that can change the entire execution of our program, and we wouldn’t have noticed it in any of our previous tests. This is why it is important to test the edge cases along with other inputs.\nIn fact, it would probably be a good idea to add a third edge case, where the sum and difference equal $9$, just to be safe. That way, we can clearly see the difference between true and false values in this program.\nSo, the final set of values we may want to test this program with are listed below:\n$6$ and $6$ (branch coverage 1 and 4) $6$ and $-6$ (branch coverage 2 and 3) $12$ and $0$ (path coverage 1 and 3) $4$ and $4$ (path coverage 2 and 4) $9$ and $0$ (edge case 2 and 4) $10$ and $0$ (edge case 2 and 4) $11$ and $0$ (edge case 1 and 3) As we can see, even a simple program with just a few lines of code can require substantial testing to really be sure it works correctly! This doesn’t even include other types of testing, where we make sure it works properly with invalid input values, decimal numbers, and other situations. That type of testing is really outside of the scope of this lab, but we’ll learn more about some of those topics later in this course.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Testing",
    "uri": "/x-cis115-labs/7-conditionals/03-pseudocode-testing/"
  },
  {
    "content": " Resources Slides So far, we’ve only worked with string values in Python. Strings are a very useful data type in programming languages such as Python, but they are very limited in their use. Recall that a data type simply defines how a particular value is stored in a computer. The str data type is used to store string values in Python.\nPython supports many different data types for handling various data that we’d like to store and manipulate in our programs. In this lab, we’re going to cover the two basic types used for storing numbers in Python, the int or integer type, and the float or floating-point type.\nIntegers In mathematics, an integer is a whole number, such as $3$, $-5$, or even $0$. Basically, any positive or negative number that doesn’t include a fractional or decimal portion is a whole number, and therefore it is an integer. In Python, those numbers can be stored in the int data type.\nIn Python, we can store an integer value in a variable using an assignment statement:\nx = 5 That statement will store the integer value $5$ in the variable x. Notice that the value $5$ does not have quotation marks around it. This is because we want to store the integer value $5$ and not the string value \"5\" in the variable. Also, as we learned earlier, this is why we cannot create variable names that begin with a number - since numerical values start with a number, this is how Python can tell the difference between a numerical value and a variable.\nJust like in pseudocode, we can also store negative numbers in a variable by placing a negative symbol - in front of the numerical value:\ny = -8 We’ll need to be careful and make sure that there is a space after the equals sign =, but no space between the negative symbol - and the number after it. Otherwise, the negative symbol could be confused for the minus symbol, which is an operator that we’ll learn about later in this lab.\nIn Python, there is effectively no maximum size for an integer, so we can store any arbitrarily large whole number (either positive or negative) in an int variable.\nFloating-Point values The other type of number we can store in Python is a floating-point number. We won’t go into too much detail about floating-point values here, since you’ll learn about them elsewhere in this class. For the purposes of programming, the only thing to know about floating-point numbers is that they are used to represent numbers that include a fractional or decimal portion. In Python, these values are stored in the float data type.\nTo create a variable that stores a floating-point value in Python, we can use an assignment statement that includes a value with a decimal point, like this:\na = 5.8 We can also create negative values using the negative symbol -:\nb = -7.987 Finally, it is possible to store a whole number in a floating-point value by simply adding a decimal point and a 0 at the end of the value, as in this example:\nc = 42.0 Later in this lab, we’ll see a couple of situations where that may be useful.\nFor now, we’re just going to assume that Python can easily handle any reasonable number we want it to store in a float variable, but there are some limits to the size and accuracy of those numbers. To reach these limits, we usually have to be dealing with numbers that have $100$ or more digits, either before or after the decimal place. So, for the purposes of this class, those limits really won’t apply to what we’re doing. You’ll learn about these limits in detail in later programming classes.\nDetermining Variable Type One thing that is very useful to know how to do in Python is determining the type of data stored in a variable. Python is very flexible, and we can store any type of data in any variable. In fact, a variable’s data type can even change in Python, which is something that many other programming languages won’t allow. Technically speaking, we would say that Python uses strong typing, which means that each variable has a known data type that we can find, and dynamic typing, meaning that the type of the variable can change while the program is running.\nTo determine the type of a variable, we can use the type(expression) function in Python. We can simply place any variable or expression in the expression argument, and then it will tell us the type of the value that results from evaluating that expression. Then, we can simply use the print() function to print it to the screen. We won’t use this in our programs themselves, but it can be helpful for debugging purposes or to just better understand what is going on with data types.\nHere’s a quick example program showing the type() function in Python:\nx = \"Hello\" y = 5 z = 6.7 print(type(x)) print(type(y)) print(type(z)) When we execute this code in Python, we should see the following output:\n\u003cclass 'str'\u003e \u003cclass 'int'\u003e \u003cclass 'float'\u003e Based on that output, we can assume that the variable x is the str data type for strings, y is the int data type for whole numbers, and z is the float data type for decimal numbers. The type() function is pretty handy!\nConverting Between Data Types We can also convert values between the various data types in Python. To do this, there are special functions that match the name of the data types themselves, just like we saw in pseudocode. So, to convert any value to a string, we can use the str() function. Likewise, to convert anything to an integer, we can use the int() function. And finally, to convert anything to a floating-point value, we can use the float() function.\nSo, we can extend the previous example a bit by showing how we can convert values between different data types:\nx = \"5.7\" print(x) print(type(x)) print() y = float(x) print(y) print(type(y)) print() z = int(y) print(z) print(type(z)) When we run this program, we’ll get this output:\n5.7 \u003cclass 'str'\u003e 5.7 \u003cclass 'float'\u003e 5 \u003cclass 'int'\u003e In this program, we’re starting with the string value \"5.7\" stored in variable x. So, the first two print() statements will print that string value, and show that x is indeed storing a str data type. Then, we’ll use the float() function to convert the string value \"5.7\" stored in x to the floating-point value $5.7$ and store that in y. The next two print statements will print that value, and show that y is storing a float data type. Notice that the value printed for both variables x and y looks identical, but the data type of each variable is different!\nFinally, we can use the int() function to convert the floating-point value $5.7$ to an integer. In math, when we are asked to convert the number $5.7$ to a whole number, our first instinct is probably to just round up to $6$, since that is the closest value. However, in Python, as in most other programming languages, this function will simply truncate the value instead. Truncating a value simply means we take off the end of the value, so to convert $5.7$ to an integer we just remove the decimal portion, and we’re left with the value $5$. So, in the output above, we see that z stores the integer value $5$, and it is the int data type.\nNotice that we are careful to say that the int() function will truncate the value, and not that it will round down. This is due to how Python handles negative numbers like $-5.7$. When converting that to an integer, it will also truncate it to $-5$ instead of rounding down to $-6$. So, we use the word truncate as the best way to describe the int() function.\nExceptions Since we are running our Python programs on a real computer, we have to be a bit careful about how we use these functions. Specifically, if we try to convert a value to a different data type and Python can’t figure out how to do that, we’ll cause an exception to occur. An exception in programming is any error that happens when the computer tries to run our code.\nFor example, what if we try to convert the string value \"5.7\" directly to an int data type, as in this example:\na = \"5.7\" print(a) print(type(a)) print() b = int(a) print(b) print(type(b)) When we try to run this code in a file, such as the tutor.py file shown here, we’ll see this output printed on the terminal:\n5.7 \u003cclass 'str'\u003e Traceback (most recent call last): File \"tutor.py\", line 5, in \u003cmodule\u003e b = int(a) ValueError: invalid literal for int() with base 10: '5.7' Uh oh! That’s not good. In the output, we can see that we’ve caused a ValueError, which is an exception that happens when we try to use a value in an incorrect way. So, we’ll need to carefully look at our code to see if we can find and fix the error.\nThankfully, in the output, it will tell us that the error occurred on line 5 of the file tutor.py, so we can open that file and scroll to that line of code:\nb = int(a) This is where the error occurred. There are several ways we can fix it. The easiest would be to simply convert a to a floating-point value using the float() function instead.\nLearning how to find and fix these exceptions is a key part of learning how to program. We’ll inevitably run into a few exceptions as we start to build larger and more complex programs. In this course, most exceptions can be easily handled simply by working carefully through the code, but every once in a while we may run into an exception that is truly difficult to solve. That’s one of the important things to remember when learning how to program - it is sometimes much easier to cause an exception than it is to figure out how to fix it, and sometimes you may need to reach out for help to get past a particularly tricky exception. So, don’t be afraid to ask the instructors or TAs for help if you get stuck on an exception. Many times, it’s a great chance for you to learn some new programming skills.\n",
    "description": "",
    "tags": null,
    "title": "Integers \u0026 Floats",
    "uri": "/x-cis115-labs/4-math-operators/03-integers-floats/"
  },
  {
    "content": " Resources Slides Getting data from the user is one way we can store data in our programs. What if we want to create a procedure that produces a new data value? We can do that using a special statement called the return statement.\nIn a procedure, we can choose any expression to be the result of calling the procedure, which will allow us to use the procedure as part of an expression instead of a statement. To really understand how this works, let’s see it in action! Here’s an example of a complete pseudocode program with a procedure that returns a value:\nPROCEDURE mult_mod(value, multiply, modulo) { value \u003c- value * multiply value \u003c- value MOD modulo RETURN(value) } PROCEDURE main() { DISPLAY(\"Enter a value: \") text \u003c- INPUT() value \u003c- NUMBER(text) answer \u003c- mult_mod(value, 5, 3) DISPLAY(answer) } main() In the mult_mod() procedure, we see that the last line of code is RETURN(value). This line will end the procedure, and it will use the current value stored in the value variable as the return value from the procedure. Then, in the main() procedure, we see that the procedure call for mult_mod() is actually part of an assignment statement answer \u003c- mult_mod(value, 5, 3). So, when the mult_mod() procedure is called, it will perform its work and then produce a return value, which can then be stored in the answer variable in the main() procedure. In effect, we can now use a procedure call to compute a value, which is a very useful thing in our programs. Let’s work through a code trace using this code to see how it works.\nCode Trace Like always, we’ll start with the usual setup for our code trace as shown below.\nThe first few steps will simply find the procedures declared in the code. Once we reach the call to the main() procedure at the bottom, we should be at this state:\nSo, we’ll enter the main() procedure. Here, we print a prompt to the user, and then accept input using the INPUT() expression:\nIn this example, let’s assume the user inputs the number $7$ as input. So, we’ll update our code trace to show that string value being stored in the text variable:\nNext, we’ll need to convert that string value to a numerical value using the NUMBER() procedure, storing that result in the value variable:\nAt this point, we are ready to call the mult_mod() procedure. So, we’ll jump up to the first line of that procedure, and create a new set of variables that represent all of the parameters of the mult_mod() procedure, with values matching the arguments provided in the procedure call:\nThe first two steps of the mult_mod() procedure will multiply the value parameter by the multiply parameter, then find the modulo of that result and the modulo parameter. As it does so, it updates the value stored in the value variable. Once it is done, value should store the value $2$:\nNow we’ve reached the RETURN() statement. This statement will end the mult_mod() procedure, so for this example it is the last line of code. Inside of the RETURN() statement, we are choosing to return the value stored in the value variable. So, in our variables list, we’ll remove all of the variables from the mult_mod() procedure, but we’ll place a special variable there showing the value that is being returned from the procedure. In our code trace, we’ll just call that the RETURN variable:\nNow, back in the main() procedure, we can deal with the assignment statement on the current line. Here, we will take the value returned from the mult_mod() procedure, which we see as the RETURN variable, and store that value in the answer variable in main. Once we’ve done that, our code trace will look like this:\nNotice that the RETURN variable disappears once we’ve passed that line. The RETURN value is only used immediately after the procedure is called, to help evaluate the expression that it is a part of. Once that is done, the value is no longer needed.\nFinally, we can complete the program by printing the answer to the output:\nWe’ll reach the end of the main() procedure, and once we’ve moved back to the outer level of the code, we’ll see that there is no more work to be done. The full trace is shown in this animation:\nReturning values from a procedure is a really useful tool in programming. It allows us to create procedures that can perform a complex calculation for us, and then we can use those procedures in other expressions to perform even more complex calculations. It is all about finding ways to simplify our programs by creating small, repeatable pieces of code for each task.\n",
    "description": "",
    "tags": null,
    "title": "Return in Procedures",
    "uri": "/x-cis115-labs/5-input-strings/03-return-procedures/"
  },
  {
    "content": " Resources Slides The last new concept we’re going to introduce in this lab is the concept of parameters. We just learned how to create procedures in our code, but our current understanding of procedures has one very important flaw in it: a procedure will always do the same thing each time we call it! What if we want to write a procedure that performs the same operation, but uses different data each time? Wouldn’t that be useful?\nThankfully, we can do just that by introducing parameters into our procedures. A parameter is a special type of variable used in a procedure’s code. The value of the parameter is not given in the procedure itself - instead, it is provided when the procedure is called. When a value is given as part of a procedure call, we call it an argument. So, a procedure has parameters, and the value of those parameters is given by arguments that are part of the procedure call.\nCreating Procedures with Parameters To include parameters as part of a procedure, we simply list the names of the parameters in the parentheses after the procedure name. If we want to use more than one parameter, we can separate them using a comma ,. Here’s an example of a \"Hello World\" procedure that uses two parameters:\nPROCEDURE hello_world(first_name, last_name) { DISPLAY(\"Hello \") DISPLAY(first_name) DISPLAY(\" \") DISPLAY(last_name) } Inside of the procedure, we can use first_name and last_name just like any other variable. We can read the value stored in the variable by using it in an expression, and we can even change the value stored in the variable within the procedure itself using an assignment statement.\nCalling a Procedure with Arguments Now that we have a procedure that requires parameters, we need to call that procedure by providing arguments as part of the procedure call. To do that, we provide expressions that result in a value inside of the parentheses of a procedure call. Once again, multiple arguments are separated by commas.\nFor example, we can call the hello_world procedure by providing two arguments like this:\nhello_world(\"Willie\", \"Wildcat\") So, when this code is run on our “mental model” of a computer, we should receive the following output on the user interface:\nHello Willie Wildcat Let’s walk through a quick code trace to see exactly what happens when we call a procedure with arguments.\nCode Tracing a Procedure with Arguments First, let’s formalize the example above into a complete program:\nPROCEDURE hello_world(first_name, last_name) { DISPLAY(\"Hello \") DISPLAY(first_name) DISPLAY(\" \") DISPLAY(last_name) } PROCEDURE main() { hello_world(\"Willie\", \"Wildcat\") } main() To do that, we’ve placed our procedure call in a main procedure, and we’ve added a call to the main procedure at the end of our program. So, once again, we can set up our code trace structure to include our code and the various boxes we’ll use to keep track of everything:\nWe are already pretty familiar with how our “mental model” of a computer will scan through the whole program to find the procedures, so let’s skip ahead to the last line with the procedure call to main:\nOnce again, our computer will see that it is calling the main procedure, which it knows about. So, it will jump to the beginning of the main procedure and start from there:\nThis line contains another procedure call, this time to the hello_world procedure. However, when our “mental” computer looks up that procedure in its list of procedures, it notices that it requires a couple of parameters. So, our computer will also need to check that the procedure call includes a matching argument for each parameter. In our pseudocode language, each parameter must have a matching argument provided in the procedure call, or else the computer will not be able to run the program.\nThankfully, we see that there are two arguments provided, the values \"Willie\" and \"Wildcat\", which match the two parameters first_name and last_name. So, the procedure call is valid and we can jump to the beginning of the procedure.\nThis time, however, we’ll need to perform one extra step. When we call a procedure that includes parameters, we must also list the parameters as variables when we start the procedure. The value of those variables will be the matching argument that was provided as part of the procedure call. So, the parameter variable first_name will store the value \"Willie\", and the parameter variable last_name will store the value \"Wildcat\". Therefore, our code trace should really look like this when we start running the hello_world procedure:\nIn the future, we’ll show that as just one step in our code trace. Once we are in the hello_world procedure, we can simply walk through the code line by line and see what it does. At the end of the procedure, we’ll see that it has produced the expected output:\nAt this point, we will jump back to the main procedure. When we do this, there are a couple of other things that happen in our “mental model” of a computer:\nAny variables created in the hello_world procedure are removed. This includes any parameter variables. We’ll reset the code back to the original, removing any computed values and replacing them with the original expressions. So, after that step, our code trace should look like this:\nNow we are back in the main procedure, and the program will simply reach the end of that procedure, then jump back to the main procedure call and reach the end of the program. The full code trace is shown in the animation below:\nThat’s all there is to calling a procedure that uses parameters! We can easily work through it using the code tracing technique we learned earlier in this lab.\nnote-3 The definitions for parameter and argument given above are the correct ones. However, many programmers are not very precise about how they use these terms, so in practice you may see the terms parameter and argument used somewhat interchangeably.\nWe’ll do our best to use them correctly throughout this course, and we encourage you to be careful about how you use the terms and make sure you understand the difference.\n",
    "description": "",
    "tags": null,
    "title": "Parameters",
    "uri": "/x-cis115-labs/3-functions/03-parameters/"
  },
  {
    "content": " Resources Slides Now that we’ve been introduced to the DISPLAY(expression) statement, let’s write a few simple programs using that statement to see how it works. Again, we’re just learning how to run these programs using our “mental model” of a computer, so it is really important for us to closely pay attention to both the code and the output of these examples. We have to learn what rules govern how our computer should work, and the only way to do that is to explore lots of different programs and see what they do.\nExample 1 - Multiple Statements First, let’s write a simple program that prints 4 letters separated by spaces:\nDISPLAY(\"a b c d\") Just like our “Hello World” program, when we run this program, we’ll see that string printed in the user interface:\na b c d Ok, that makes sense based on what we’ve previously seen. The DISPLAY(expression) statement will simply display any string expression in our user interface.\nOf course, programs can consist of multiple statements or lines of code. So, what if we write a program that contains multiple DISPLAY(expression) statements, like this one:\nDISPLAY(\"one\") DISPLAY(\"two\") DISPLAY(\"three\") DISPLAY(\"four\") What do you think will happen when we try to execute this program on our “mental model?” Have we learned a rule that tells us what should happen yet? Recall on the previous page we learned that it will print the value on the user interface, but that’s it. So, when we execute this program, we’ll see the following output:\nonetwothreefour That’s a very interesting result! We might expect that four lines of code would produce four lines of output, but in fact they are all printed on the same line! This is very helpful, since we can use this to construct more complex sentences of output by using multiple DISPLAY(expression) statements.\nIf we want to add spaces between each line, we’ll need to include that in our expressions somehow. For example, we could rewrite the program like this:\nDISPLAY(\"one \") DISPLAY(\"two \") DISPLAY(\"three \") DISPLAY(\"four\") Notice that there is now a space inside of the quotation marks on the first three statements? That will result in this output:\none two three four There are many other ways we could accomplish this, but this is probably the simplest to learn.\nExample 2 - Multiple Lines What if we want to print output on multiple lines? How can we do that? In this case, we need to introduce a special symbol, the newline symbol. In our pseudocode, as in most programming languages, the newline symbol is represented by a backslash followed by the letter “n”, like \\n, in a string. When our user interface sees a newline symbol, it will move to the next line before printing the rest of the string. The newline symbol itself won’t appear in our output.\nFor example, we can update our previous program to contain newline symbols between each letter:\nDISPLAY(\"a\\nb\\nc\\nd\") This might be a bit difficult to read at first, but as we become more and more familiar with reading code, we’ll start to see special symbols like the newline symbol just like any other letter. For now, we’ll just have to read closely and make sure we are on the lookout for special symbols in our text.\nWhen we run this program in our “mental model” of a computer, we should see the following output on our user interface:\na b c d There we go! We’ve now figured out how to print text on multiple lines.\nExample 3 - Multiple Statements on Multiple Lines We can even extend this to multiple statements! For example, we can update another one of our previous programs to print each statement on a new line by simply adding a newline character to the end of each string:\nDISPLAY(\"one\\n\") DISPLAY(\"two\\n\") DISPLAY(\"three\\n\") DISPLAY(\"four\") When we execute this program, we’ll get the following output:\none two three four That’s pretty much all we need to know in order to use the DISPLAY(expression) statement to do all sorts of things in our programs!\nnote-1 In this course, we have already introduced one big difference between the AP CSP Pseudocode and our own pseudocode language. In the official CSP Exam Reference Sheet, the DISPLAY(expression) statement is explained as follows:\nDisplays the value of expression, followed by a space.\nBy that definition, each use of the DISPLAY(expression) statement will add a space to the output. So, programs like this:\nDISPLAY(\"one\") DISPLAY(\"two\") will produce nice, clean output like this:\none two We believe this is done to simplify the formatting for answers on the AP exams, which must be hand-written. By automatically including the space in the DISPLAY(expression) statement, it becomes easy to construct a single line of output consisting of multiple parts, and they will be spaced nicely.\nHowever, when trying to print output on multiple lines, the AP CSP Pseudocode does not provide a clear definition for how to accomplish that. For example, adding a newline symbol at the end of the line, like this:\nDISPLAY(\"one\\n\") DISPLAY(\"two\") will result in output with an awkward space at the beginning of the second line:\none two This could be resolved by adding the newline at the beginning of the next line, like so:\nDISPLAY(\"one\") DISPLAY(\"\\ntwo\") However, this is rarely done in real programming languages, since most languages have a display statement that adds a newline at the end by default, and most programmers are used to that convention. Therefore, we don’t feel that it is proper to teach this method, only to adjust later on to fit with a more proper style.\nLikewise, there is no way to use a DISPLAY(expression) statement without adding a space at the end, which is something that is very useful in many situations.\nTherefore, we’ve chosen to redefine the DISPLAY(expression) statement to not append a space at the end of the line. That aligns it with statements that are available in most common programming languages.\n",
    "description": "",
    "tags": null,
    "title": "Using Display",
    "uri": "/x-cis115-labs/2-print-variables/03-using-display/"
  },
  {
    "content": " Resources Slides Video Script So let’s take a look at some early attempts of artificial intelligence. So Alan Newell and Herbert Simon were a couple of early researchers in AI. In 1955, they wrote a program designed to mimic the problem solving skills of a human being, and called it the logic theorist. This program is now widely considered to be the first AI program, it was used to prove theorems in the book of Principia Mathematica, and actually created a much more elegant proof for some of the theorems than the author wrote for the book. At the time, interest was swirling around the growing idea of AI, and the experts decided to come together and discuss that topic at length. This is a conference that John McCarthy had wanted and successfully organized. There’s a lot of different types of AI that have been developed over the years. And there’s a lot of different methodologies behind them to make them artificially intelligent. But a lot of this deals with how we represent knowledge and information for the AI. So there’s a ton of information in the world, even something as simple as a smartwatch that’s detecting your heart rate and oxygen levels and things like that. It ends up being a lot of information over the course of a small period. And so how do we represent that knowledge in order for our AI to actually be able to consume it and make good rational decisions from it.\nThat also includes a search of that information, so how do we find and dig our way through all of that data, which includes expert systems. So a really good example of an expert system is Amazon. So it learns your shopping habits and recommends items to you. And that recommender system is really what tries to learn your likes, and dislikes, and what you might need to buy, or want to buy next. The ability to plan right? To set out a course between information between two points. Reasoning, machine learning, which we’ll talk about here in a little bit with neural networks, special topics like a natural language processing, so AI that can understand human speech, which for us is not as difficult, but for a machine and for a computer understanding human like speech, and producing human like speech is an incredibly difficult problem.\nSo to dive a bit deeper into the topic of AI, we’re going to look at the last tool mentioned called neural networks. In 1969, Marvin Minsky, one of the founders of MIT’s AI lab, wrote a book called perceptrons that laid the groundwork for this idea of a neural network. Now, what are neural networks? So the idea behind a neural network lies behind the power of individual neurons, and the connections between them. Each neuron is capable of doing a certain task, and then its output is passed on to other neurons. The strength of a neural network comes in the form of the connections between neurons. If one of them tends to give correct answers to a problem, other neurons will be more likely to use its output based on the strength of the connection between them. And the process of strengthening good connections and weakening bad ones is how neural networks are able to learn how to do particular tasks. And this is really kind of how we’re trying to simulate the human brain, right? We have in our brain, we have lots of neurons and synapses and those synapses, those connections are a representation of the knowledge and things that we actually learned throughout our life. And so how do we actually get a computer to imitate that particular idea? Now, neural networks have been out for quite some time. But more recently, this has been the idea behind deep learning. Deep learning works at a very basic level, expanding the network to have numerous different layers to actually learn from. Deep learning is very much like an artificial neural network, but lots and lots of different layers. And each layer may actually be a different learning algorithm that is producing that particular output.\nAn example of neural network is here about classifying camouflage tanks. So in this experiment, the researchers wanted to create a neural network that would classify pictures of tanks hiding in trees from pictures of just trees. So we have pictures of trees and pictures of tanks in trees. This was a really interesting problem for the government at the time, and it worked pretty well for the original photos. But when the researchers brought in a new set of photos to test it on, the results were no better than random. The reason behind this behavior is that the original photos that the AI were trained on, were taken all on sunny days for the tanks, all the pictures trees were taken on cloudy days. And so what they really built here was a machine that determined whether or not it was sunny or cloudy. And so this is really kind of a funny ending result here about an AI that did a really good job, right? It was given information and without information, it classified these pictures. And based off of the pictures themselves, the classification of sunny or not sunny became a lot easier or more prevalent than tank or no tank. And so this is a really good example of how AI is really only as smart as, currently, as smart as how we program it or what we tell it to do. And sometimes it ends up finding things out or doing things that we totally didn’t expect. And sometimes it turns out for the better.\nSo let’s take a better look at some other AI that is a little bit more modern, or a little bit more recent. So in 1997, so this is still pretty old, a little over 20 years old now, Deep Blue, a AI that was developed by IBM beat Garry Kasparov at chess. So Garry Kasparov was a world class chess player. This is a very big achievement at the time because chess again, like many other games can end up being far more complex than what you actually think. So IBM’s next AI venture was IBM’s Watson. Watson was a research project that started out in 2006. And its goal was to be able to learn from the internet. So basically be able to answer lots of questions based off of the information that it can actually scrape from the internet. So basically, Wikipedia type information, things that you search on Google, that sort of thing. A really huge achievement of IBM’s Watson was in 2011, beat Ken Jennings in Jeopardy, which Ken Jennings at the time, if you never watched Jeopardy, or haven’t watched Jeopardy for a while, Ken Jennings was one of the best players in jeopardy at the time. So after IBM’s Watson beat Jeopardy, IBM kind of repurposed the AI to start targeting things like the medical field. So being a computer that is able to answer or intelligently answer medical questions, also things like industrial questions. So it’s basically been in a continuous innovation project where it is basically an AI that is essentially better than your Google search. So not only does searching the internet for information, but actually coming up with this specific answer for the question.\nNow even more impressive, Google’s DeepMind project had this AI called AlphaGo. And in 2015, this was the first AI to ever beat a professional human player in Go. Go is a really ancient game that originated in China with a board with a bunch of squares on it, and the task here is to end up with the most colored stones on the board. So there’s white and black stones, and it’s kind of like reverse if you’ve ever played Reversi, but a lot more complex. AlphaGo continued its winning streak by defeating the world champion at Go in 2016. So this is a huge achievement, because again, right, this is the first AI to ever beat a human player in Go. But the real achievement here is that Go is an extremely complex game. It has 10 to the power of 170 possible board configurations. And so an AI that can actually play a game better than a human player at this, or professional at this, is really quite an achievement, because computationally wise it’s practically impossible to look at all board configurations instantaneously at any time for all the moves. So AlphaGo really started to train itself. How it works is it played variations of itself, millions upon millions upon millions of times, to start to learn different techniques and strategies to actually play Go. And AlphaGo was later expanded into an algorithm called alphaZero, which played games like chess and checkers. This is a little bit different than most algorithms or AI’s that play chess and checkers, where those just generates the possible game trees and choose the best move. But alpha zero is deep learning base, so it plays with a little bit more strategy instead of just looking five or six minutes ahead.\nNow we could talk on and on and on about the uses of AI and machine learning because it’s pretty much ubiquitous in our current life. But things like Microsoft Connect was a huge innovation that is able to track and map out a human skeleton so you can move and interact, right? This is kind of a big portion or big push into things like AI virtual or augmented reality. Things like Apple Siri or Amazon, Alexa or Cortana all are natural language processing AI applications. So AI that is able to understand and answer human speech questions which are really impressive and improve on it on a daily basis. Things like Wolfram Alpha. AI is pretty much everywhere right has so many interesting capabilities and applications and really have started to become integrated and ingrained in our daily life. ASIMO A S I M O Honda is another example of an attempt at artificial intelligence in this time in a very human like form, this has so many interesting capabilities. And they hope that one day can be used to assist humans in everyday life. Just like a lot of the smart home devices and things like that have started to integrate into our daily routines. The hope here is that we have robotic agents and AI that is able to further assist us in our daily tasks.\n",
    "description": "",
    "tags": null,
    "title": "AI Advancements",
    "uri": "/iii-topics/18-ai/06-ai-advancement/"
  },
  {
    "content": " Resources Slides Video Script The success for cracking the Enigma machine really comes down to the work of this man, Marian Rejewski. Marian Rejewski was a Polish mathematician who worked on the Enigma machine in the early days of the 1920s and 1930s. The Enigma machine was actually originally available as a corporate machine; you could go out and buy it as a corporation, and use it to encrypt and store data. And so it wasn’t until much later that was taken over by the German Nazi Party and used in their war efforts. And so public Enigma machines were available and could be studied. And so Marian Rejewski was able to study some of the early Enigma machines and try and predict the adaptations that Germany made as they move closer to war in the late 1920s and 30s. So based on his work, he was able to determine what the Germans were doing and was even able to eventually replicate some of the German machines that they had created. But of course, that was just part of the story. So to crack the Enigma machine, it was really first cracked by Marian Rejewski of Poland. He was able to use some of those publicly available Enigma machines to crack some of the earliest things that they did. By 1938, as Germany was getting closer to war, they added two new wheels of their own making it much much harder to crack if you didn’t know the wheels existed. And so Marian Rejewski of Poland contacted folks in England and gave them a lot of his research and ask them for assistance. And so by 1939, Alan Turing, working together with the folks at Bletchley Park, created what he called the Bombe, which was a machine that could decrypt the Enigma machine. And so work on the Bombe progressed pretty much throughout the entire war. And by 1945, almost every single message that the German sent using the Enigma machine, could be deciphered by the allies within two days. So what is the Bombe? The Bombe is a machine developed by Alan Turing to simulate hundreds of Enigma machines side by side. You can see that it has all of these sets of three wheels, simulating the three wheels that might be present in an Enigma machine. And it was designed to explore many of the weaknesses and other facts about the Enigma machine that were known to the Allies based on the work of Marian Rejewski and Alan Turing at that particular time. So let’s take a look at a quick video of a Bombe in action just to see what it looks like.\n",
    "description": "",
    "tags": null,
    "title": "Cracking Enigma",
    "uri": "/iii-topics/16-cryptography/06-cracking-enigma/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "How oldschool graphics work, part 2 - Apple and Atari",
    "uri": "/iii-topics/22-graphics-and-video-games/06-oldschool-ii/"
  },
  {
    "content": " Resources Slides Video Script One of the last things I want to talk about here with big data is some of the algorithms that we can actually use to work with this sheer amount of information. So one that I want to highlight here is called MapReduce. Oh, MapReduce is a very well known algorithm and big data realm. And now it’s been, of course, transformed significantly, since its original inception, inception, to handle even larger amounts of information. But the idea here is that we take a very large amount of information, let’s say text, and then we map it to smaller parts, break it out, and then we recombine that and to produce a final result. Okay. And so if you can use this as an example, right, if we’re trying to, let’s say, sort of deck of cards, okay, if I asked if I give you a whole bunch, or if I give you a full deck of cards that is completely shuffled, but I want you to sort it out in numerical order, as well as the suits would actually take you a little bit of time to actually achieve that task. But if I were allow it, if I gave you a deck of cards in a group, well, so let’s say I gave a group of 10 people, one single deck of cards, and I said, sort do the same thing, it will take them significantly less time than it will if I gave just one person a deck of cards to actually achieve that end result.\nSo that’s the idea of MapReduce, we partition our information out into very small parts. And then each of those small parts has the same task done to it. And once that task has been executed on the small parts, all of the end results are then combined to produce the final results. So let’s take a look at another example here with word count, which is pretty a real classic example of how MapReduce works. So our input here is a very simple section of texts. So a bunch of different words, dear bear, river, car, car, river, deer car bear. And so you can imagine this being a very large book or something like that. And we want to count the count the occurrences of each word in our in our data set. So first thing that we do here, let’s split this data out. So let’s say that each line of text here is our initial split. So deer, Bear River, car, car, river, and deer car bear. So we have these three, these three data sets that are that are our big data set has been split into these individual data sets. Where each the key value we have key value pair, where the key is this as a document, the value is the the text that we actually contain. So each of these documents here are then going to be mapped to a task. And our task here is to count the word occurrences.\nSo in this mapping task, I’m going to map each word to a number. So each word of course, and individualized is only going to occur once. So deer occurs once bear occurs once and river occurs once. The key here is going to be word and the value here is going to be of course, the word count. As you can see down here in this middle example, where we have two cars, that’s okay, because it’s individual tasks, remember, so each car is still going to be one key value pair here. Because the important part actually comes in the next step. And the next few steps here. So we’re actually going to shuffle this out on the shuffling process is going to take care of essentially sorting the result of our mapping process. Because once it’s actually sorted, it’s a lot easier to easier to actually reduce and combine. So when we actually shuffle all of the bears and get put in one bin, all the cars get put in one bin, all the deer get put in one bin and all of the rivers get put in one bin.\nAnd then all that happens here is actually the reducing so we actually combining one more step actually combining the information. So we sum the word counts. So bear occurred twice, Parker three, deer two and river two. So we’ve taken all of the individual words here, counted them and sort of the mount and summed them. And then the final reduce phase is we’ve combined this all back into a single list, where the key is the word and the value is the total word count over the entire day. To set. But you can imagine this to be significantly faster than having a one single process or one single out or one single computer doing this, we can use this on things like balcatta, a distributed computer system where we can throw a split the data set up and onto a lot of different processors and have each processor each thread actually execute the mapping, shuffling and reducing task. And then they all come in back together at the end to form the final results. But this is just one of the big data algorithms out there. There’s obviously a significant amount of other types of techniques and algorithms and tasks out there, that big data can actually accomplish. So we’ve just scratched the surface here. But if you’re interested in learning more, please reach out and we happy to actually connect to you with more resources.\n",
    "description": "",
    "tags": null,
    "title": "Map Reduce",
    "uri": "/iii-topics/20-big-data/06-map-reduce/"
  },
  {
    "content": "Lab 3 Functions ",
    "description": "",
    "tags": null,
    "title": "Functions",
    "uri": "/x-cis115-labs/3-functions/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Floating Point Numbers - Computerphile",
    "uri": "/i-concepts/07-encoding/06-float-point-computerphile/"
  },
  {
    "content": " Resources Slides Video Script Welcome back everyone. In this video we’re gonna be looking at JavaScript. But let’s look into some of the history behind it. To start, we’re going to talk about Brendan Eich. Brendan Eich was actually one of the people who co founded the Mozilla project to of course launching the major browser Firefox, but he’s also the creator of JavaScript. Eich had a master’s degree from the University of Illinois at Urbana Champaign, but then he started working at Silicon Graphics, working about seven years or so on an operating systems project, and primarily a lot of networking code. But he then started at Netscape in 1995. And when he joined Netscape, he really intended to put the language called scheme into the web browsers. Now, Netscape, of course is no longer prevalent in today’s internet world, but Netscape was really primarily one of the leading internet companies back in the mid to late 90s. But as Brendan started to work and putting scheme into the web browser, Netscape noted that his project actually resembled the Java syntax, and pushed really quickly after after that point. His project released a little over a week later, to accommodate Netscape Navigator 2. And so he was really pushed really time pressed underneath, and a lot of pressure to get this language actually released. And it actually underwent many different name changes during that time. One point it was called mocha, then LiveScript, and then eventually called JavaScript all in the same month. While it does resemble Java, JavaScript itself is actually an entirely different category of programming language. While Java is very object oriented JavaScript is more of a as as it sounds, right, more of a scripting programming language designed specifically for the web.\nNow, JavaScript, as I mentioned, originally called LiveScript at a time, was finally released in 1995, and has gone over multiple iterations since then, many and different important updates as we as we go along. But JavaScript was used to manipulate the Document Object Model after a page was actually loaded. So JavaScript was one of the first languages out there that allowed us to manipulate the webpage. After it was actually presented to the user. When HTML was first released, the page was served and loaded on the user’s web browser. And that was it. Nothing actually changed after the page was, was loaded. So if you wanted something to change, you’d have to be redirected or reloaded into an entirely different page or refresh the page to get that change to actually happen. JavaScript allows you to edit that page live, so the page doesn’t actually have to completely be reloaded in order for an interactive component to be utilized as part of the content. So this makes the webpage much more interactive, and much more entertaining overall, and much more useful for the user. And while it was mentioned by Netscape to be related, or looking like the Java programming language, it is completely unrelated. As far as the general structure and usage of and operation of the languages.\nJavaScript, while it does allow you to manipulate the Document Object Model behind the scenes, it can be a little bit cumbersome, and it had its limitations. And so that’s when jQuery was released in 2006. jQuery is a cross platform JavaScript library that made it a lot easier to manipulate and edit the DOM elements. So JavaScript caught a lot of flack because it was kind of difficult to use and very clunky. And if you wanted to do anything fancy, there’s a lot of code. And overall, it really just wasn’t that user friendly. So jQuery made a leak to try to make this process a lot easier for developers to get the results that they wanted in much cleaner and shorter amount of code. So JavaScript and jQuery in general, what you’ll see as you start using, it has a lot of different plugins and a lot of different frameworks. So very rarely anymore. Will you see a web page that uses JavaScript purely in its raw form, majority of web pages anymore are going to utilize some form of framework or external library to actually work and get the end functionality that they want. But we’ll talk more about this later.\n",
    "description": "",
    "tags": null,
    "title": "Javascript",
    "uri": "/ii-internet/13-webprog/06-javascript/"
  },
  {
    "content": " Resources Slides Video Script J. C. R. Licklider his idea inspired him to write a paper in 1962 titled Man Computer Symbiosis. And in that paper, he had this quote, that he foresaw a network of such computers connected to one another by wideband communication lines, which could provide the functions of present day libraries together with anticipated advances in information storage and retrieval, and other symbiotic functions. And while there’s a lot of words here, he’s really thinking about building computer connections where computers can store libraries worth of information that we can access at our fingertips.\nAnd so a few years later, he started talking with his colleagues. And he came up with this idea of what he called the intergalactic computer network, which I really admit I wish we called the internet the intergalactic computer network, I think is a really catchy idea. But he envisioned this idea of a global network of computers all interconnected and accessible to each other. And so you can easily ask access data from data and programs from any of those computers on any other computer. And he actually even submitted a memorandum called a memorandum for members and affiliates of the intergalactic computer network to encourage people to participate in this new idea. And while this never really came to be, this idea of forms the basis of a lot of the internet and cloud computing resources that we use today in our daily lives.\nAnother major figure in the history of the internet is Leonard Kleinrock. Leonard Kleinrock was a major figure in the history of the internet and was a researcher at UCLA. And he helped develop the technology behind packet switched networking, which we will take a look at in the next lecture. And it was really developed and proposed to the government as a way to build computer systems that were very fault tolerant in case of an attack or an emergency. His work was really revolutionary. And there’s actually a great video of Leonard Kleinrock himself discussing the importance of his work at UCLA in the early days of these computer networks. So let’s take a look at that video.\n",
    "description": "",
    "tags": null,
    "title": "Part 2",
    "uri": "/ii-internet/11-internethistory/06-part2/"
  },
  {
    "content": " Resources Slides Video Script Let’s spend a little bit more time looking at modern computer hardware and talking about some of the things that are related to what we’ve already discussed in this lab. On our modern CPUs, one of the things we have to keep in mind is the instruction set architecture or ISA, that is built around the ISA determines how the CPU actually interprets the binary ones and zeros in the program code and turns that into instructions that it can follow to perform the calculations needed. One of the most common instruction set architectures is the x86 in ISA, a that was developed all the way back in the 1980s as part of the IBM compatible computers. And for about 20 or 30 years, almost every computer supported the x86 ISA or something very similar. In the mid 2000s, we had the development of 64 bit architectures such as x86, IA-64, and some other architecture sets, and so most modern computer processors today use some variant of a 64 bit operating system and a 64 bit ISA.\nThere are of course, some other instruction set architectures that are built for various types. For example, most mobile phones and small devices such as Raspberry Pi’s use the arm instruction set architecture, which is a very different is a very much focused on low power devices. Macintosh used to use power PC, and in fact, they’ve recently announced that they’re planning on moving to the ARM-ISA very soon. And then of course, for smaller embedded systems there are things such as the MIPS-ISA, which is really good for small embedded chips and circuits.\nOf course, every modern computer also includes a motherboard. A motherboard is the main chip that connects all the other devices of the system together. This slide shows some of the other parts of a modern computer motherboard, such as the CPU socket, memory slots, the northbridge and southbridge chips also today, just known as the chipsets. The on board graphics processor and sound card and some of the expansion slots where you can plug in things such as your larger graphics card or a sound card or anything else that you might have. Let’s talk a bit more about the hardware you might find in a modern computer system.\nThe first part we should talk about is the central processing unit or CPU. This is what actually does all of the computation and calculation on your computer and is basically the brains of the operation. CPUs have a lot of different features you can look at such as the architecture or instruction set architecture that they use, the clock speed, that they have, the number of cache memory chips that they use, and the number of processing cores that are available. And central processing units come in a variety of styles and a variety of costs. And they’re all basically the brains of your computer.\nThe next piece we can talk about is the memory usually referred to as the ram or random access memory. This is the memory that your computer uses to store the program it’s running and the data that is currently operating on the ram can also vary based on the size and the speed at which you can access data. There’s also different types and classes of memory. And they’re even advanced features such as registered in ECC memory, which does error correction.\nBeyond that, you could also have the storage devices such as your hard drive or solid state drive. These are for more long term storage of data even while the computer is turned off. They can vary based on the capacity of the drive, the interface that it connects to your computer with, and even things such as the speed that it can read and write data. For some drives. We also worry about the latency or how long it takes to get that first piece of data off of the drive once we request it. There are also more advanced things you can do with your hard drives such as create a raid raids allow you to get better performance or better security by mixing multiple drives together.\nAnd there’s so much more we could talk about CD drives or optical disk drives. We could talk about graphics cards, sound cards, wireless cards, network cards, all sorts of peripherals that go on your computer. So I think encourage you to take a look at the computer that you’re using right now to watch this video and think about all the different parts that make up that computer and how they look in your system.\n",
    "description": "",
    "tags": null,
    "title": "Parts of a Computer",
    "uri": "/i-concepts/08-architecture/07-computer-parts/"
  },
  {
    "content": " Resources Slides Video Script The next algorithm we’re going to look at is merge sort. Merge Sort is a very unique algorithm because it’s an example of the divide and conquer paradigm of creating algorithms. In fact, Merge Sort was actually written way back in the 1950s and 60s to allow us the ability to sort data that didn’t even fit on a single data storage media at the time. So for example, with merge sort, we could sort the data on three different disks full of data very independently and very efficiently. The process for merge sort is pretty simple. We start by taking our data and splitting it in half, and we keep repeatedly splitting it in half until we get down to one or two items. Then we make sure those items are in order, and then we will merge those two items together all the way down until we get to our final results. So let’s take a look at how we can perform Merge Sort using our deck of cards. The next sorting algorithm we’ll look at is merge sorts. Remember that merge sort is a divided conquer algorithm. So it takes place in two phases. The first phase is the divide phase.\nSo we’ll start with our set of 10 cards, and we need to divide it in half. So we’ll have one group of five cards over here. And we’ll have one group of five cards over here. Then we’ll repeat that process for each group. So we’ll look at this group, and we’ll divide it in half, we’ll have a set of three cards, and a set of two cards. Likewise, here, we will have a set of three cards, and a set of two cards. And finally, these groups of three can be divided once again into a set of two and a set of one. And likewise here, we’ll have a set of two and a set of one. So now we’ve divided all of our groups into sets that are at least two cards or smaller. The next phase is to actually sort each of these individual groups by swapping the cards If needed, so let’s look at each group, the two and the four are out of order. And so we will swap them. So the two comes before the four. Since 10 only has one card, we don’t do anything, the six and the nine are in the correct order, as are the three in the seven, the eight is all by itself, so we don’t need to swap anything. And finally, the five and the ace are also out of order, so we will swap them.\nSo in total, we only did two swaps, we only had to swap two of the possible four pairs of cards that we could swap, but that’s all we really have to do. The last part of merge sort the conquer phase is where we merge all of these groups back together in sorted order. To do that, we pick two groups. And usually we just go down the row and we merge them back together by choosing the smallest card at the front of the group and putting it back in the destination. So with these two groups, we know that the two is the smallest. So it will go down first, then the four, then the 10. Likewise, we have this group over here, we know the three is the smallest, followed by the seven, followed by the eight. So now we have undone the division step that divided these into smaller bits. Now we’ll do the merge step where we merge these two groups together, and these two groups together. So once again, we will look at the front card in each of our two and see which one’s smaller. In this case, it’s the two. So the two goes first, followed by the four than the six than the nine, and finally the 10.\nAnd so you can see that actually, a lot of the sorting happens in this merge phase more than anything else. Likewise, we can do the merge phase over here, where the ace will come first than the three, then the five, then the seven, and the eight. So we’re almost there, we have one more set of merging that we need to do. And so once again, we’ll look at the front card and each one, and we will see which one is smaller and merge it first, so the ace is smaller, so it will go first, followed by the two, then we’ll have the three. Now we’re looking at the four and the five, we take the four, the five and the six, we would take the five. Likewise, we would take the six before the seven than the seven before the nine, the eight before the nine. And then finally, the nine and the 10. Go here at the end.\nAnd so that’s how we perform merge sorts. We divide everything out, we swap if needed, and then we conquer by doing that merge step to merge everything back together. And as we merge, we find that that’s where a lot of the sorting happens by putting things back together using the front element, whichever is smaller until we get into sorted order. So once again, see if you can do merge sort on your own using Your own deck of cards and keep track of how many swaps you make and how many times you have to merge things back together. And we’ll use that in our analysis in a later video.\n",
    "description": "",
    "tags": null,
    "title": "Merge Sort",
    "uri": "/i-concepts/06-algorithms/07-merge-sort/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 8 - Databases\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 8 - Databases",
    "uri": "/iii-topics/19-search-info/06-9algs-ch8/"
  },
  {
    "content": " Resources Slides Video Script So what really is a universal computer? We’ve thrown that term around a little bit. We’ve also talked about what it means to be a truly general purpose computer or reprogrammable computer compared to a fixed program computer like what the original Difference Engine was. So, this is what made the ENIAC so unique as well as the mark one, although to a lesser extent. is the fact that they are considered the world’s first true universal computers. So what do you think it means to be called a universal computer? Well, a universal computer can simulate any real world computer given infinite time and infinite memory. So if you imagine taking your cell phone or even something as small as like the little Raspberry Pi or a smartwatch. And if it was truly a universal computer, if you gave it enough time and enough memory, it could pretty much do anything any other computer could do. So compare that to some supercomputer right like Beocat that we have in the computer science department here at K-State. Right, a universal computer can do anything that Beocat can do, given enough time and give it given enough space.\nSo this brings us to Alan Turing. Now, Alan Turing was one of the first people to come up with this idea of a truly universal computer. Now, in 1936, he proposed this idea of an imaginary computer, and this imaginary computer was so simple, it was like it couldn’t do anything right. And actually Alan Turing was mocked quite extensive. Simply for coming up with this idea because people thought it was just crazy that it wouldn’t work. But now we know this imaginary computer to be known as the Turing machine. But in reality, this Turing machine, this simple machine that he kind of came up with, was able to do and calculate any value that could be done by any other computer, even though it was crazy simple. So let’s take a look at an example of what a Turing machine might look like right because it was an imaginary computer an imaginary machine.\nSo a Turing machine itself consisted of a an infinitely long tape, and this tape is divided. It has individual squares on it, just kind of like a roll of film wood and a classic non digital camera anyways, but each individual square you could would be either a one or a zero or it could be blank if it hadn’t had any data written to it yet. Now the machine actually works by moving back and forth along the tape and reading and writing ones and zeros depending on the value that actually reads out from the tape. But how does it actually know where to go? Well, if you can see here in the picture, there’s this little controller in the system as well.\nNow this controller would have had a program pre loaded onto it. And so we could write this program using these commands here and it’s relatively simple, right? We have eight different commands right, move left, and move right, right one, right, zero, read. So the read is if this square is zero, or if this square is one, go to Step x in the program. And then we also have just a straight, go to Step whatever, and stop. So the program itself right could only consist of these eight steps and here in another video, we’ll take a look at an example of these eight steps in action. But it’s really important to emphasize how cool this actually is right? The simplicity of these eight basic steps represent a universal computer. And this universal computer right is just a can accomplish just as much as something a supercomputer could do like Beocat. So, given enough time, and memory, a Turring machine with these eight basic steps, and only reading and writing ones and zeros could accomplish any problem.\n",
    "description": "",
    "tags": null,
    "title": "What ARE Universal Computers?",
    "uri": "/i-concepts/05-universal-computers/06-what-are-universal-computers/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 2.\n“The Pattern on the Stone: The Simple Ideas that Make Computers Work” by W. Daniel Hillis. ISBN 046502596X, newer version is also available and will work fine\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/08-pots-reading/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 3.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/04-programming/10-pots-reading/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Software Engineering (Crash Course)",
    "uri": "/i-concepts/09-software-engineering/06-se-crash-course/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Microsoft Bob Experience: Was It Really THAT Bad?",
    "uri": "/i-concepts/10-hci/06-ms-bob/"
  },
  {
    "content": " Resources Slides K-State IT Help Desk - Email helpdesk@ksu.edu K-State Online Canvas Help Instructure Canvas Guides Codio Documentation Codio Support K-State Libraries K-State CS Support K-State CS Advising K-State Engineering Student Services K-State Office of Student Life K-State Report It Video Script [Slide 1]\nAs you work on the materials in this course, you may run into questions or problems and need assistance. This video reviews the various types of help available to you in this course.\n[Slide 2]\nFirst and foremost, anytime you have a questions or need assistance in the Computational Core program, please email the appropriate help group. It is the best place to go to get help with anything related to this program, from the tutorials and projects to issues with Codio and Canvas. For example, if you are enrolled in CC315 and have questions, from your KSU email, you would type cc315-help and hit tab to auto-complete the email.\n[Slide 3]\nIf you have any issues working with K-State Canvas, K-State IT resources, or any other technology related to the delivery of the course, your first source of help is the K-State IT Helpdesk. They can easily be reached via email at helpdesk@ksu.edu. Beyond them, there are many online resources for using Canvas, all of which are linked in the resources section below the video.\n[Slide 4]\nIf you have any issues using the Codio platform, you are welcome to refer to their online documentation. Their support staff offers a quick and easy chat interface where you can ask questions and get feedback within a few minutes.\n[Slide 5]\nIf you have issues with the technical content of the course, specifically related to completing the tutorials and projects, there are several resources available to you. First and foremost, make sure you consult the vast amount of material available in the course modules, including the links to resources. Usually, most answers you need can be found there.\nOf course, as another step you can always exercise your information-gathering skills and use online search tools such as Google to answer your question. While you are not allowed to search online for direct solutions to assignments or projects, you are more than welcome to use Google to access programming resources such as StackOverflow, language documentation, and other tutorials. I can definitely assure you that programmers working in industry are often using Google and other online resources to solve problems, so there is no reason why you shouldn’t start building that skill now.\n[Slide 6]\nNext, we have grading and administrative issues. This could include problems or mistakes in the grade you received on a project, missing course resources, or any concerns you have regarding the course and the conduct of instructors and your peers. Since this is an online course, you’ll be interacting with us on a variety of online platforms, and sometimes things happen that are inappropriate or offensive. There are lots of resources at K-State to help you with those situations. First and foremost, please email your instructor as soon as possible and let them know about your concern, if it is appropriate for them to be involved. If not, or if you’d rather talk with someone other than your instructor about your issue, I encourage you to contact either your academic advisor, the CS department staff, College of Engineering Student Services, or the K-State Office of Student Life. Finally, if you have any concerns that you feel should be reported to K-State, you can do so at https://www.k-state.edu/report/. That site also has links to a large number of resources at K-State that you can use when you need help.\n[Slide 7]\nFinally, if you find any errors or omissions in the course content, or have suggestions for additional resources to include in the course, email the instructors. There are some extra credit points available for helping to improve the course, so be on the lookout for anything that you feel could be changed or improved.\n[Slide 8]\nSo, in summary, the content and links in the modules should always be your first stop when you have a question or run into a problem. For issues with Canvas or Codio, you are also welcome to refer directly to the resources for those platforms. For questions specifically related to the projects, use the courses help group. For grading questions and errors in the course content or any other issues, please email the instructors for assistance.\nOur goal in this program is to make sure that you have the resources available to you to be successful. Please don’t be afraid to take advantage of them and ask questions whenever you want.\n",
    "description": "",
    "tags": null,
    "title": "Where to Find Help",
    "uri": "/00-introduction/03-where-to-find-help/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "AI in Healthcare",
    "uri": "/iii-topics/18-ai/07-ai-healthcare/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Video Game History",
    "uri": "/iii-topics/22-graphics-and-video-games/07-vg-history/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Bombe Demonstration at Bletchley Park",
    "uri": "/iii-topics/16-cryptography/07-bombe/"
  },
  {
    "content": " Resources Slides Video Script So far, we’ve looked at the parts of a modern computer all the way from the integrated circuit to the CPU and RAM that we have in our modern computers. But we still haven’t talked about how we can use those computers to represent real world systems and actually do something useful. To do that, we have to look at one more thing from computer science called the finite state machine. a finite state machine is a theoretical device that has a limited number of states. And those states can be changed based on the transitions that we get based on some inputs.\nFor example, take a look at the finite state machine diagram on this slide. Do you recognize it? This diagram shows what we might see if we mirrored a door as a finite state machine. A door has two states open and closed and it has two transitions the closed door state which allows us to take an open door and make it closed and the open door state which takes a closed door and makes it opened So obviously, we can use finite state machines to represent all sorts of different real world ideas, like the ones on this slide. This slide lists a few different things that you might come in contact with during your daily lives. And all of these things can be represented using finite state machines if we think about them in just the right way.\nSo let’s go through an example of what it would take to create a finite state machine diagram for one of these devices. The one that I like to do is the one for a stoplight. So let’s take a look at that. Imagine for example that we have a crossroads where two roads meet and there’s a stoplight that helps control traffic that comes to this crossroad. We can represent a finite state machine of a stoplight by thinking about the states that are stoplight could have most stoplights we know today have three states, a red states, a green state and a yellow state. So a modern stoplight will start at the red state and then it will go to the green states. Then after a certain time, it will go to yellow. And then finally, it will go back to red. That’s a pretty simple finite state machine, but it does help explain exactly how a stop light works. Of course, this is just for a single stoplight. at a crossroads like what shown here, we probably actually have two stoplights that are working in tandem to control both directions. So that might be represented by a few more states.\nFor example, let’s say both stoplight start out initially as red. Then one stoplight switches to green and allows traffic to pass in that direction. After a certain amount of time that stoplight will go to yellow, and then we will go back to red red. However, notice that this state is different than the previous red red state because now we’re going to go to green red Then of course, we go to yellow red. And finally, this state will go back to red, red. So now we’ve gone from three states to six states to represent a two direction stoplight.\nBut of course, there’s more to it than that. For example, let’s say that this green light would be on the main highway, we don’t want to always interrupt that traffic flow if there’s nobody waiting. So we might have another state here, that is a wait state, we get to red green. And then we wait until we get some sort of sensor input saying there’s a car on the other road that needs to pass. Then we could switch to yellow and red, and then switch the other road to green for a little bit to allow that car to pass. And of course, we could also have stoplight states. And so for example, green, we might still need to have the stoplight, say walk and then flash. And then don’t walk before we get to the yellow states. And then of course, we can have buttons for the stoplights. We can have buttons for the crosswalks, there could be a lot of different things going on here that are all different states that we have to model within our finite state machine.\nSo as you can see, even a simple stoplight controller with two directions could have as many as 10 or 15 unique states that describe how it works. This is the real power of a finite state machine. It allows us to easily describe how real world devices work. And then we can build computer programs to represent the states and transitions of that device and run it on a computer simulation. So if you want to follow along, see if you can do one of these or two of these as an example by creating a finite state machine diagram yourself. I think you’ll find it to be a very valuable exercise and understanding exactly how a finite state machine works.\n",
    "description": "",
    "tags": null,
    "title": "Finite State Machines",
    "uri": "/i-concepts/08-architecture/08-finite-state-machines/"
  },
  {
    "content": " Resources Slides Video Script So now that we understand how to encode numbers into binary, let’s look at some other data types and see how those work. The nice thing is in the computer, everything is really just a binary number. It’s all ones and zeros. So we really just have to find a way to take other types of data and convert them into numbers. And then we can store those numbers in our computer and use them in our computer programs.\nSo for example, to store text in a computer program, we can use an encoding that converts each character of the text to a number and then store that number. The code that we use today is ASCII, or the American Standard Code for Information Interchange. And on this table, we see the first 127 characters of the ASCII code. In modern computers we use a more advanced code called Unicode that allows us to show many more characters, but it’s all based off of ASCII and in most of our computer programs will just work with simple ASCII text in most cases. So for example, The letter K is the decimal value of 75. On this table, we can see that here in this third column, we can also see all of the numbers and symbols. And we also have this whole first column of various different control characters. And these were really important in older computers where the control characters would tell the system things to do. For example, we have special characters for, for shift in shift out for end of text or end of transmission for cancel, substitute. And there’s even a particular symbol number seven that will play a bell or a sound. And it’s actually fun, you can still do that today. In most modern systems, you can send a character seven and it will ding on a terminal.\nSo to store text in ASCII, we would simply store a whole string of binary digits such as this, then to actually calculate what this is, we would break this binary digits up into eight bits. So we have 1,2,3,4,5,6,7,8. We would draw a line right here. We would draw a line right here. And so on every eight characters, we can draw a line. And so then we take each of those blocks of eight characters, and we convert them into their decimal value. So for example, 01100110, we can convert that to a decimal value, which is 102. And then on this previous slide, we can look that value up. So the value 102 is the lowercase character F. So back on the slide, we know that the value 102 is equal to character F. Likewise, we can continue to do this and find out what each character value is for all of these binary numbers. But on the slide, we’ve already done it for you. And actually, it’s really interesting. You can see that this slide uses ASCII text to encode the value 42 in words using those characters from ASCII.\nSo what about images, a lot of our computer Programs today make use of images. And of course, with the internet and video games and all the technology that we use images are a really important thing to be able to store on our computer. And it turns out there are actually two different types of ways that we can store images on our computer. The first way is a vector image, which uses mathematics to actually describe the shape and the lines and the colors within the image itself. Or we can create what’s called a bitmap or a raster image, which actually stores individual pixel pixels within the image itself. So what’s the vector image look like? It could look something like this. Most computers today support the vector image format, SVG, or Scalable Vector graphics. And a scalable vector graphics image is simply a list of mathematical equations. They’re used to draw the lines and the shapes and fill in all the colors of the image. And you’ll see these SVG graphics used a lot in logos and marketing materials, things that need to be printed very large or very small. For example, here at K-State, there is a scalable Vector Graphics version of the K state power cat as well as a lot of the K-State logos. So they can be printed as small as on a business card or as large as on the size of the stadium without looking pixelated. And that’s the big power of vector graphics is they can be shrunk or expanded as much as you want. And all of the graphics will seem perfectly smooth, because they’re mathematically defined. However, creating a scalable vector graphics such as that takes a lot of work. There is some very special tools. And it’s not like you can just go out and take a picture of something and easily convert it to a vector graphic, you really have to draw it from scratch or spend a lot of time recreating it to get that vector graphic.\nThe other way that we can store graphics in our computer is through a bitmap. And so a bitmap is simply a list of pixels, and each pixel is assigned a color. So this is a bitmap of an old sprite from a video game, just to give us a really quick blown up example of what a bitmap might look like. So how would we store an image like this in our computer? Well, it comes down to the concept colors. From color theory and art, we know that all the colors in the world are made up of three colors red, green, and blue. And so we can mix and match different intensities of those colors to produce any color that we need in the palette. And this is the key behind paint mixing. If you’ve ever mixed paints, you know that you can get any color by mixing two different paints together at various levels, or maybe all three paints to get the particular color you want. For example, K-State purple is a mix of a lot of red, a lot of blue and not very much green. So that bitmap if we actually render it out as this is hexadecimal values, if we render it as hexadecimal values, we would get something that looks like this. And so these values, each pair of two digits represents a particular color, we have red, green, and blue, and in this case, they should be inverted. So we have blue, green, and red. So if we overlay that data on top of the bitmap itself, you can see that each particular Color is represented by its own value. And so these values in hexadecimal are just binary numbers that have been simplified a little bit so they’re easier to read. And so for example, the squares that are dark red are 18009 B. So it means one a, there’s very little blue 00 means there’s no green, and nine beams, there’s a lot of red in that color. Likewise, we have colors of yellow, and orange, and then we have black as well. So of course, the store this bitmap does take quite a lot of value. Each one of these numbers requires 32 bits of data to actually store them.\nBut in old computer systems, especially early video game systems, we didn’t have nearly enough memory to do this. And so one of the tricks you can use with bitmaps is you can replace those colors with very simple numbers, and then provide a lookup table that says What color is what. And so here we’ve replaced these colors with four different numbers 000110 and one one and then somewhere else, we can to store a color table that says 00 is this color one, one is this color, etc. And in fact, some of the early video games use this very technique. If you go back and play the earliest Super Mario video game, you’ll notice that the clouds and the bushes and some of the enemies have different color palettes applied to them. And what they’ve actually done is they’ve taken the same bitmap image and just change the color key that goes with it to convert them from clouds that are white to bushes that are green and converted different colors of enemies from Red koopas to yellow koopas all of the different colors through this little trick.\nThe last topic we’ll talk about in encoding is the idea of compression. One of the big things in computer science is taking large amounts of data and storing them in smaller spaces. Because as it turns out, storing data can be very expensive. And with the rise of the Internet, we found that transmitting that data can also be very expensive. So we need to look for ways that we can compress data and store it in a smaller number of bits than we would normally So let’s look at an example of something that has some repetitive data in it. For example, how much wood could a woodchuck chuck if a woodchuck could chuck wood? This example of a tongue twister has a lot of repeated data. So what if we took some of those words and replace them with shorter things such as numbers. So if the word wood was replaced with one and could was replaced with two and Chuck was replaced with three, then we’d end up with a sentence that looks like how much one two a 1 3 3. If a 13 2 3 1, it is quite a bit shorter. We’ve noticed that by storing that key of those words, we can replace those longer words with shorter values, and we take up much less space. This is the concept behind a lot of computer compression algorithms. You find repeated chunks of data that show up multiple times in the code. And then you replace those repeated chunks with smaller representations and maybe have some sort of a lookup table that says how to expand those representations. And that’s really it. And so everything from zip compression to things like JPEG for images, are based on some of these similar ideas.\nUnfortunately, image compression can become really tricky. This is a really great case study, and we’ll link to this later on in this module. But Xerox copiers used an image compression algorithm that would look through the image and it would try and find parts of the image that it could replace with other parts. So here we have this first image. This is the original image of a printout of an accounting documents. Then here, we have a photocopy of that document made on a non Xerox copier back in the day. And then we have a photocopy of that document made on a Xerox photocopier that had this particular error. Can you spot the problem? So what Xerox was doing is it was looking at the image and it was trying to find things that were very similar. And then it would store only one copy of that image and replace the rest of it with identifiers that say, Oh, this chunk of the image should be this and what they noticed is this Right here, and this eight right here looked very similar. And so as some photocopiers It was no problem. But with Xerox photocopiers, you see that, oh, that six accidentally got replaced with this eight. And so in fact, here, there were a couple of sixes, they got replaced with eights. Although, interestingly enough, this one didn’t. And that shows some of the imperfection of these image processing algorithms that were being used at the time. And so this is a really interesting case study in how image compression can go awry. And it can cause really strange things like your accounting documents to have incorrect values, even though it’s a photocopy and you would think this doesn’t happen. So if you’re interested in this, I encourage you to read more. The case study is really fascinating about how they went through and figured out this issue and what was going on.\n",
    "description": "",
    "tags": null,
    "title": "Other Data Types",
    "uri": "/i-concepts/07-encoding/07-other-types/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The first Internet connection, with UCLA's Leonard Kleinrock",
    "uri": "/ii-internet/11-internethistory/07-first-connection/"
  },
  {
    "content": " Resources Slides Video Script One person who’s very active in the field of HCI today is Don Norman. Don Norman was a 2006 Franklin medalist. And he’s really famous for writing a book called The Design of Everyday Things, which if you haven’t taken a look at it, I encourage you to at least look at the front cover of that book and see what he’s talking about. Don Norman is a real big proponent of designing things to be how they’re expected to be used instead of design just to be interesting. And he talks about some really great examples of designing for everyday things. And so after this video, we’ll take a look at a short clip of Don Norman talking about some of his work, and hopefully, you’ll start to see the things that he saw in the real world that helped us understand modern design.\nSo one of the important things to remember in HCI is that iterative design process and designs change over time. For example, on this slide, the top picture is a picture of Microsoft Word from version two 2003. And the bottom picture is from a much more modern version of word that we use today. In 2003, the version at the top was very well regarded, it had a toolbar with lots of easy to follow buttons. And a lot of people got used to it and really liked it. And so in 2007, when they switched from the toolbar design to the ribbon design that we use today, there were a lot of users that really didn’t like that design. And if you get down to it, it really turns out that those users didn’t like the design, not because it wasn’t a better design. They didn’t like it because it was different. And so one of the things we’ve struggled with in the field of computer science is design changes for change sake is not good, because a lot of users don’t like change. But if we change things for the better, eventually users will get used to it. And thankfully, we’ve seen over time that users have very much gotten used to the new ribbon style and they do understand that it is much more efficient and much easier to use than the old toolbar style, but there’s always still little bit of fear of change that always comes into this.\nAnother good example of this is Windows, we’ve gone from Windows XP to Windows 7 to Windows 8 to Windows 10. And each time we’ve changed a little bits of how the Windows computer system works from different toolbar designs, two different Start Menu designs, two different designs for things such as the control panel and touch interfaces. And each one of those designs might be based on a lot of really good research, but it’s changed and a lot of users are very resistant to change at first. But of course, some changes are really good. For example, in Windows XP, if you had a blue screen, you would get something that looks like this. This error message isn’t really all that helpful is it? It’s got a lot of technical details. But for most normal users, it just scares them and they don’t really know what to understand. And so a more modern computer system has a little bit friendlier, have an error message that tells you what’s happening and it tells you what’s going on but it doesn’t just bombard you with more data than you actually need.\nSo what is the future of HCI look like? It’s really hard to tell, but there are tons of things going on. After this video, we’ll post several videos for different views of HCI. And some of the things that have been out there in research or in industry today, for example, different user interface concepts such as 10 GUI, different ideas around ubiquitous computing, such as the Google Glass project from a few years ago. We can look at 3d tools today, such as the Oculus Rift, and some of the new 3d virtual reality tools. And we can even talk about accessibility and how we can design computer systems that use just a single finger to allow you to type text very, very fast with a minimal amount of inputs. And so I hope by looking at some of these videos, you’ll be inspired by the different ways that computer systems can be interacted with beyond just the keyboard and mouse that we’re used to today, and it will encourage you to think about different ways that we can build computer systems in the future.\n",
    "description": "",
    "tags": null,
    "title": "The Future",
    "uri": "/i-concepts/10-hci/07-the-future/"
  },
  {
    "content": " JQuery Script Tag In some older videos, the JQuery script tag is shown using http in the URL. This should be changed to https in order to work correctly due to some recent browser security updates. Alternatively, you can always find the correct JQuery script tag by visiting https://releases.jquery.com/ and clicking the “uncompressed” link next to the latest version of JQuery.\nResources Slides Video Script Welcome back everyone. In this video, we’re going to start making our Tic Tac Toe game a little bit more interesting by enabling us to actually play the game. So a few pieces that we need before we actually start programming with the JavaScript. The first part is our script tag. So we need to actually embed JavaScript into our web page. So to do that, we’re going to add a couple tags, right after our table or our board that we had before. So down here towards the bottom right above your body tag, right underneath the table tag, we’re going to add our script tags. And these script tags are going to be used to import the JavaScript. So just like what we’ve done with our CSS up here, where our link tag is actually importing our CSS, our Cascading Style Sheets into our page. Our script tag is going to work very much the same. So I’m going to go ahead and just paste these in here. And then let’s go ahead and talk about them. So each script tag has a source attribute, where the source attribute is going to be the actual location of the script that you’re actually pulling in. And inside, typically, you won’t see one unless you’re importing JavaScript. Typically won’t see anything in between the opening and closing tag, but you could just leave the source blank, and actually put the JavaScript straight inside of the tag itself.\nBut in this situation, we’re importing two different things. The first one is jQuery. Now, we’ve talked about jQuery before. jQuery is the JavaScript library that enables us to manipulate and modify the DOM elements on the web page in a way that is a little bit easier to utilize than raw JavaScript itself. And then the second script tag, there is going to be our Tic Tac Toe JavaScript that we use to play our game. So let’s go ahead and save that out. Now, nothing is going to change as part of our web page here. So our JavaScript still stays the same as we had before. But let’s go ahead and create our JavaScript. So in our, and you may need to create a new file here if you don’t have one already. So let’s go ahead and change this to all types. I’m going to call this script.js for JavaScript. And on our next slide here, we actually have all of the JavaScript that you want to actually put onto your web page. So let’s go ahead and copy this over. Now, do be careful when you’re copying and pasting this particular chunk of code because whitespace can make a difference here, depending on what you’re copying and pasting from. So just be careful with the whitespace and spaces. So everything should match up exactly as I have it. So just to explain our JavaScript here just a little bit before we move forward here.\nJavaScript is very similar to how Python works in the sense that it is a dynamically typed language, meaning that we don’t actually have to declare data types. But variables in JavaScript are typically declared using something, a keyword called let or var. So we have a variable called turn, it is initially x, because x always goes first. And then here, every everywhere you see a $ is referring to the jQuery library that we actually imported. So what the dollar sign is going to do is it’s going to select. This is going to select all of the DOM elements that match this search or this search parameter. And so this search here is going to be looking for td tags. And the search is very much based off of the CSS rules that we’ve had before. So the selector or the search, or this query is going to look for all the td tags, and then it’s going to link to it this onClick event. So this function is going to be ran or executed, every time a td tag is clicked. When the td tag is clicked, we’re actually going to select that square.\nSo we’re going to take that square or that td tag that was selected. And then if there is no data inside of it or text inside of it, so meaning that there is no X or there is no O, we’re going to insert the text for whoever’s turn it is. So if it’s X’s turn, we’ll add an X. If it’s O’s, turn we’ll add an O, and then we’ll change turns. And lastly here, at the end of our click, we need to update the div tag that we had before with new text that indicates whose turn it is an actual game. So if we save that out, and then go back over to our webpage and refresh, and we click, we can see that our page actually updates with X’s and O’s. Now, you can see here that it actually alternates, but it’s not going to recognize when you win, or lose. So that will just kind of a scouts honor sort of thing. We’re not going to code this up to indicate whether or not there’s a winner or loser in this class. But it’s still kind of a fun little exercise all with CSS and JavaScript that we can make a really simple game in a relatively short amount of time.\n",
    "description": "",
    "tags": null,
    "title": "Tic Tac Toe JS",
    "uri": "/ii-internet/13-webprog/07-tictactoe-js/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Alan Turing",
    "uri": "/i-concepts/05-universal-computers/07-alan-turing/"
  },
  {
    "content": " Resources Slides Video Script The last sorting algorithm we’re going to look at is quicksort. Quicksort is the newest of these algorithms being first published in 1961. Quicksort is a little bit different than the other sorting algorithms, because it requires us to choose a pivot element from the list and then sort based off of that pivot elements, it’s really kind of hard to understand conceptually without seeing it in action. So let’s take a look at how we perform quicksort using our deck of cards. The last sorting algorithm we’ll look at in this class is quicksort. Quicksort is a very unique algorithm. It’s like a divide and conquer algorithm, but it has some really interesting quirks and how it works that make it work really fast with random data. So let’s take a look at how quicksort works and see if we can get it to sort our deck of cards. The first step in quicksort is to choose a pivot element. And this is actually one of the key things about quicksort is choosing a pivot element most quicksort algorithm Don’t even put any thought into it, they just pick the last element or the first element in the list and call that the pivot.\nSo we’re going to take our six, and we’re going to call that our pivot element. Then we simply go through all the rest of the cards and sort them into two piles. All of the cards that are less than six go on one side, and all of the cards that are greater than six, go on the other side. And you notice that I’m not changing the order at all, I’m not doing any other sorting in those groups. I’m just putting them into those groups in the order that they come. So now we have our six that was our pivot elements, we have all of the items that are less than six on one side, and we have all of the items that are greater than six on the other side. This is where the divide and conquer part comes into this algorithm. We will do the same thing for each of these two groups. We’ll choose the pivot element, which is the last card and we will sort in this case the pivot element is five and all of the rest of Have the cards are less than five. So we don’t really gain a whole lot there, we just move this down to the next group. Here, we would choose the pivot element has eight. And so we would end up sorting the seven and the nine after the eights are, my my apologies, we would end up sorting the nine to 10 after the eight, whereas the seven would go before us.\nSo now we can do this again, we’ll pick this item as our pivot. And we will notice that very quickly, the ace goes before the three and the four. And notice I’m not changing anything else, I’m just arranging them in the order that they come. So now we’ve had six as a pivot, we’ve had five as a pivot to as a pivot, and eight as a pivot. So now we need to look at the other groups. We have a single group here, so that would become the pivot and gets locked in place. We have a group of two here where that becomes the pivot and gets locked into place. We have a group of one here where that becomes a pivot, and we have a group of two here where that becomes the pivot And now we can lock the others in place. And tada, it’s already sorted. That seemed to go very, very quickly.\nSo let’s shuffle this up and try again and see if quicksort really is just that fast. So let’s walk through quicksort. Again very quickly and see if it works just like we think. We’ll start by selecting our pivot element as three. And then we will put all of the elements that are greater than three on one side. And again, I’m not changing the order of them, I’m just grabbing them as they come. And then we’ll put all of the elements that are less than three on the other side. So now we’ve divided and we’ve set it up like that, in this item, we have two, so the two will become the pivot, the ace doesn’t move and an ace becomes the pivot. We’re already done with that side. Here are the four will become the pivot, and we know that everything is greater than the four after we look at It so the four will get locked in over here. The six will become the next pivot, and we will shuffle things around such that the six is in the correct spot. The five is a single so it’s going to get locked in place, we’ll choose the seven is the pivot, everything is greater than seven, it will get locked in place, which is the eight is the pivot, it will get locked in place, then we will choose the 10 is the pivot and finally the nine will get locked.\nSo again quicksort works very quickly. But let’s take a look at an example where quicksort may not work as well. And then in the later video, we’ll analyze why that doesn’t work. Alright, so now we have one more list of cards that we’re going to start with quicksort. And obviously, looking at this, you realize immediately that this is sorted, but the computer would know that without checking, so we’re going to do our quicksort algorithm and see what happens. So we’ll pick the 10 as the first pivot, and we’ll put everything less than 10 on one side and everything greater than 10 on the other side, and we noticed that everything left is less than 10. So nothing moves. So now we’ll do the nine. And now we’ll have to do the same thing by looking at every single card and making sure that it’s less than nine, and it is, and then we’ll do eight, and we’ll make sure that everything is less than eight. And it is we’ll do seven, we’ll make sure everything is less than seven.\nAnd as we go through this process, you’ll notice that this feels an awful lot like so, like Insertion Sort. We’re comparing each card to each other card and trying to figure out where it fits. And so as it turns out, quicksort has this really weird Worst case where if the data is already sorted quicksort is actually very inefficient. And it runs pretty much the same as Insertion Sort with a few extra steps. So in the next video, we’ll do some analysis of mergesort and look at its complexity. And then we’ll also look at the complexity of quicksort and see why it has this really bad worst case.\n",
    "description": "",
    "tags": null,
    "title": "Quick Sort",
    "uri": "/i-concepts/06-algorithms/08-quicksort/"
  },
  {
    "content": " Resources Slides Finally, let’s go through a complete worked example program that uses dictionaries in Python. Consider the following problem statement:\nWrite a program that will compute the score of a given word in a game of Scrabble. Assume that there are no special squares present. The program should prompt the user to input a string that only contains letters, and then compute the total score of that string by summing the value assigned to each letter. If the user inputs a string that contains invalid characters, the program should prompt for additional input until a valid word is received.\nThis is a pretty simple program that can easily make use of a dictionary in Python. So, let’s go through the process of solving it!\nHandling Input As always, we can start our solution by including a main() function and a call to the main() function at the bottom of our code, as shown here:\ndef main(): main() Next, we’ll probably want to create a function to handle requesting input from the user. So, we’ll add that function to our solution as well, and we’ll call it from within the main() function itself:\ndef get_input(): def main(): word = get_input() main() In the get_input() function, we’ll need the while loop structure we’ve already learned to handle input and verify that it is correct, so let’s go ahead and add that:\ndef get_input(): word = input(\"Enter a single word: \") while # word is not valid print(\"Error! Invalid Input!\") word = input(\"Enter a single word: \") return word def main(): word = get_input() main() The only part we have to figure out is how we can determine if a word contains only valid characters. There are many different approaches we could follow, but the simplest is to use the isalpha() function that is part of the Python string data type. This function, along with many others, are described in the Official Python Documentation.\nSo, let’s update our code to use that function as the Boolean expression in our while loop:\ndef get_input(): word = input(\"Enter a single word: \") while not word.isalpha(): print(\"Error! Invalid Input!\") word = input(\"Enter a single word: \") return word def main(): word = get_input() main() There we go! that covers the get_input() function, which will prompt the user to input a string that only contains letters.\nComputing Score Next, let’s look at writing a function that will accept a single word as a parameter, and then compute the score of that word according to the official Scrabble scoring rules.\nWe can start with a simple function definition as shown here:\ndef compute_score(word): First, let’s quickly convert the word we are given to lowercase, just in case the user has included any uppercase letters. Remember, we already know that this word should only contain letters, but it may be a mix of uppercase and lowercase. We can use the lower() function to make this conversion:\ndef compute_score(word): word = word.lower() Next, we’ll need to iterate through each letter in the word. Since we can treat a string just like a list, we can use a for loop for this:\ndef compute_score(word): word = word.lower() for letter in word: We’ll also need some way to keep track of the total score, and then return that value at the end of the function. This is a pretty common pattern in programming known as the accumulator pattern. So, let’s add a total variable to our program, starting it at $0$ and then returning it at the end:\ndef compute_score(word): word = word.lower() total = 0 for letter in word: # add letter's score to total return total Finally, we just need some way to convert a letter into a score in Scrabble. Thankfully, we can refer to the Official Scrabble FAQ to find out how many points each letter is worth:\n(1 point) - A, E, I, O, U, L, N, S, T, R (2 points) - D, G (3 points) - B, C, M, P (4 points) - F, H, V, W, Y (5 points) - K (8 points) - J, X (10 points) - Q, Z There are many different ways we could build this program, but one simple way would be to assign each letter a value in a dictionary! To make things even easier, we can leave out all of the letters that are worth 1 point, and just include the letters with higher point values. By doing so, if we don’t find our desired letter in the dictionary, we can simply assume that the score must be 1!\nSo, let’s add that dictionary to our code:\ndef compute_score(word): scores = {\"d\": 2, \"g\": 2, \"b\": 3, \"c\": 3, \"m\": 3, \"p\": 3, \"f\": 4, \"h\": 4, \"v\": 4, \"w\": 4, \"y\": 4, \"k\": 5, \"j\": 8, \"x\": 8, \"q\": 10, \"z\": 10} word = word.lower() total = 0 for letter in word: # add letter's score to total return total Now that we have this dictionary available in our code, we can use it inside of the for loop to compute the total score of the word by looking up the value of each letter. However, before we can directly access a letter, we first must determine if a given letter is contained in the dictionary. In Python, we can do this using the in keyword. So, we can add an if statement inside of our for loop that is structured as shown here:\ndef compute_score(word): scores = {\"d\": 2, \"g\": 2, \"b\": 3, \"c\": 3, \"m\": 3, \"p\": 3, \"f\": 4, \"h\": 4, \"v\": 4, \"w\": 4, \"y\": 4, \"k\": 5, \"j\": 8, \"x\": 8, \"q\": 10, \"z\": 10} word = word.lower() total = 0 for letter in word: if letter in scores: total = total + scores[letter] else: total = total + 1 return total The Boolean expression letter in scores will return true if the current letter in our word is present as a key in the dictionary scores. The same syntax also works for determining if an element is present in a list!\nComplete Program We can complete our program by simply printing the score returned by the compute_score() function in our main() function. So, the complete program is shown below:\ndef get_input(): word = input(\"Enter a single word: \") while not word.isalpha(): print(\"Error! Invalid Input!\") word = input(\"Enter a single word: \") return word def compute_score(word): scores = {\"d\": 2, \"g\": 2, \"b\": 3, \"c\": 3, \"m\": 3, \"p\": 3, \"f\": 4, \"h\": 4, \"v\": 4, \"w\": 4, \"y\": 4, \"k\": 5, \"j\": 8, \"x\": 8, \"q\": 10, \"z\": 10} word = word.lower() total = 0 for letter in word: if letter in scores: total = total + scores[letter] else: total = total + 1 return total def main(): word = get_input() print(compute_score(word)) main() We can confirm our program works correctly by running it and testing a few different inputs, as shown below:\nThis example shows a great way to use dictionaries in our program - we can assign values to various keys, and then easily look them up in the dictionary as needed. Feel free to run this example in Python Tutor on your own to see how it works, and see if you can come up with your own high-scoring Scrabble words.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/14-dictionaries/04-worked-example/"
  },
  {
    "content": " Resources Slides One of the coolest features in Python is the ability to easily create slices of lists. A slice is simply a portion of a list that can be stored and used as a separate list, allowing us as programmers to quickly create and manipulate new lists based on existing lists.\nThere are two basic ways to create a list slice in Python.\nnums[start:end] - this will create a slice of the list stored in nums that begins as the index start and ends before the index end. For example, if nums is storing the list [2, 4, 6, 8, 10], then nums[1:3] would create the list slice [4, 6]. nums[start:end:step] - this will create a slice of the list stored in nums that begins as the index start, moves step indexes between each successive items, and ends before the index end. For example, if nums is storing the list [2, 4, 6, 8, 10], then nums[0:5:2] would create the list slice [2, 6, 10]. The method for creating list slices is very similar to how the range() function is used in Python. In effect, if the same values are provided as arguments to the range() function, then it will produce the list of indexes that will be used to generate the list slice.\nBeyond the simple syntax, there are a few other rules to understand about list slices:\nAny of the numbers may be omitted, as long as there is at least one colon placed inside of the square brackets. By default, start will be $0$ at the start of the list, end will be the size of the list, and step will be $1$. So, each of these are valid ways to slice a list, and there are many more possible combinations: nums[:] - this will effectively copy the list and include every item in the slice. nums[start:] - this will include all items in the list starting at start. nums[:end] - this will include all items in the list before end. nums[::step] - this will include all items in the list starting at index $0$ and moving forward step indexes each List slices may include negative indexes! In fact, we can use negative indexes to access elements in any list in Python. Some examples: nums[-1] - this will access the last item in the list nums[-3:] - this will create a slice containing the last three items in the list. nums[:-2] - this creates a slice of the entire list except for the last two items. For example, we can start with a simple list, and then try the various list slicing methods to see what elements would be included in the new list. Here’s an example program that shows some of the various ways to manipulate lists in Python:\ndef main(): nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(nums) # simple slices print(nums[3:7]) print(nums[5:]) print(nums[:5]) print(nums[::2]) print(nums[1::2]) # negative numbers print(nums[-1]) print(nums[-7:-3]) print(nums[-3:]) print(nums[:-3]) print(nums[::-1]) main() When we execute the program above, we should see the following output:\nList slicing is a great way to use and manipulate lists in Python, but it takes a bit of practice to learn all the various ways that it can be used. Feel free to play around with all of the various examples above using some sample data to see how they work.\nnote-1 The range() function in Python is used to generate a list, but unfortunately we can’t directly use that list in our code without a bit of manipulation. For example, we can try to store the result of the range() function in a variable as shown here:\nnums = range(10) print(nums[3:7]) However, when we try to run that code, we’ll see this output:\nrange(3, 7) This is because the range() function doesn’t actually create a list - it is it’s own data structure type! Since a range can be constructed from just three numbers, it is much simpler to store just those numbers in memory instead of the entire list of numbers that it represents. When we create a slice of a range object, it just generates a new range instead of a list. So, to actually convert a range to a list, we must use the list() function in Python:\nnums = list(range(10)) print(nums[3:7]) This will produce the expected output:\n[3, 4, 5, 6] You can learn more about this by reading Python’s Range documentation.\n",
    "description": "",
    "tags": null,
    "title": "Slicing Lists",
    "uri": "/x-cis115-labs/13-lists/04-slicing-lists/"
  },
  {
    "content": " Resources Slides Now that we’ve explored how to create programs that contain nested loops, let’s work through a complete example problem to see how we can convert a problem statement into working code.\nConsider the following problem statement:\nWrite a program to print the sum of the first n prime numbers, where n is provided as input from the user.\nThis is a very simple problem statement, but it can be very complex to build a program that satisfies it. So, let’s go through the steps and see if we can get it to work.\nHandling User Input As always, we can start building our programs by adding a main() function and a call to the main() function to our code, as shown here:\ndef main(): main() Inside of the main() function, the first thing we’ll need to do is get input from the user, since we really can’t do anything else until we know what our goal is. While the problem statement doesn’t include any information about what inputs are acceptable, we can infer that only positive integers should be used as input. So, we can borrow the positive_input() function from earlier in this module to handle all of our input:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def main(): n = positive_input() main() Reusing existing code, such as the positive_input() function we just included here, is a great way to build our programs. We can always think of previous code that we’ve already written and tested as possible building blocks for future programs, and reusing existing code is a great way to speed up our development process.\nPrime Numbers Next, we need some way to determine if a number is a prime number. Recall from mathematics that a prime number is a number that is only equally divisible by $1$ and itself. For example, $7$ is prime, but $8$ is not since it can be evenly divided by $4$.\nThankfully, we know that we can use the modulo operator % to determine if a number if evenly divisible by another number. So, all we need to do is check if each number less than our chosen number can equally divide it. If none of them can, then our chosen number is prime.\nSo, let’s write a function that performs this operation. We’ll start by creating a function that accepts our chosen number as a parameter:\ndef is_prime(n): Next, we know that we need to check all of the numbers from $2$ up to but not including n. We can do this using a for loop and the range() function:\ndef is_prime(n): for i in range(2, n): Inside of the for loop, we want to check and see if the iterator variable i can evenly divide the chosen number n using the modulo operator:\ndef is_prime(n): for i in range(2, n): if n % i == 0: # i equally divides n Here’s where things get a bit tricky - if i can equally divide n, we know that n is not prime and we don’t have to check any other values. So, in our function, we can just use the return False statement to return the value False from this function. As soon as the function reaches a return statement, even if it is inside of a loop, it will immediately stop the function and go back to where it was called from. In effect, we can use this to shortcut the rest of the loop.\ndef is_prime(n): for i in range(2, n): if n % i == 0: return False # what if we don't return false? However, what happens if we check all of the values from $2$ up to n and don’t find a single one that will equally divide our chosen number n? In that case, we’ll reach the end of our for loop, but our function hasn’t returned anything. So, we’ll need to add one extra line to the end of the function to return True if we get to that point.\ndef is_prime(n): for i in range(2, n): if n % i == 0: return False return True There we go! That’s a quick and easy function to determine if a given number is prime. This function is a great example of a pattern that we’ll see many times as we write complex programs whenever we must determine if a particular situation is true for a given list of numbers. Inside of the loop, we’ll check each case and return False if it isn’t true. If it is true, then we’ll complete the entire loop without returning False, so we’ll need to return True at the end of the function. We’ll see this pattern again in a later lab.\nnote-1 The is_prime() function above is very simple, but not very efficient. With a bit of thought, it is easy to determine that we only have to actually check numbers up to n /2, since it is impossible for any number larger than that to evenly divide n. Likewise, we can do some quick math to eliminate numbers that end in an even digit or $5$, since those numbers will never be prime.\nFinally, we could use a more advanced mathematical technique such as the Sieve of Eratosthenes to generate all prime numbers more quickly. However, for this example, we’ll stick to the simplest approach.\nComplete Program Finally, now that we have the is_prime() function, we can complete our main() function by simply iterating through all possible numbers until we’ve found n prime numbers, and then print the sum:\ndef main(): n = positive_input() count = 0 i = 2 sum = 0 while count \u003c n: if is_prime(i): sum = sum + i count = count + 1 i = i + 1 print(\"The sum of the first {} prime numbers is {}\".format(n, sum)) This program requires three additional variables. The variable count is used to keep track of the number of prime numbers found, so we’ll increment it inside of the if statement each time we find a prime number. Likewise, the sum variable keeps track of the sum of the prime numbers, which we’ll print at the end. Finally, we use i as our iterator variable, so we must make sure that we increment i each time the while loop iterates, outside of the if statement. We’ll start i at $2$, since $1$ is not a prime number mathematically. A very common programming mistake is to forget to increment i outside the if statement, resulting in an infinite loop. Also, we chose to use a while loop instead of a for loop since our program’s goal is to sum up the first n prime numbers, which is better expressed as a while loop instead of a for loop.\nThe full program is shown below:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def is_prime(n): for i in range(2, n): if n % i == 0: return False return True def main(): n = positive_input() count = 0 i = 2 sum = 0 while count \u003c n: if is_prime(i): sum = sum + i count = count + 1 i = i + 1 print(\"The sum of the first {} prime numbers is {}\".format(n, sum)) main() Finally, notice that this program doesn’t contain a loop nested within another loop in the same function, but because we are calling the is_prime() function, which contains a loop, from within a loop inside of the main() function, it actually has a nested loop structure inside of it! Feel free to run this program in Python or using Python Tutor to confirm that it works as expected before continuing.\nTesting Testing this program is a bit complex, since we can only provide a single input. We can easily provide a negative value or $0$ to confirm that the loop in the positive_input() function is working correctly, but beyond that we have little control over the rest of the program just by changing inputs.\nInstead, we have to rely on our ability to read and analyze the code to determine if it is working properly. For example, we can look at the loop inside of the main() function. It is a while loop, which relies on the count variable increasing until it is greater than or equal to n before it will terminate. We can see that count will be incremented each time the is_prime() function returns True, so as long as we are able to find enough prime numbers, and assuming our is_prime() function works correctly, this loop should eventually terminate.\nIn the is_prime() function, we have a simple for loop, which will always terminate eventually. There is no way to bypass it, so we don’t really have to worry about that function not eventually returning a value.\nHowever, proving that this program creates the correct answer is a bit trickier. One of the best ways to do this is to simply check a few answers manually. For example, with a bit of searching online, we can find a list of prime numbers. According to Wikipedia, the first 9 prime numbers are:\n2 3 5 7 11 13 17 19 23 The sum of those numbers is easy to calculate using a calculator or other device, and eventually we can be fairly certain that the correct answer is $100$. When we run our program, we should hopefully get the same result:\nWe can test a few other numbers until we are sure that our program is working correctly.\nHopefully this example is a good look at how to build a program using loops that meets a given problem description. We were able to put together various types of loops and conditional statements in our program, and then test it to be sure it works. As you continue to work on projects in this class, feel free to refer back to these examples for ideas and blocks of code that you may want to use in your own programs. Good luck!\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/12-nested-loops/04-worked-example/"
  },
  {
    "content": " Resources Slides Now that we’ve seen how we can chain and nest multiple conditional statements in our code, we need to address a very important concept: variable scope.\nIn programming, variable scope refers to the locations in code where variables can be accessed. Contrary to what we may think based on our experience, when we declare a variable in our code, it may not always be available everywhere. Instead, we need to learn the rules that determine where variables are available and why.\nMany Languages: Block Scope First, let’s talk about the most common type of variable scope, which is block scope. This type of variable scope is used in many programming languages, such as Java, C#, C/C++, and more. In block scope, variables are only available within the blocks where they are declared, including any other blocks nested within that block. Also, variables can only be accessed by code executed after the variable is initially declared or given a value.\nSo, what is a block? Effectively, each function and conditional statement introduces a new block in the program. In languages such as Java and C/C++, blocks are typically surrounded by curly braces {}. In Python, blocks are indicated by the level of indentation.\nFor example, consider the following Python code:\ndef main(): # main block x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") main() This program contains six different blocks of code:\nThe main block, which is all of the code within the main() function Block A, which is all of the code inside of the True branch of the outermost conditional statement. Block B, the True branch of the inner conditional statement Block C, the False branch of the inner conditional statement Block D, the True branch of the first elif clause of the outer conditional statement Block E, the False branch of the outermost conditional statement Inside of each of those blocks, we see various variables that are declared. For example, the variable x is declared in the main() function block. So, with block scope, this means that the variable x is accessible anywhere inside of that block, including any blocks nested within it.\nBelow is a list of all of the variables in this program, annotated with the blocks where that variable is accessible in block scope:\nx - blocks main, A, B, C, D, E y - blocks A, B, C z - blocks B and C more on this later a - block D b - block E One thing that is unique about this example is the variable z, which is declared in both block B and block C. What does this mean when we are dealing with block scope? Basically, those variables named z are actually two different variables! Since they cannot be accessed outside of the block that they are declared in, they should really be considered as completely separate entities, even though they are given the same name. This is one of the trickiest concepts when dealing with scope!\nSo, if this program is using block scope, what variables can be printed at the very end of the program, where the question mark ? is found in a print() statement? In this case, only the variable x exists in the main() function’s scope, so it is the only variable that we can print at the end of the program.\nIf we want to print the other variables, we must declare them in the appropriate scope. So, we can update our code as shown here to do that:\ndef main(): # main block # variable declarations in main block y = 0 z = 0 a = 0 b = 0 x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") main() With this change, we can now access all of the variables in the main() function’s scope, so any one of them could be printed at the end of the program. This also has the side effect of making the variable z in both blocks B and C the same variable, since it is now declared at a higher scope.\nPython: Function Scope Python, however, uses a different type of variable scope known as function scope. In function scope, variables that are declared anywhere in a function are accessible everywhere in that function as soon as they’ve been declared or given a value. So, once we see a variable in the code while we’re executing a function, we can access that variable anywhere within the function.\nLet’s go back to the previous example, and look at that in terms of function scope\ndef main(): # main block x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") main() Using function scope, any of the variables x, y, z, a or b could be placed in the print() statement at the end of the main function, and the program could work. However, there is one major caveat that we must keep in mind: we can only print the variable if it has been given a value in the program!\nFor example, if the user inputs a negative value for x, then the variables y, z, and b are never given a value! We can confirm this by running the program in Python Tutor. As we see here, at the end of the program, only the variables x and a are shown in the list of variables within the main() frame in Python Tutor on the right:\nBecause of this, we have to be careful when we write our programs in Python using function scope. It is very easy to find ourselves in situations where our program will work most of the time, since it usually executes the correct blocks of code to populate the variables we need, but there may be situations where that isn’t guaranteed.\nThis is where testing techniques such as path coverage are so important. If we have a set of inputs that achieve path coverage, and we are able to show that the variables we need are available at the end of the program in each of those paths, then we know that we can use them.\nAlternatively, we can build our programs in Python as if Python used block scope instead of function scope. By assuming that variables are only available in the blocks where they are given a value, we can always ensure that we won’t reach a situation where we are trying to access a variable that isn’t available. For novice programmers, this is often the simplest option.\nDealing with scope is a tricky part of learning to program. Thankfully, in Python, as well as many other languages, we can easily use tools such as Python Tutor and good testing techniques to make sure our programs are well written and won’t run into any errors related to variable scope.\n",
    "description": "",
    "tags": null,
    "title": "Blocks and Scope",
    "uri": "/x-cis115-labs/9-nested-conditionals/04-blocks-scope/"
  },
  {
    "content": " Resources Slides Now that we’ve seen many examples of how to use loops in our code, let’s briefly discuss some techniques for testing programs that contain loops. Many of these techniques are similar to ones we’ve explored when testing conditional statements, but there are a few important nuances to think about.\nBranch and Path Coverage First, just like we explored with conditional statements, it is important to test our programs in a way that we execute every possible branch, and try to find every possible path through the program as well. When dealing with a loop, usually we just consider two paths - one where the loop is entered at least once, and one where the loop is skipped entirely, if possible.\nConsider this example program in pseudocode:\nPROCEDURE main() { x \u003c- NUMBER(INPUT()) y \u003c- NUMBER(INPUT()) REPEAT WHILE(x \u003c y) { x = x + x } DISPLAY(x) } This program will repeatedly double x until it larger than y. So, let’s come up with some inputs for this program that achieve branch and path coverage.\nBranch Coverage To achieve branch coverage, we must simply come up with a set of inputs that will execute every line of code in the procedure at least once. So, let’s try inputting $3$ and $5$ first. Since x is less than y, we enter the loop at least once. Eventually, x will become greater than y, so we’ll exit the loop as well at some point. Therefore, we can say that the inputs 3 and 5 are enough to achieve branch coverage.\nPath Coverage In this sample program, we’ve already executed all of the code, but we may want to try and come up with a set of inputs that will bypass the loop completely. This helps us check to make sure there aren’t any issues with the code if the loop isn’t executed at all. For this instance, consider the inputs 5 and 3. In this case, the value in x is already greater than y, so the program will never execute the code inside of the loop at all. Thankfully, this doesn’t break anything, so we know this program will work just fine without executing the loop.\nLoop Termination When testing code that contains a loop, there is one other test we must consider - is it possible to reach a situation where the loop will never terminate? That is, once we start executing code within the loop, is it possible to get stuck in the loop and then never actually complete the program?\nTherefore, we must think carefully about our loops and situations that might cause problems. For example, what if we provide the inputs -5 and -3 to the pseudocode program above?\nIn that case, we’ll enter the loop since $-5$ is less than $-3$, but once we’ve executed the code in the loop, we’ll see that x is now storing $-10$! We’ve actually gotten further away from a situation where the loop will terminate, which is definitely not good. In fact, this loop will repeat infinitely, and our program will run forever.\nSo, we should either rethink our program a bit, or possibly add additional code to make sure the user does not input a negative value for y. By properly testing our program, we were able to discover a situation where the loop would not terminate!\nnote-1 Unfortunately, it can be difficult to definitively prove if a loop will terminate in all cases. In computer science, we typically use a special concept known as a loop variant in order to prove that a loop will eventually terminate. Loosely, a loop variant is a way of expressing a maximum number of possible iterations of a loop before it terminates based on the current state of the program.\nIn the example above, we could say that our loop variant is the difference between x and y. Then, as long as we can show that the difference between those two values is monotonically decreasing each time the loop iterates, we can show that eventually it will reach a $0$ or less than $0$ and the loop will terminate. If the loop variant does not decrease, then the loop will not terminate.\nIn this course, you won’t be expected to reach that level of detail, but hopefully you’ll be able to use some simple logic and common sense to figure out if a loop will terminate or if there are situations where it won’t work correctly.\n",
    "description": "",
    "tags": null,
    "title": "Testing Loops",
    "uri": "/x-cis115-labs/10-pseudocode-loops/04-testing-loops/"
  },
  {
    "content": " Resources Slides Another important aspect of working with loops in code is learning how to properly test programs that contain loops. So, let’s look at some of the methods we can use when testing our programs containing loops to make sure they work correctly and won’t run into any problems.\nBranch and Path Coverage Loops, like conditional statements, introduce different branches and paths into our programs. So, one of the first steps when testing these programs is to develop a set of inputs that will execute each branch of the code, as well as finding inputs that will execute multiple different paths through the program. Since loops may repeat many times, typically we only worry about two possible paths when dealing with loops - one path where it is skipped entirely and another path where the loop is entered at least once.\nLet’s consider this simple Python program that contains loops:\ndef main(): x = int(input(\"Enter a number: \")) y = int(input(\"Enter a number: \")) i = 0 line = \"\" while i \u003c x + y: line = line + \"*\" print(line) i = i + 1 while i \u003e x - y: print(\"=\", end=\"\") i = i - 1 print() main() This program will simply print a right triangle of asterisks * that is x + y characters wide and tall, similar to a previous example in this lab. However, it will also print a final line of equals signs = below that, consisting of x - y characters. To test this program, we want to try and find some input values for x and y that achieve branch and path coverage.\nBranch Coverage To achieve branch coverage, we want to execute each line of code in this program at least once. An easy way to do that is to provide inputs so that the sum of x and y is a positive number in order to enter the first loop. After the first loop terminates, the value of i will be equal to the sum of x and y, provided that value is greater than $0$. So, in order to also enter the second loop, we need to make sure the difference of x and y is smaller than their sum.\nA set of inputs that achieves this would be $3$ and $1$ for x and y, respectively. Their sum is $4$, so the first loop will be executed 4 times. Then, the difference between the values is $2$, so the second loop will executed twice to reduce the value in i to $2$.\nSo, we can say that the inputs 3 and 1 are enough to achieve branch coverage.\nPath Coverage To achieve path coverage, we must consider three additional paths through the program:\nNeither loop is entered Only the first loop is entered Only the second loop is entered First, in order to enter neither loop, we must have a set of inputs where the sum is less than or equal to $0$, and also where the difference is less than or equal to $0$. The simplest way to achieve this is to set both inputs to exactly $0$! Sometimes the simplest inputs are the easiest for testing.\nTo enter the first loop only, we need the situation where the sum of x and y is greater than 0, but then their difference is even larger. An easy way to accomplish this is to set y to a small negative number. For example, we could set x to $3$ and y to $-1$. That will make their sum $2$ but the difference $4$, so we’ll only execute the first loop but not the second one.\nFinally, if we want to execute the second loop only, we need to make both the sum and the difference of x and y a number less than $0$. In that case, we can simply set both x and y to negative values, but make sure that x is overall a smaller value than y. So, we could set x to $-3$ and y to $-1$. In that case, their sum is $-4$ but their difference is $-2$. That will cause the program to skip the first loop but enter the second loop.\nSo, we can achieve path coverage with these four sets of inputs:\n3, 1 0, 0 3, -1 -3, -1 Loop Termination When testing loops, we should also check to make sure that the loops will eventually terminate if we ever enter them. Thankfully, in this program, it is very easy to reason about this and convince ourselves that it works.\nConsider the first loop - the only way to enter that loop is if the value of i is less than the sum of x and y, and each time the loop iterates the value in i will be incremented by $1$. Since i is getting larger each time, eventually it will reach a value that is greater than or equal to x + y and the loop will terminate.\nThe same argument can be made for the second loop. In that loop, i is initially greater than the difference of x and y, but i is decremented each time, so eventually the loop will terminate.\nTechnically speaking, we can come up with a loop variant for each loop and show that it is monotonically decreasing. This is easily done by simply finding the difference between the iterator variable i and the termination condition of the loop, either the sum or the difference of x and y. We won’t ask you to get to this level of detail when testing your own loops, but it is a very useful concept to understand when working with loops.\nThere we go! We were able to quickly come up with a set of inputs that will execute all possible branches and paths in this program, and we can also show that each of the loops will properly terminate anytime they are executed. So, we know that our program at least won’t crash, no matter what integers are provided as input. We can also examine the output of each test and make sure that it matches what the expected output should be in order to show that our program not only doesn’t crash, but that it provides the correct output.\n",
    "description": "",
    "tags": null,
    "title": "Testing Loops",
    "uri": "/x-cis115-labs/11-python-loops/04-testing-loops/"
  },
  {
    "content": " Resources Slides In Python, Boolean values are stored in the bool data type. Just like in pseudocode, variables of the bool data type can only store one of two values, True or False.\nTo create a Boolean variable in Python, we can simply assign those values to a variable in an assignment statement:\na = True b = False print(a) print(type(b)) When we execute that code, we’ll see the following output:\nTrue \u003cclass 'bool'\u003e In Python, we use the keywords True and False to represent Boolean values. Notice that they are capitalized, unlike the true and false values we saw in pseudocode. In Python, it is very important to make sure these values are capitalized, otherwise the program will not work properly. Also, since these are keywords and not strings, we don’t need to put them in quotation marks.\nConverting Between Data Types Python includes the special bool() function, which can be used to convert any data type into a Boolean value. The bool() function follows these rules to determine what to return:\nIf the input is the value False, the value 0, the value None, or anything with 0 length, including the empty string, it will return False. Otherwise, for all other values it will return True. Let’s look at a couple of quick examples. First, let’s try to convert the strings \"True\" and \"False\" to their Boolean equivalents:\nprint(bool(\"True\")) print(bool(\"False\")) When this code is executed, we’ll see this output:\nTrue True This seems a bit strange, since the string \"False\" ended up creating the Boolean value True. However, if we look at the rules above, since the string \"False\" has a length greater than 1, and it is not any of the special values listed above, it should always result in the Boolean value True.\nIn this example, we can check a couple of special values using the bool() function:\nprint(bool(0)) print(bool(1)) print(bool(\"\")) In this case, we’ll see the following output:\nFalse True False Here, we see that the value 0, as well as the empty string \"\", both result in a value of False. However, the value 1 is True, since it is a non-zero value.\nIn practice, we won’t use the bool() function directly very often. Instead, if we want to determine if a user inputs a True or False value, we can just use one of the Boolean comparators that we’ll see later in this lab.\n",
    "description": "",
    "tags": null,
    "title": "Python Booleans",
    "uri": "/x-cis115-labs/6-booleans/04-python-booleans/"
  },
  {
    "content": " Resources Slides Boolean expressions in Python can be used in a variety of ways. One of the most important things we can do with a Boolean expression is affect the control flow of our program using a conditional statement.\nRecall that a conditional statement is a type of statement that allows us to choose to run different pieces of code based on the value given in a Boolean expression. The simplest conditional statement is the if statement.\nIn an if statement, we include a Boolean expression and a block of statements. If the Boolean expression evaluates to True, then we execute the code in the block of statements. If it is False, then we skip the block and continue with the rest of the program.\nThe structure of an if statement in Python is shown below:\nif \u003cboolean expression\u003e: \u003cblock of statements\u003e In this structure, we still have a \u003cboolean expression\u003e that is evaluated. However, instead of it being in parentheses like in pseudocode, in Python those parentheses are not required. After the Boolean expression is a colon :, just like at the end of a function definition.\nThen, the \u003cblock of statements\u003e is included below the if statement’s first line, and it must be indented one level. Again, this is very similar to the structure of a function definition in Python. In Python, the \u003cblock of statements\u003e must include at least one line of code, otherwise Python won’t be able to understand it.\nLet’s go through a couple of code tracing examples in Python Tutor to see how an if statement works in code.\nCode Tracing Example - False Consider this program in Python:\ndef main(): x = int(input(\"Enter a number: \")) if x == 7: print(\"That's a lucky number!\") print(\"Thanks for playing!\") main() We can run that code in Python Tutor by clicking this Python Tutor link. At first, our window should look something like this:\nWhen we step through the program, the first thing it will do is record the main() function in the objects list, as shown here:\nThen, we’ll reach the call to the main() function, so Python Tutor will jump to that function and create a frame for all the variables needed:\nThe next line of code will ask the user to input a number, so Python Tutor will show an input box at the bottom of the window:\nFor this first time through the program, let’s assume the user inputs the string \"42\" as input. So, when we click Submit, we’ll see the integer value $42$ stored in the variable x in the main frame:\nAt this point, we’ve reached the if statement. The first step is to evaluate the Boolean expression x == 7. Since x is actually storing the value $42$, this statement will evaluate to False. So, when we click the Next button on the state below:\nWe’ll see that the program arrow jumps past the block of statements in the if statement. So, the next line will simply print the goodbye message:\nFinally, the main() function will return, and we’ll end the program:\nThe entire process is shown in the animation below:\nAs we can see, when the Boolean expression evaluates to False, we’ll just skip the block of statements inside of the if statement. This is the same result that we observed when we were working in pseudocode.\nCode Tracing Example - True Now let’s see what happens when the Boolean expression evaluates to True instead. To see that, we can go back to the point where our program is asking for input, as shown below:\nThis time, we’ll assume the user inputs the string \"7\" as input. So, when we click Submit, we’ll see the integer value $7$ stored in the variable x in the main frame:\nThis time, when we reach the if statement, we’ll see that the Boolean expression x == 7 will evaluate to True. So, when we click the Next button, we’ll be taken to the block of statements inside of the if statement:\nHere, we’ll print the special message for finding a lucky number:\nThen, we’ll print the program’s goodbye message:\nAnd finally we’ll reach the end of the main() function, so it will return and we’ll be at the end of the program:\nThe entire process can be seen in this animation:\nSo, when the Boolean expression evaluates to True, we’ll run the code inside the if statement. If it is False, then we’ll just skip past the if statement and continue with the rest of our program.\n",
    "description": "",
    "tags": null,
    "title": "Python If",
    "uri": "/x-cis115-labs/7-conditionals/04-python-if/"
  },
  {
    "content": "Lab 4 Math Operators ",
    "description": "",
    "tags": null,
    "title": "Math Operators",
    "uri": "/x-cis115-labs/4-math-operators/"
  },
  {
    "content": " Resources Slides Previously, we worked through this simple example pseudocode program:\nDISPLAY(\"Enter a number: \") text \u003c- INPUT() number \u003c- NUMBER(text) square \u003c- number * number DISPLAY(\"The square of your input is \") DISPLAY(square) However, we can greatly shorten this program’s code using a couple of programming features that we have not covered yet. Let’s look at how we can do that.\nExpressions of Expressions The single biggest thing to understand about expressions in programming is that we can usually combine them in a variety of different ways.\nFor example, this program receives input from the user using the INPUT() expression, and then on a separate line of code it uses the NUMBER() procedure to convert it to a number and store it in a variable. However, since the NUMBER() procedure allows us to use any expression as an argument, we can combine those two lines:\nDISPLAY(\"Enter a number: \") number \u003c- NUMBER(INPUT()) square \u003c- number * number DISPLAY(\"The square of your input is \") DISPLAY(square) Yup, that’s right! Because INPUT() is essentially a procedure that returns a value, we can directly use that returned value as an argument to the NUMBER() procedure, without ever storing it in a variable. Our “mental model” of a computer will call the procedure inside the parentheses first, just like we’d expect, and then once it returns a value it will use that value to call the other procedure.\nWe can combine the last two lines of code in a similar way. We’ve already seen how to combine strings using the concatenation operator, so as long as we convert the value in square to a string it will work:\nDISPLAY(\"Enter a number: \") number \u003c- NUMBER(INPUT()) square \u003c- number * number DISPLAY(\"The square of your input is \" + STRING(square)) So, we’ll just place the square variable in the STRING() procedure to convert it to a string value, and then we can concatenate that value onto the end of the other string and display it in a single line.\nFinally, we can even perform operations directly inside of procedure calls. So, we can combine the last two lines in this new example, preventing us from even needing the square variable at all:\nDISPLAY(\"Enter a number: \") number \u003c- NUMBER(INPUT()) DISPLAY(\"The square of your input is \" + STRING(number * number)) Our computer knows to resolve any expressions used as an argument in a procedure before calling the procedure, so this will work exactly like we’d expect it to. So, we’ve taken a program with 6 lines of code and reduced it to just 3 lines of code, and removed 2 of the 3 variables it uses in the process.\nConcise and Readable The real question is: which of these two examples is best? That is, which one is the preferred coding style to learn? The answer is that it really depends - both have their merits, and functionally they will work nearly identically on most modern computers and programming languages.\nIt really is a question of style - is it better to have more lines of code and variables, clearly spelling out what each step of the process is, or is it better to have shorter programs with more complex lines of code but maybe fewer variables? For beginning programmers, it is usually recommended to follow the first style, using as many variables as needed and focusing on short, concise lines of code over large, complex statements.\nHowever, as we become more accustomed to programming, we’ll find that many times it is easier to read and understand complex statements, and our code can be written in a way that better reflects what it is actually doing.\nThis is very similar to learning how to read, write, and speak in a new language. We must start with short, concise sentences, and slowly build up our knowledge of more complex statements and grammar rules until we become a fluent speaker.\nOverall, the best advice to follow is to make your code readable to both yourself and anyone else who may have to read and maintain the code. As long as it is clear what the code is doing based on what it says, it is probably a good style to follow. As we continue to learn more, we’ll slowly refine our coding style to be one that is easy to follow and understand for everyone.\n",
    "description": "",
    "tags": null,
    "title": "Complex Pseudocode",
    "uri": "/x-cis115-labs/5-input-strings/04-complex-pseudocode/"
  },
  {
    "content": " Resources Slides We can also use Python to perform mathematical operations on numerical data using operators. So, let’s briefly review the operators we’ve learned so far, and introduce a couple of new operators that are unique to Python.\nMathematical Operators Python supports the same mathematical operators that we’ve already seen in pseudocode. The only exception is the the modulo operation is performed using the percent symbol % instead of the MOD keyword. So, here are the symbols we can use in Python and the operations they perform:\n+ addition - subtraction * multiplication / division % modulo However, there is one major difference between how these operators work in pseudocode and how they work in Python, and it has to do with the fact that Python includes two numerical data types. To deal with this, we have to define how the operators work when applied to different data types.\nResulting Data Types - Same Type The basic rule to remember, if a mathematical operator is applied to two variables of the same data type, the result will also be that data type.\nLet’s see what that means in practice. Here’s a quick example in Python using the multiplication operator on two integer values:\nx = 5 y = 10 z = x * y print(z) print(type(z)) When we run this code, we should see the following output:\n50 \u003cclass 'int'\u003e Since both x and y are the int data type, the result of x * y will also be an int value, so the variable z will have that data type, as shown in this example.\nHowever, there is one exception to this rule, which is the division operator /. In Python, the division operator will always return a float value, even if it is a whole number. Here’s an example that demonstrates that:\na = 9 b = 3 c = 4 x = a / b print(x) print(type(x)) print() y = a / c print(y) print(type(y)) When we run this program, we’ll see the following output:\n3.0 \u003cclass 'float'\u003e 2.25 \u003cclass 'float'\u003e So, as we can see, even though we are dividing two int values, we’ll get a float value as a result each time we use the division operator.\nFollowing the rule above, if we perform a mathematical operation between two float values, the resulting value will always be a float as well:\na = 2.5 b = 4.5 c = a + b print(c) print(type(c)) Running this code will produce this output:\n7.0 \u003cclass 'float'\u003e So, even though the result is a whole number, the value that is stored is the float data type.\nResulting Data Types - Different Type The other rule to remember is anytime an operation involves a float value and an int value, the result will be a float. So, if there are mixed types, Python will default to the float data type.\nThis can be seen in the following example:\na = 5 b = 2.0 c = a - b print(c) print(type(c)) When this code is executed, the output should look like this:\n3.0 \u003cclass 'float'\u003e Once again, even though the result is a whole number, because the variable b is a float value, the entire result will also be a float value.\nNew Operators In Python, we can also introduce two new operators:\n** exponentiation (power) // integer division First, the double star ** operator is used to represent the exponentiation operation, sometimes referred to the power operator. In Python, the expression 2 ** 3 would be written mathematically as $2^3$, which is the operation of taking $2$ to the power of $3$, or multiplying $2$ by itself $3$ times. This operator follows the rules listed above for determining what type of data is the result of the operation.\nHere’s a quick example of using the ** operator in code:\nx = 5 ** 3 print(x) print(type(x)) When this code is run, we see the following output:\n125 \u003cclass 'int'\u003e The integer division operator, represented by two forward slashes //, is used to perform division that truncates the result to an integer. However, it still follows the rules for determining the data type of the result as listed above, so if either of the values in the operation is a float value, it will return a float, even though the result is an integer.\nLet’s look at an example with that operator in code:\na = 17.5 // 4.5 print(a) print(type(a)) As we expect, when we run this program, we’ll get the following output:\n3.0 \u003cclass 'float'\u003e So, we see that this operator will return a float value, even though it is truncating the result to an integer, simply because the input values contained a float.\nLearning the data types that are returned by a mathematical operator can be tricky, but most programmers slowly develop an intuition of how each operator works and what to expect. So, don’t worry too much if this is confusing right now, since it will become much clearer with practice! Also, don’t forget that we can always create a simple test program like the examples shown above to confirm the result for any operation.\nOrder of operations Let’s quickly review the order of operations in Python. Thankfully, this is very similar to what we’ve already seen in pseudocode and in mathematics - we just have to add the two new operators:\nOperations in parentheses are resolved first, moving from left to right. ** is resolved second, moving from left to right *, /, // and % are resolved third, moving from left to right. + and - are resolved fourth, moving from left to right. Of course, this means that there are now 4 operators that all fit in the “multiplication and division” portion, so we have to carefully make sure they are all taken care of in the correct way. As we learned before it is always best to add extra parentheses to any expression to make the intent very clear instead of relying on the order of operations.\n",
    "description": "",
    "tags": null,
    "title": "Python Operators",
    "uri": "/x-cis115-labs/4-math-operators/04-python-operators/"
  },
  {
    "content": " Resources Slides Let’s briefly consider one more important situation that may arise when calling procedures. What if the arguments provided in a procedure call are variables themselves? What does that look like?\nLet’s work through an example:\nPROCEDURE swap(one, two) { temp \u003c- one one \u003c- two two \u003c- temp DISPLAY(one) DISPLAY(two) } PROCEDURE main() { first \u003c- \"Willie\" last \u003c- \"Wildcat\" swap(first, last) DISPLAY(first) DISPLAY(last) } main() Before reading the code trace below, take a moment to read this code and see if you can predict what the output will be.\nCode Tracing Expressions as Arguments Like before, let’s set up our code trace to include our code and the various boxes we need to keep track of everything:\nLet’s go ahead and skip to the bottom where the main procedure call is. When we reach that line, we’ll start at the top of the main procedure, like this:\nNext, we can move through the following two lines of code, which create the variables first and last, storing the values \"Willie\" and \"Wildcat\", respectively. At this point, we’re ready to call the swap procedure:\nTo make a procedure call, we must first make sure the computer knows about the procedure. Since it is in our procedures box, we know we’ve seen it. The next step is to check and make sure that there is a matching argument for each parameter. The swap procedure requires two parameters, and we’ve provided two arguments, so that checks out. The next step is to actually evaluate each of the expressions used as arguments to a single value. If we look at our code, we see that the first argument expression is the variable first, which stores the value \"Willie\". So, we can place that value where the variable goes in our procedure call:\nThen, we can do the same for the last variable, which stores the value \"Wildcat\":\nNow that we’ve evaluated all of our argument expressions, we can finally perform the procedure call and enter the swap procedure. When we do this, we’ll create two new variables, one and two, and populate them with the values that we evaluated for each expression. Just like when we store the value of one variable into another, these are copies of the values that were stored in the original variables. So, just because they have the same value, they otherwise aren’t connected, as we’ll see later. So, our current code trace should look like this:\nInside of the swap procedure, we actually perform a three step “swap” process, which will swap the contents of the parameter variables one and two. First, we place the value of one in a new variable we call temp:\nNext, we place the original value in two into one. At this point, they both have the same value, but we’ve stored the original value from one into temp, so it hasn’t been lost:\nFinally, we can place the value from temp into two, completing the swap:\nThe next two lines will simply display the current values in one and two to the user:\nNotice that the values of first and last have not changed throughout this entire process. They are still the same values that were originally set in the main procedure. At this point, we’ve reached the end of the swap procedure. So, we can jump back to the location we left off in the main procedure. When we do so, we’ll remove all of the variables we created in the swap procedure. We’ll also reset all of the evaluated expressions in the swap procedure back to the original code. So, our code trace should now look like this:\nSince there’s nothing else to evaluate on this line, we can move to the next line in the program:\nThe next two lines are going to print the values of the first and last variables in the interface. Notice that, even though we swapped the values of one and two in the swap procedure, the values of first and last are unchanged here. This is an important concept to remember - when we use a variable as an argument in a procedure call, the procedure receives a copy of the value stored in that variable. So, any chagnes to the parameter variable in the procedure will not affect the variable that was used as an argument in the procedure call. In technical terms, we say this is a call by value procedure, since it uses the values in the arguments.\nSo, after running those two lines of code, we should reach the end of the main procedure, and our code trace should look like this:\nAt this point, we’re at the end of the main procedure, so the computer will just jump back to the main procedure call, and reach the end of the program! The whole process is shown in the animation below:\nAs we can see, calling procedures is a pretty easy process. By using parameters, we can build procedures that repeat the same steps in our program, just with different data each time.\n",
    "description": "",
    "tags": null,
    "title": "Expressions as Arguments",
    "uri": "/x-cis115-labs/3-functions/04-expressions-arguments/"
  },
  {
    "content": " Resources Slides Now that we’ve learned how to use the DISPLAY(expression) statement, let’s focus on the next major concept in pseudocode, as well as any other programming language: variables.\nThe word variable is traditionally defined as a value that can change. We’ve seen variables like $x$ used in Algebraic equations like $x + 4 = 7$ to represent unknown values that we can try to work out. In programming a variable is defined as a way to store a value in a computer’s memory so we can retrieve it later. One common way to think of variables is like a box in the real world. We can put something in the box, representing our value. Likewise, we can write a name on the side of the box, corresponding to our variable’s name. When we want to use the variable, we can get the value that it currently stores, and even change it to a different value. It’s a pretty handy mental metaphor to keep in mind!\nCreating Variables To use a variable, we must first create one. In pseudocode, we create a variable in a special type of statement called an assignment statement. The basic structure for an assignment statement is a \u003c- expression. When our “mental model” runs this statement, it will first evaluate expression into a single value. Then, it will store that same value (we can think of this as a copy of that value) in the variable named a. For example, the statement:\nx \u003c- \"Hello World\" will store the string value “Hello World” into a new variable named x. Pretty handy!\nNow, let’s cover some important rules related to assignment statements:\nAssignment statements are always written with the variable on the left, and an expression on the right. We cannot reverse the statement and say expression -\u003e x in programming like we can in math. In mathematical terms, this means an assignment statement is not commutative. The left side of an assignment statement must be a location where a value can be stored. For now, we only have single variables in our pseudocode so that’s all we’ll use, but later on in this course we’ll learn about lists as another way to store data. The right side of an assignment statement must be an expression that evaluates to a value that can be stored in the location given on the left side. We’ll spend more time discussing this in future labs, but it is an important rule to know. Using Variables Once we’ve created a variable, we can use a variable in an expression to retrieve its current value. For example, we can now rewrite our previous “Hello World” program to use a variable like this:\nx \u003c- \"Hello World\" DISPLAY(x) Notice that we don’t put quotes around the variable x in the DISPLAY(expression) statement like we did before. This is because we want to evaluate the variable x and display the value it contains, not display the string \"x\". Remember that quotes are only placed around string values, but variables are used without quotes around them. So, when we run this program on our “mental model” of a computer, we should get this output:\nHello World Great! We’ve learned how to use variables in our programs.\nUpdating Variable Values We can easily update the value stored in a variable by simply using another assignment statement in our code. For example, consider this program that displays two lines of output:\nx \u003c- \"First line\\n\" DISPLAY(x) x \u003c- \"Second line\" DISPLAY(x) When we run this program, we should see the following output:\nFirst line Second line Notice how we are printing the variable x twice in the program, but each time it displayed a different value? This is because the value stored in x can change while the program is running, but when we evaluate it, we only get the value that it is currently storing. This is why we call items like x variables - because their value can change!\nnote-2 Let’s talk about variable names for a minute. There is an old joke in computer science that says “the two most difficult things in computer science are dealing with cache invalidation and naming things.” We won’t learn about cache invalidation for a while (it’s a pretty advanced topic), but as we spend more time writing code, we’ll probably find out that coming up with good and useful variable names can indeed be difficult. It might even derail your progress for a bit while you try to come up with the most perfect variable name ever.\nMost languages have some rules for how variables should be named, and our pseudocode is no different. Likewise, there are some conventions that most programmers follow when naming variables, even though they aren’t required to. Thankfully, these conventions can be bent or broken at times depending on the situation.\nIn this course, we’ll follow the following rules when it comes to naming variables:\nA variable name must begin with a letter. Variable names must only include letters, numbers, and underscores. No other symbols, including spaces, are allowed. Beyond that, here are a few conventions that you should follow when naming your variables:\nVariables should have a descriptive name, like total or average, that makes it clear what the variable is used for. Variables should be named using Snake Case. This means that spaces are represented by underscores _, as in number_of_inputs Try to use traditional variable names only for their specific uses. Some examples of traditional variable names: tmp or temp are temporary variables. i, j, and k are iterator variables (we’ll learn about those later). x, y, and z are coordinates in a coordinate plane. r, g, b, a are colors in an RGB color system. Variables should not have the same name as keywords or any built-in statements or expressions in the language. For example, our pseudocode has a DISPLAY() statement, so we should not name a variable DISPLAY in our language. In general, longer variable names are more useful than short ones, even if they are more difficult to type. That said, in many of the code reading and writing examples in this course, you’ll see lots of simple variable names that are not descriptive at all. This is because the point of the exercise is to read and understand the code itself, not simply inferring what it does based on the variable names. We’ll still follow the rules, but we may ignore some or all of the conventions in our code.\n",
    "description": "",
    "tags": null,
    "title": "Pseudocode Variables",
    "uri": "/x-cis115-labs/2-print-variables/04-pseudocode-variables/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "MarI/O - Machine Learning for Video Games",
    "uri": "/iii-topics/18-ai/08-mario/"
  },
  {
    "content": " Resources Slides Video Script Of course, the impact of cracking the Enigma machine cannot be understated. It’s probably best put by Sir Harry Hensley, who is a British intelligence historian. And he wrote, “My own conclusion is that it shortened the war by not less than two years and probably by four years … we wouldn’t have in fact been able to do the Normandy landings, even if we had left the Mediterranean aside, until at the earliest 1946, probably a bit later.” So really, the ability of the Allies to decrypt and decode the German messages sent via the Enigma machine was really important toward ending the war effort. And it’s almost unfathomable to imagine how bad World War Two had been, had it gone on for two or even four more years. And, of course, this is just focusing on the work in the European Theater. There was also another program called Ultra. It was based in the Pacific Theater, focused on decrypting some of the Japanese messages that were sent during World War Two. And so later on, we may add some videos to this module discussing that program, as well.\nBut let’s move into modern days and talk a little bit about Claude Shannon again. We’ve talked about Claude Shannon several times in this class before, but one of his most lasting claims to fame is as The Father of Modern Information Theory. And his work after the war really helped build the modern cryptography systems that we use today. He realized that there was a very mathematical way that you can encrypt data so that it could be very, very difficult to decrypt that data without understanding the keys used to build it. So because of a lot of his work in the 1950s, we refer to Claude Shannon as The Father of Modern Information Theory.\nSo one of the modern forms of encryption is called symmetric key encryption. And in symmetric key encryption, we take some sort of data such as the plain text hello world, and we encrypt it using a very particular algorithm and a key. And so the algorithm uses the data that we want to encrypt and the key, and it will produce what’s called ciphertext. And so the ciphertext is the encrypted form of the data that we can send and receive and do everything we want. And then to decrypt it, we would use the same key and sometimes a similar algorithm or a slightly different algorithm to get back to the plain text. So symmetric key encryption does have some advantages and disadvantages. One of the biggest things to remember with symmetric key encryption is that it uses a shared secret key. Both the person encrypting the message and decrypting the message need to have a copy of the key. And so that creates this interesting problem of how do we share the key without knowing that someone else got ahold of the key. And likewise, if we encrypt something with a shared key, and the other person has lost that key, then we may not know who has access to that data, making it really kind of complex. However, shared key encryption and symmetric key encryption does still get used from time to time. Most of the time, it’s used for file encryption, things like encrypted zip files, usually use symmetric key encryption. You use the same password to encrypt them as you use to decrypt them.\nThe other form of modern encryption that we’ll talk about is public key encryption. And public key encryption is a little bit more complex because it uses two different keys. So we start by generating two keys, a public key and a private key. The private key we keep for ourselves; we don’t give that to anybody else. A lot of times the private key is unique to a particular computer itself. Then we would give our public key to anybody; it’s public. We could tattoo it on our forehead. We really don’t care because that’s the public key. Then, anybody that wants to send us encrypted data, could take their data and lock it using the public key that we have made public available. And as soon as they lock it with that public key, the only person that can unlock it is the person with the matching private key. And so if they want to send something that only we can read, they lock it with our public key, and then we can unlock it with our private key. Likewise, we can go the other way, if we want to send something out to the world and have the world know that it came from us, we can lock it with our private key and post it out on the web along with our public key. And so anybody that wants to can look at that data, unlock it with our public key. And as long as they trust that that’s our public key, they know that we are the only person that could have sent that message. This is how things such as email signatures, the actual like signed signatures work. You can also do this on websites. If you look at your websites, they’ll have a lock that usually says it’s encrypted. And part of that is that the data is encrypted, but also part of that is that it’s verified that we know where that data is coming from using a process based on public key encryption. And then of course, we can combine the two. For example, if we’re sending our credit card data back and forth with a website, we can use their public key, and they can use our public key in very unique ways. For example, if we want to send our credit card data, what we could do is we could lock it using their public key so that they are the only person that can read it. But we can also sign it with our private key so that they know that the only person that could have sent that data is us. And so by combining the two, we can get both protected data, and we can get it signed and verified so we know where it came from. So let’s take a look at a quick video on Diffie-Hellman key exchange, which is how we can actually share keys back and forth and make sure that both users have a key that they can use to encrypt data.\n",
    "description": "",
    "tags": null,
    "title": "Modern Cryptography",
    "uri": "/iii-topics/16-cryptography/08-modern-crypto/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Restored PDP-1 Demonstration",
    "uri": "/iii-topics/22-graphics-and-video-games/08-pdp-demo/"
  },
  {
    "content": " Resources Slides Video Script Welcome back, everyone. Now let’s continue our discussion on interactive web technologies. So we’ve done a little bit of JavaScript so far to get our Tic Tac Toe game working. But there are a lot of other technologies out there that really make web 2.0 really work. So in concert with JavaScript, we have Ajax Ajax was released in 2005. And it allowed for a synchronous JavaScript. So really what happens with Ajax is once the web page loads, the JavaScript can run on the webpage. But what if you wanted more data from your web server? Well, typically, what would end up happening is that you would have to have the page refreshed in its entirety in order to get that web request fulfilled. But Ajax allows you to send information back and forth to your web server behind the scenes without having to have the whole entire page reload. This isn’t really useful, because we can have the entire page get loaded once, especially if it’s a really large, complicated page. And then your JavaScript can handle sending requests back and forth to your web server to reload certain things. Like for example, new comments that were on the page, a new likes, or even maybe a new reply to a Reddit thread, this drastically decreases the amount of time you spend browsing the web page by having to wait for the entire page to reload, just to see who the latest comment was on your post. Now, in this case, this also applies with XML, which we’ll talk about here in a little bit. Now, most Ajax anymore will actually heavily favor using JSON, which we’ll also talk about here in a little bit. But let’s take a look at XML first. xml stands for the Extensible Markup Language, oh, what really XML is, is kind of looks like HTML.\nSo HTML works off of a series of tags, just like what XML works off of within this particular set of XML data, we have our person all the way up here at the top, our person is the top level object or top level tag here, and a person has certain attributes for them. So this particular person, as a first name of john, and a last name of Smith, in age of 25, it also has an address, and this address has different elements about it. So this address has a city postal code, state street address, and so on. And so notice each bit of information has a tag that describes it, and a closing tag, that opening closing tag nerves, the actual information, and the tag name itself describes that information. So this is a pretty useful way of sending information, especially in the early days, the internet. And a lot of other applet types of applications actually use XML to send information like this as well. json works in a very similar manner. json or JavaScript Object Notation has a series of keys and values, these keys indicate the actual description of the data. And the value is the of course, the actual data itself. So we have this exact same sort of object that we had from last time from the XML. But instead of having a top level type of person, now we have a JSON object. JSON objects are denoted using a set of curly brackets. And inside here are our each of our particular elements. So we have a first name element. And then that first name has a value of john, the same thing with last name, age. And so you can kind of notice we’re mixing data types.\nSo here, we have strings, and here we have an int. Now, to denote sub objects, we have a address which value is a JSON object. So we can nest JSON objects inside of JSON objects, which helps denote relationships between attributes or between elements just like what we had with our XML, which had nested tags and other things here, we can also have a list. So we here with this person has multiple phone numbers. So we have a list of JSON objects here, which also have elements inside of it with data associated with it. And so a lot of what JavaScript actually works with most things that have multiple pieces of information about it, like a person or maybe a car, or whatever it may be, typically is represented as a JSON object. Now, many other languages use this sort of syntax for a lot of different things, for example, and Python. When we cover dictionaries and Python, you’ll actually notice that the sentence Tax and representation in Python for dictionaries is very, very similar to how JSON objects are actually represented. They work very similar. But there’s a lot of different technologies out there in the web, especially the web 2.0, with the sheer amount of different websites and the variety that we actually have, there’s a lot of different technologies that are actually running those behind the scenes. Much of the core of that, of course, is HTML, JavaScript, and CSS, especially with JavaScript, though there are a lot of different frameworks that are being used out there that have all sorts of different functionalities.\nThis functionality varies between libraries that allow you to, let’s say, graphic data, right. So make charts or these complete different frameworks that change the actual structure of your web page, like react view, or Angular JS, which are all JavaScript frameworks that are used to design more dynamic web pages using templates, a lot of what react view and angular do mixes a lot of what JavaScript and Ajax tried to accomplish. So you’re only sending the smallest amount of data or refreshing the smallest amount of the webpage at any given time. And you’re dynamically generating a lot of that content instead of statically, creating it. Or you also have things like SAS or SAS, which is a better way of organizing and structuring structuring your CSS. So there’s a lot of different packages, frameworks and libraries out there that we can use, make very beautiful dynamic webpages. And depending on your use case, there’s probably a library out there that will help you and help you either improve your code, or make your project better. These are just some of the current popular technologies that are being used right now. But Lastly, I kinda want to conclude our talk on web 2.0, because this is the last major web module or internet module that we have for this course. Now, as we mentioned, right web one point O is very static web 2.0 is very dynamic. And we’ve been kind of repeating this throughout these modules. But it’s not just about the technology.\nBut Web 2.0 has really enabled us as a society to interact and relate in an entirely different way than we’ve ever been able to before in the past. And even now, even then, past 10 years, web 2.0 has grown, especially in regards to things like social media, social media has significantly taken off compared to 10-15 years ago when it was just in its infancy stages. And so as you work around on the internet, try to think about, or reflect about how the switch and web technologies and the advancements of web technologies has really impacted you on how you actually work in your daily life, how you interact with your friends and family. But the last thing I want to close with is the machine is us/ing us, which is a video made by one of K-State’s professors, Dr. Michael Wesch, who works in the anthropology department, but I’ll link that video up for you to watch.\n",
    "description": "",
    "tags": null,
    "title": "More Web 2.0",
    "uri": "/ii-internet/13-webprog/08-more-interactive-web/"
  },
  {
    "content": " Resources Slides Video Script On October 29, 1969, the first message was transmitted across the newly created ARPANET between computers at UCLA and SRI, the Stanford Research Institute. And so in this particular picture, we see the notes from Leonard Kleinrock notebook taken on October 29, 1969, showing that they talked to SRI hosts to host and it was really revolutionary moment on the internet. Because this was the first instance of a packet switch network being used that now forms the basis of the internet. Of course, it wasn’t exactly a success. They tried to transmit the word login, but only got the letters L o before the system crashed. So it wasn’t exactly a huge success, but it was a very small step toward the creation of the internet.\nAnd so with that, ARPANET was born, ARPANET was the Advanced Research Projects Agency Network, and it was really the first computer network of its kind in the United States. Connecting all sorts of research areas together. Above me is a picture of the ARPANET map from March 1977, showing several hosts all connected to the network and all the different ways that they talk to each other. It was originally started as a packet switch network of just four different sites that were connected to these devices called interface message processors, or IPS, which are really modern, early precursors to what a modern router does, taking the messages from a computer and translating it so that it can be sent over a packet switch network.\nOf course, ARPANET wasn’t the only network at that time. As we saw in the video at the beginning of this module, there are many different networks created all across the world. For example, with ARPANET by the 1970s, there were sometimes 20 new hosts coming online every day, you had the National Physical Laboratory in Great Britain, you had merits, the Michigan Educational Research Information Triad. You had supply days in France, and then you had the proliferation of public networks such as X25, and Usenet. Which were all public networks that were available through telephone providers at that time.\nBut all these different networks were disconnected you really couldn’t get from one network to the other network. And so we needed something else to really build the modern internet that we use today. And so that comes from the work of Vinton Cerf and Robert Kahn, who were two engineers for ARPANET. And they began working in the 1970s for a way that we could connect all of these computer systems together using a similar technology. And so their work really led to the creation of what we call TCP, the Transmission Control Protocol, which is the underlying technology for most computer networks today. And their work was so revolutionary that the two of them received the Presidential Medal of Freedom in 2005. So let’s take a quick look as Vinton Cerf talks a little bit about the history of the internet and around the birth of the modern internet that we know today.\n",
    "description": "",
    "tags": null,
    "title": "Part 3",
    "uri": "/ii-internet/11-internethistory/08-part3/"
  },
  {
    "content": " Resources Slides Video Script So now that we’ve learned about merge sort and quicksort, let’s take a look at the complexity of one of these algorithms. Just to understand how that works. For this example, we’re going to look at the complexity of merge sort. Let’s consider the example where we’re doing merge sort on eight numbers. So here we have the numbers 1,2,3,4,5,6,7,8. So the first step of Merge Sort would have us divide those in half into groups, 1,2,3,4, and group 5,6,7,8, then we would divide each of those in half again, ending up with four groups 1-2,3-4,5-6, and 7-8t. So this diagram helps us understand the complexity of this algorithm. And we need to measure two things. We need to measure how many swaps it can make, and then we need to measure how many divisions it makes. So let’s look at swaps first, these are all in the correct order, but we have to assume worst case. So in the worst case, we would make 1,2,3,4 swaps. So we know we need four swaps for one of our numbers. And we need to compare that to the size of the input, which is eight. So how does four compared to eight, an easy way to think of it is four is just our input size eight divided by two. That’s pretty easy. The second step is a little trickier. Because what we need to do is we need to look at how many times we have to divide the numbers to get all the way down to groups of two. And in this case, we have three levels. So we have three here, but how does three compared to eight?\nThat’s a little trickier to answer. But let’s think about what it would look like if we had four levels. How many numbers would we need to get all the way to four levels and fill four levels all the way up? As it turns out, to do that we would need to double the amount of numbers we would need to have 16 in order to fill up four layers. So how does three relate to eight in the same way that four relates to 16? This can be kind of tricky, but it actually lies in the idea of powers. Consider this, two to the power of three is eight. And likewise, two to the power four is 16. That’s where our answer lies. And it actually makes sense. We’re dividing these in half. And we do that three times for eight numbers. Likewise, if we’re dividing it in half, we would do it four times to get the 16 numbers. So how do we express this in terms of our number eight? This relies on a little bit of algebra and calculus, but the answer is in logarithms, and so this would be the logarithm of base two of N. And so that tells us that two to Two the whatever it is, is equal to eight. So we can put this all together by combining in divided by two and log base two event. And usually when we do this, we ignore the divided by two. And so we just end up with the answer in times log of in. And here specifically, we’re using lg as the shorthand for log base two. If you’re familiar with calculus, you know that In is log of e.\nIn computer science, we usually use lg as a shorthand for log base two. So as you can see, based on this analysis, mergesort runs in the complexity of nlog(n) if we graph that we find that nlog(n) is actually quite a bit shorter than n^2, meaning that as the input gets larger, Merge Sort will take many fewer steps to complete, then algorithms such as bubble sort, and Insertion Sort. Quicksort is a little bit difference. Quicksort has this really interesting worst case, where if the numbers are already sorted, and you always pick the pivot item as the last element in the list, then you’ll end up basically doing Insertion Sort every single time. And so it’s worst case is actually big O of n^2. However, in practice, if you pick a pivot item that is close to the middle of your input, then the average case for quicksort is big O of nlog(n) and in practicality, quicksort is usually the fastest of the sorting algorithms on random input data. So let’s take that idea a little bit further, we can look at these different sorting algorithms and determine exactly when they might be useful.\nFor example, Insertion Sort might be pretty useful in certain cases where there’s a small set of numbers, or maybe while we’re getting numbers one at a time and we just want to insert them in the proper place in an array bubblesort is really useful when we know the data is nearly sorted, because we only have to bubble a few items around till we get to the point where bubblesort has Completed because there’s no more swaps to make. Merge Sort is really good when we know nothing about our data, or if we’re worried about the size of our data not being big enough, or not being small enough to fit in memory. And of course, quicksort besides that really bad worst case is generally the fastest performing algorithm. So as long as we’re sure that we’re not going to run into that worst case, very often, we can generally use quicksort as a really great sorting algorithm in our code.\n",
    "description": "",
    "tags": null,
    "title": "Complexity Part 2",
    "uri": "/i-concepts/06-algorithms/09-complexity-2/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Modern Turing Machines",
    "uri": "/i-concepts/05-universal-computers/08-modern-turing/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "User Centered Design - Don Norman",
    "uri": "/i-concepts/10-hci/08-user-centered/"
  },
  {
    "content": " Resources Slides Code.org Quotes Video Script Finally, before embarking on this program, let’s take a brief minute to review what you’ll learn by the time you complete the program.\nOf course, the biggest and most impactful outcome will be learning how to write computer programs. Throughout the Computational Core program, you’ll learn either the Java or Python programming language, and get to a point where you are quite proficient with your language of choice. You’ll be capable of building your own programs from scratch to meet many of the challenges you’ll encounter in your career or elsewhere. This skill alone will set you well above your peers.\nThere are many additional benefits beyond just learning how to write programs. For starters, programming involves a large amount of problem solving and computational thinking, and these courses will help sharpen you skills in both areas. In addition to programming, you’ll also learn about software engineering methods that will help you build better programs, but also data structures and algorithms that will make your code more efficient and useful as it manipulates and stores data. Of course, you’ll also pick up some new math and logic skills, as both are vitally important to understanding computer code. Lastly, we’ll spend a bit of time discussing how computers actually work, so you can see how your code actually gets a computer to perform the tasks you desire.\nFinally, you may be asking yourself why this is important. I could absolutely bring out large numbers of statistics stating how many computer programming jobs are available right now, and how we have a distinct lack of capable graduates to fill these positions. I could also talk about how much more money you could make as a computer programmer than in many other fields. But, instead, I think it is best to just present this quote from Stephen Hawking, one of the most brilliant people to ever live:\nWhether you want to uncover the secrets of the universe, or you just want to pursue a career in the 21st century, basic computer programming is an essential skill to learn. - Stephen Hawking\nThis is just one of the many great quotes encouraging you to learn computer programming from Code.org. I highly recommend checking out their quote archive whenever you need additional inspiration.\nThat should cover all of the background information you’ll need before you start this program. The rest of this module includes the full course syllabus and a few assignments that you should read through before beginning the course, but you don’t have to do anything else for them right now. Finally, this module wraps up with a quick quiz making sure you are 100% ready to take this course.\nBest of luck to you on your adventure through this program!\n",
    "description": "",
    "tags": null,
    "title": "What You'll Learn",
    "uri": "/00-introduction/04-what-youll-learn/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "IBM's Watson",
    "uri": "/iii-topics/18-ai/09-ibm-watson/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Steve Russell talks about his early video game Spacewar!",
    "uri": "/iii-topics/22-graphics-and-video-games/09-spacewar/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Internet History part 4: Vint Cerf on the Birth of the Internet in 1983",
    "uri": "/ii-internet/11-internethistory/09-vint-cerf/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Public Key Cryptography: Diffie-Hellman Key Exchange (short version)",
    "uri": "/iii-topics/16-cryptography/09-diffie-hellman/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "The Machine is Us/ing Us (Final Version)",
    "uri": "/ii-internet/13-webprog/09-machine-us/"
  },
  {
    "content": " Resources Slides Video Script So far in this module, we’ve studied algorithms, and remember that an algorithm is a specific set of steps that we can use to solve a problem. However, what if we’re faced with a problem that we can’t solve? Either because it’s impossible, or because we have so much data that we can’t possibly find the one right answer using an algorithm. In that case, we would use something we call a heuristic. A heuristic is an experience based technique we can use to find a satisfactory solution to a problem, which may or may not be the absolute best solution to that problem. For example, if we have a particular person, and we’d like to know what their height is, we could actually get out a tape measure and measure it. Or we could use a heuristic and say, well, you’re standing next to that door and you look like you’re about six feet tall. That would be an experience based technique or a heuristic to estimate how tall someone is. We of course, use heuristics every day. For example, we use the rule of thumb when Trying to measure things. We can take educated guesses based on our previous experience, we can use our common sense and find answers that seem logical. We can try an answer and see if we can work backwards and prove that that is an answer to the question. Or we can even take our problem and try and do a simpler problem first and use that information to solve our larger problem.\nThe whole idea of heuristics lies in this graph on trade offs. This graph is very common in business circles. For example, in a business, it’s usually said that you can have fast good or cheap, pick two. So you can have things that are fast and good. You can have things that are fast and cheap. And you can have things that are good and cheap, but not necessarily fast. I usually like to apply this diagram to fast food. You can think about your favorite fast food restaurants and place them somewhere in this diagram. Are they fast and good, but not necessarily cheap? Are they fast and cheap, but maybe not the best food you’ve had? Or are they good and cheap, but sometimes it takes a little bit to get your food It’s really interesting to think about this diagram and the different things that we interact with in the world. Algorithms usually lie on the scale of good, they find the one right answer. They may be fast. They may be cheap in terms of memory or processor usage, but they generally will find the one right answer. For heuristics, we’re looking closer to the fast and cheap side of this diagram, we can find an answer that is quick and we can find one that is very cheap to compute, but it may or may not be as good as the one right answer we could find using an algorithm. We just hope that it’s good enough to be useful for our needs.\nLet’s take a look at one common problem in computer science and see how we can apply a heuristic to solve this problem is called the Traveling Salesman Problem. The idea behind the Traveling Salesman Problem is that everyday a salesman has to set out from home and would like to visit all the towns on the map and make it home as soon as possible. And so here we have a very simple map that contains four towns and edges between the towns are the roads that are labeled with the distance between each town. So looking at this map, can we find a way that we can find a route between all four of these towns that is the shortest as possible. There are some algorithms that we can use to solve this problem. For example, we could use a brute force algorithm, we can just compute every possible path, which would be in the time of big O of n!. If you know what factorial is, you know that that’s a very big number. For example, eight factorial would require 40,320 steps to solve this problem. It’s a very, very, very large number. You using some advanced programming techniques, such as dynamic programming, we can cut this algorithm down to big O of 2^n, which is still a big number for eight cities that requires 256 steps, but it’s not easy and it’s not cheap to perform. However, there is this really cool heuristic that we can use.\nFor the Traveling Salesman Problem. We can just pick any city as our City. In this example, we’ll use B. And then we’ll just go to the next closest city we haven’t been to yet. And from that city will go to the next closest city from there. And we’ll repeat this process until we visited all of the cities. So here’s a graphic showing what the greedy solution might look like. We start at City B, and we noticed that City A is the closest city that we haven’t been to, then from A, we can either go 42 miles to city C, or 35 miles to city D. So we’ll go 35 miles to city D. And finally, from there, the only city we haven’t been to a C, and so that will get us all of our diagram. So this solution requires 67 miles to complete the path is this the fastest way we could visit all four cities. As it turns out, there is a better solution to this. We’ll look at that in just a minute. So this greedy algorithm runs in big O of (d*n) where d is the number of dimensions in the graph and ins the number of cities. So on a two dimensional graph with eight cities We would have 16 steps. That’s much, much less than the 256 or 40,000 steps that we saw in an earlier example. Now, of course, the time that it takes to do this can vary widely based on how the data is presented and how it’s sorted. But this is a pretty simple example. And actual optimal solution to this problem would require us to start at either city A or C,B,D. And of course, here we find an optimal solution of 62 miles.\nSo why is the Traveling Salesman Problem so important in computer science? Well, let’s consider one use of this problem, which is deliveries. For example, delivery companies, such as Amazon and UPS and FedEx and the United States Postal Service basically have to solve the Traveling Salesman Problem every single day. They have a set of locations that they need to visit, and they want to visit those locations in the most efficient way possible. And so these companies have invested lots of time and resources in computer systems that can help them solve this problem very efficiently. They come up with some very unique solutions. For example, there’s some information online about how ups, for example, solves this problem such that its trucks don’t have to make many left turns, because they found that the time they spent waiting at a turn before they can make a left turn is wasted. And so they try and build the routes in such a way that they’re always making right turns so that it’s very quick and efficient. So heuristics are just one example of ways that we can solve problems in computer science without using a particular algorithm that gets the right answer. Of course, heuristics are just another form of an algorithm. But the important thing to remember is with a heuristic we’re trying to find a best answer that may not exactly be the most correct answer possible. But heuristics are at the core of a lot of what we do in computer science today, such as artificial intelligence and machine learning. All of the things that are related to that build upon this idea of heuristics, we’re trying to find an answer that seems most likely, which may or may not be the actually correct answer that we’re thinking of.\n",
    "description": "",
    "tags": null,
    "title": "Heuristics",
    "uri": "/i-concepts/06-algorithms/10-heuristics/"
  },
  {
    "content": " Resources Slides Video Script Hello everyone in this video we’re going to take a look at a detailed example on how a Turing machine may actually perform a common operation that we would do with a regular program. Remember that our Turing machine has eight simple instructions that it can execute using the control arm or the the reader that the machine or the program is actually loaded on. But it can simply move left or right one, it can write ones and zeros and it can also read and also jump around in the program as well. So these eight simple steps remember represent a truly universal computer given enough time, and given enough memory, it can perform any operation any other real world computer could actually do. So here’s an example of a basic program on our Turing machine. So our reader or the Turing machine itself would be preloaded with this program. In this situation, we’re going to assume that we start with two elements or two items or two pieces of data on our tape. And these items, remember, all we’re dealing with here are ones and zeros, nothing else.\nSo we’ll start with two binary digits on our tape. And then the program has just a finite number of steps here, so steps one through 11. And you can see here we jump around a little bit. For example, in step one, if we read a one on the tape, then we’re going to jump to step number five in our program. So the go to number five isn’t a step to number five in our tape, it is go to number five in our actual programs, line five in our program. For this example we’re actually going to do here is we’re going to step through our program overall and try to figure out what kind of operation it’s actually trying to perform is just looking at this straight up. It’s kind of hard to tell what we’re actually trying to accomplish or what the Turing machine is actually trying to accomplish.\nSo let’s work out this example here. So since we only start with two binary digits on our tape, that really means we only have four possible combinations in total, right, we only have two binary digits to the power of two is four. So this is the number of combinations of those two digits that we might actually have. So let’s go ahead and write to these different combinations out here. We have 0 0. We have 0 1, 1 0, and finally, 1 1. So I’m going to go ahead and label these different cases here. So we can kind of keep track of them a little bit better. So this is case A, B, C, and let’s call this one over here. D Now this is a little bit different than how we would normally actually read things. In this case for my Turing machine, I’m going to read my inputs or start my inputs from left to right. So if we start out our program here at step number one, I’m going to go ahead and just work on example A here first or this data A here first, to our head, our reader, our Turing machine, starts looking at the first square out. Step number one, and our program says if one, go to Step Five. Now, the data that we have here is actually just a zero, so we’re not going to jump to step five. So we’ll actually just continue on and go to step number two.\nNow notice that my head over here, or where my Turing machine is actually reading from does not actually move until I tell it to. Now step two does tell us to move left. And so you can either imagine this as the head moving left, or the tape moving in the opposite direction. And so what that actually causes us to do is we’re going to no longer be in that spot are going to move on to this square. So then let’s continue on to our next step here. So we already move left and so we’ll keep on executing our program sequentially. So at step number three, we have if 0, go to step nine. So if 0 is true. So we were reading a 0 here, I’m going to jump from step three, all the way down to step nine. Step nine, says move left. So we’re going to move our tape over here to this empty square. And then we’re going to go down to the next step, step 10. Step 10 says write a 0. So my, machine is going to write a zero here. And then we’ll continue on to our next step of our program, and our Turing machine stops. So our output here, this is our output, what our machine actually wrote out as a result of running our program, given the starting data.\nLet’s continue on. Let’s go and look at another example here. So if we look at our second data set here, we are going to again, start at our first position here. And start out at number one on our slides over here or on our on our list over here. So if one, go to Step five, and so this indeed is a one. So that is that is good. And so we’re going to skip steps two, three and four, and go down to step five. Step five tells us to move left. So I’m going to move left here. And that’s step five. And then step six says move left again, though, we’re going to stop that, move our Turing machine, head over one. Step seven, tells us to write a one. And then we go down to step eight, and that says, Stop. So this was the result of doing our data B over here. This particular example. So our first one, we read two zeros and output at zero. In this case, we read a one. And then we, we moved over to zero, but we didn’t actually read this one, right? Remember, we didn’t actually read the second data piece, we only read our first piece of information, and then we skipped over zero and then wrote a one in our empty spot. So let’s do more examples.\nYou still have C, and D to go. So again, we’re going to start out over here at our first piece of information. Step one, right, step one, go to Step five, so that’s not true. So we’re going to jump down here to step number two. Step number two says move left. So we’re going to move left one Then continue on to Step three. That three says if zero go to nine, well, that’s not true because we’re at a, our, our current carrying machine tape square has a one on it, it will go down to step four, which says if one go to Step six, which is true, though, that is true. So we’re going to go to step number six, then that tells us to move left, go on to Step seven. Step seven, tells us to write a one and then the top. So very similar case as what we had for be here where we read a one, skip to zero, wrote one. Here, we wrote as we read a zero, move left, write a one and then output it. And then finally, just to kind of put this last the this dataset to rest here, let’s check out D. This will be the final indicator for what kind of operation that we’re actually trying to showcase here.\nSo just like what we’ve done before, we’re going to start out at our first square on our Turing machine tape. And then of course, start out at our first step in our program. So if one go to step number five, so our square that we’re at is indeed a one. So we’re going to skip all the way down here to step number five. Step number five, says, move left though, I’m going to move the machine over one. Step six says move left. I’m going to move over one again. Then, step seven says write a one. Oh, well, let’s try to one here and that square and then Stop. So that’s pretty much it for our particular Turing machine example, for this particular program, we’ve covered all of the different combinations of data that we possibly could have on our tape for this particular program.\nNow, what kind of operation Could you imagine would actually be represented here? Oh, really, the hint is how the program or what the program outputted when we actually read our ones and zeros out, the only time that we actually out voted a, we wrote out a zero was when both of our inputs here were heroes. Right? So when we had two zeros, so remember, zero meaning false and one meaning true in binary, so, zero and zero is zero. So starting to look like a Boolean operator. So if we come down and look at B. So we have for a we had zero whatever the operator is zero, and that equals zero. So for B, we had, we had one , zero, which is one, for C, we had zero, one. And that was a one. And then for D, we had one, one, which is one. Now, what is the binary or not that sorry, not the binary, the Boolean operator that unifies all of these statements. Well, it’s not AND right, because if and was the operator here, this would output false ,right, so one and zero would be zero not one, or true and false is false. So it’s not that and it’s not the exclusive OR either because exclusive OR would have made D equal false. So one XOR one would be to write because XOR is one or the other, but not both. So really the only to the left, the only Boolean operator that takes two operands right, left hand and right hand side, the only one that we have left is OR so if we put OR here, zero or zero is 0, 1, OR zero is one, zero OR one is one, and one OR one is one. So this Turing machine is simply OR Or you can, if you remember from the Boolean algebra, right, it’s For our examples that we’re going to be doing in class other examples that we’ll be doing in class will have you try your shot at trying to analyze a Turing machine program to figure out what kind of Boolean operator it may be, or even making your own Boolean operator program as as a Turing machine.\n",
    "description": "",
    "tags": null,
    "title": "Turing Machine Example",
    "uri": "/i-concepts/05-universal-computers/09-turing-machine-example/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Graphical User Interfaces (Crash Course) ",
    "uri": "/i-concepts/10-hci/09-gui-crash-course/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nPython Dictionaries Dictionaries in Python allow us to store key-value pairs in a single data structure. Keys are used to uniquely identify an associated value.\nDictionaries can be created using curly brackets {}:\ndict_1 = {} dict_2 = {\"a\": 1, \"b\": 2, \"c\": 3} Adding and Accessing Dictionary Items New elements can be added to a dictionary by providing a new key in square brackets:\ndict_2 = {\"a\": 1, \"b\": 2, \"c\": 3} dict_2[\"d\"] = 4 Items can also be accessed and updated using square brackets\ndict_2 = {\"a\": 1, \"b\": 2, \"c\": 3} dict_2[\"c\"] = dict_2[\"a\"] + dict_2[\"b\"] Loops with Dictionaries Dictionaries can be iterated by just the keys or by the keys and values in a tuple:\ndict_3 = { \"cat\": \"mammal\", \"lizard\": \"reptile\", \"goldfish\": \"fish\", \"chickadee\": \"bird\" } # keys only for key in dict_3: print(\"{}: {}\".format(key, dict_3[key])) # keys and values for key, value in dict_3.items(): print(\"{}: {}\".format(key, value)) Functions with Dictionaries When calling a function that accepts a dictionary as a parameter, the argument is passed using call by reference instead of call by value. The original dictionary can be modified by the function, but it cannot be replaced with a new dictionary unless the reference to that new dictionary is returned from the function.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/14-dictionaries/05-summary/"
  },
  {
    "content": " Resources Slides Throughout this course, we’ve seen several different ways to work with strings. In Python, just like in many other programming languages, it is possible to treat strings as a list of individual characters. Because of this, we can write many useful programs that use and manipulate strings in a variety of ways.\nLet’s look at one quick example program that can manipulate strings just like a list! Consider the following Python program:\nimport random import string def encode(secret, step): output = \"\" for i in secret: output = output + i for j in step: output = output + random.choice(string.ascii_lowercase) return output def decode(code, step): return code[::step] def main(): secret = input(\"Enter a secret word\") step = int(input(\"Enter a positive integer\")) code = encode(secret, step) print(\"Your code is:\") print(code) print() decoded = decode(code, step) print(\"I can decode it back to:\") print(decoded) main() This is a very simple encoding program that will allow the user to enter a secret phrase, encode it by inserting many random characters between the characters of the word itself, and then show that it can be decoded once again. This is very similar to how a Scytale encodes messages.\nLet’s briefly walk through this example using Python Tutor to see how it works. As always, we can copy and paste this code in the tutor.py file in Codio, or click this Python Tutor link to open it in a browser window.\nWe can skip ahead to the point where the code enters the main function, as shown in this state:\nLet’s assume that the user inputs the string \"password\" for the secret word. That will be stored in the secret variable. On the next line, we’ll ask the user to input a positive integer:\nFor this input, we’ll assume the user chooses to input the number $5$. So, we’ll store that in the step variable in our main() function, as shown here:\nAt this point, we’re ready to call the encode() function, which requires two parameters. We’ll use the variables secret and step as the arguments to those parameters, so Python Tutor will create a new frame for the encode() function and store those values within it:\nAt this point, we can notice one very important difference between strings and lists. Even though a string can be treated like a list, as we’ll see in this example program, it is still stored as a single variable item in the frame. So, the encode() function’s frame now contains a copy of the string secret, not a pointer to the original variable in the main() function’s frame. Technically, we would say that strings are an immutable data type, so we cannot change them from within a function like we can do with lists.\nInside of the encode() function, we’ll start by creating a new variable output, which is initially set to store an empty string.\nThen, we’ll reach a for loop. This for loop will iterate through each character in the secret string, one at a time. So, just like with a list, each character will be stored in the iterator variable i so we can use it inside of our for loop. For the first iteration, we’ll store the character 'p' in the iterator variable i, then we’ll enter the loop:\nInside of the loop, the first step is to append the current iterator variable i to the output string. So, we’ll place the character 'p' at the end of that string:\nThen, we’ll reach a second for loop. This loop will repeat step - 1 times, so we’ll enter the loop and set the iterator variable j to be $0$ initially.\nInside of this loop, we have one complex line of code that we haven’t seen before. First, we have the string.ascii_lowercase list, which is a built-in list that is part of the string library which contains all $26$ lowercase letters of the English alphabet. To use this list, we have to include the import string line at the top of our file. Then, we use a special function named random.choice(), which is used to choose a random element from a list. So, we’ll also have to include the import random line at the top of our file to use that library as well. Finally, we’ll add that character to the end of the output string.\nWe’ll repeat this process a few more times. Once we exit the innermost for loop, we should be at this state:\nIn the output variable, we now see the first character of our secret word, 'p', followed by four random characters. These random characters make it more difficult for someone to decode our message. We’ll repeat this process for each of the other letters in our secret word. So, at the end of the encode() function, we should be at this state:\nAs we can see, the output variable appears to be completely random at first glance, which is exactly what we want. At this point, the encode() function will return that string back to the main() function, and it will be stored in the code variable there.\nNext, the main() function will print out some helpful output, and then eventually it will reach the line that calls the decode() function.\nOnce again, we’ll copy the values in the code and step variables to the decode() function’s frame since they are provided as arguments, and then we’ll enter the decode() function:\nIn this function, we see that we can decode our encoded phrase using a simple slicing operation, with the step variable providing the key we need to get our secret word out of the encoded string. We’ll return that back to the main() function:\nThere we go! We’ve shown that we can easily construct an encoded phrase in a string using a secret word and a step variable, and then we can decode that phrase using a simple string slice. At the same time, we were able to explore how strings can be used like lists by iterating through a string and creating slices of a string, but also that strings are immutable and aren’t passed using call by reference like lists are. Instead, strings use call by value in Python, so we have to remember to return our updated strings at the end of any functions that manipulate them.\nThankfully, being able to work with strings in Python using the same methods as lists makes it very easy to write a wide variety of programs that create and manipulate strings!\n",
    "description": "",
    "tags": null,
    "title": "Strings are Lists",
    "uri": "/x-cis115-labs/13-lists/05-strings-are-lists/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nNested Loops Loops in Python can be nested, just like any other statement. While loops and for loops can be nested in any combination.\nTesting Nested Loops When testing nested loops, it is important to consider situations where a loop will be executed and where it will be bypassed. It is also important to consider the loop variants for while loops to ensure that there aren’t situations where a loop will accidentally run infinitely.\nEfficiency Nested loops can result in programs that execute many individual steps, even using just a few lines of code. It is always helpful to think about the number of times a loop will execute and make sure that it isn’t executing more times than necessary.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/12-nested-loops/05-summary/"
  },
  {
    "content": " Resources Slides Let’s go through a complete worked example program so we can see how to use loops to transform a problem statement into a working program. Once we’re done, we’ll also talk about how we can test the program to determine if it works correctly and won’t run into an error.\nProblem Statement For this example, we’re going to write a simple program to play a variant of the game Nim known as the 21 Game. Here are the rules:\nThe game begins with the first player choosing either $1$, $2$, or $3$. Then, the second player chooses either $1$, $2$ or $3$ and adds that number to the number chosen by the first player to establish a total. The game continues by alternating between players, each choosing to add either $1$, $2$ or $3$ to the total. The game is over when the total reaches $21$ or higher. The player who adds the number to the total that causes the game to end is the loser.\nThis is a very simple game, and a great example of how loops can be used in a program in a variety of different ways. So, let’s see what it takes to create this program.\nBasic Structure To begin, we need to start with a main() procedure and a call to the main() procedure, as shown here:\nPROCEDURE main() { } main() Next, we know that the program will repeat until the total is greater than or equal to $21$. So, we can easily add a variable to keep track of the total, and a loop that will represent the actual game being played.\nPROCEDURE main() { total \u003c- 0 REPEAT WHILE(total \u003c= 21) { # players take turns } # game over } main() We also need some way to keep track of which player’s turn it is. So, we’ll need a variable to track that, as well as a simple conditional statement at the end of our loop to switch between the two players. In pseudocode, that would look like this:\nPROCEDURE main() { total \u003c- 0 player \u003c- 1 REPEAT WHILE(total \u003c= 21) { # player's turn IF(player = 1) { player = 2 } ELSE { player = 1 } } # game over } main() As we can see, we just use a variable that switches between the values $1$ and $2$ to keep track of the current player. At the end of the loop, we have a conditional statement that checks the current value of that variable, and then switches it to the other value. This allows our players to take turns within a single loop.\nHandling Input Next, we need a way for our players to provide input. Thankfully, earlier in this lab we saw a simple procedure for accepting input from a user and checking to make sure it is valid. So, we can simply borrow that procedure and tweak it a little bit to fit this scenario. Here is what that procedure would look like in pseudocode:\nPROCEDURE read_input(player) { DISPLAY(\"Enter 1, 2, or 3 for player \" + player + \": \") x \u003c- INPUT() REPEAT WHILE(x != \"1\" AND x != \"2\" AND x != \"3\") { DISPLAY(\"Invalid Input!\\n\") DISPLAY(\"Enter 1, 2, or 3 for player \" + player + \": \") x \u003c- INPUT() } RETURN NUMBER(x) } This procedure is a bit different than the previous one because it requires a parameter. The parameter is used to represent the current player, and we include that in the prompt for input to show which player’s turn it is. Without that, the game would be very confusing. We’ve also updated the Boolean expression inside of the while loop to make sure the value input is either \"1\", \"2\", or \"3\". If it isn’t, it will print an error message and prompt the same player for input again. Once a valid input has been received, it will return that value back to where this procedure was called from.\nnote-1 Unfortunately, in pseudocode, there isn’t a good way to require users to input whole numbers. For this example, the number of possible inputs is small enough that it makes the most sense to just check for the individual string values themselves, and then convert the input to a number once it has been verified. There are many other approaches in both pseudocode and Python that will achieve the same result.\nCompleting the Program Now that we have a procedure for handling input, we must simply add that procedure call to our main() procedure, and use it to update the value stored in the total. We can also add a message at the end to determine which player is the winner. The final, complete program is shown here:\nPROCEDURE read_input(player) { DISPLAY(\"Enter 1, 2, or 3 for player \" + player + \": \") x \u003c- INPUT() REPEAT WHILE(x != \"1\" AND x != \"2\" AND x != \"3\") { DISPLAY(\"Invalid Input!\\n\") DISPLAY(\"Enter 1, 2, or 3 for player \" + player + \": \") x \u003c- INPUT() } RETURN NUMBER(x) } PROCEDURE main() { total \u003c- 0 player \u003c- 1 REPEAT WHILE(total \u003c= 21) { # player's turn total \u003c- total + read_input(player) IF(player = 1) { player = 2 } ELSE { player = 1 } } # game over DISPLAY(\"Player \" + player + \" wins!\") } main() Notice at the end of the main() procedure that we are able to print the player that wins, instead of the losing player. This is because we are switching between players at the end of the while loop, so once the total reaches a value greater than or equal to $21$, we know that we’ve already switched the player variable to be the other player, instead of the one that just caused the game to end. It’s a subtle logic choice, but it works well in this case.\nTake a moment to work through this program and make sure you understand how it works. We won’t do a full code trace, but you are welcome to do so to make sure you are comfortable with it before continuing.\nTesting - Branch \u0026 Path Coverage Now that we’ve written our program, let’s test it to see if it works correctly. Testing this program is a bit different than some of the other programs we’ve created, mainly because it heavily restricts the inputs that are valid. Each player can only input the strings \"1\", \"2\", or \"3\" as valid input. Any other string is invalid, and will result in the loop inside of the read_input() procedure repeating.\nTherefore, when testing our program, we should make sure we try each of these inputs, but also try some invalid inputs as well. The order the inputs are provided also matters - for path coverage, we want to test the situation where a valid input is provided first and the loop in read_input() is skipped, and also the situation where a valid input is provided after an invalid input or two, so the loop in read_input() is executed.\nFinally, since this program will read inputs many times while it is executing, we can’t simply use multiple sets of inputs. Instead, we have to look at entire lists of inputs, where the order that they are provided matters as much as the inputs themselves.\nConsider the following list of inputs, which are marked with the player’s turn and the updated sum or error:\nInput Player Sum/Error \"1\" 1 1 \"2\" 2 3 \"3\" 1 6 \"0\" 2 error \"4\" 2 error \"1\" 2 7 \"-1\" 1 error \"5\" 1 error \"2\" 1 9 \"lizard\" 2 error \"(*\u0026#$\u0026*^@\" 2 error \"3\" 2 12 \"invalid\" 1 error \"3\" 1 15 \"broken\" 2 error \"2\" 2 17 \" \" 1 error \"1\" 1 18 \"3\" 2 21 Player 1 Wins This list represents one complete game. The first input, \"1\", will be the first input provided by player 1, then the \"2\" will be player 2’s turn, and so on. However, as the inputs progress, we start to see some invalid inputs as well. When the game receives an invalid input, the read_input() procedure will enter the loop, and the same player will be prompted for input again until a valid input is received. So, looking through this list, we see that it includes both the situation where the input provided is valid the first time, bypassing the loop, as well as situations where the initial input provided by a player is invalid, entering the loop and prompting for additional input. So, this set of input achieves path coverage in just one game!\nWe may also want to test and make sure that it is possible for both players to win. To do that, we can simply come up with another set of inputs similar to the one given above, but use different values for the valid inputs to make sure that player 2 wins that game. By doing so, we’ve achieved every possible outcome of the game.\nTesting - Loop Termination The other part of testing this program is to show that the loops will terminate properly. You won’t be required to prove this yourself in this course, but you should still think about it when designing and testing them. So, let’s briefly take a look at that process as well.\nFirst, we can look at the loop in read_input() procedure. This is a bit tricky, since the condition for repeating in the loop is entirely driven by user input. So, we really can’t say whether the loop will terminate or not, but we can easily show that if the user inputs a valid value, the loop will correctly terminate and the program can continue running. So, as far as our testing goes, that’s good enough.\nThe loop in the main() procedure is a bit different. This loop will repeat while the value stored in total is less than or equal to $21$. So, to prove this loop will terminate, we need to come up with a loop variant and show that it is reducing each time the loop is executed. Thankfully, we can just say that the loop variant is 21 - total. As the value in total increases, that value will decrease until it reaches $0$ or less.\nTo show that it is constantly decreasing, we can simply say that the read_input() procedure will always return a positive integer, and that value is added to the total each time the loop iterates. So, since total is always getting larger, the loop variant is getting smaller, and the loop will eventually terminate.\nThere we go! That’s a complete worked example for building and testing a program that contains multiple loops in different procedures. Hopefully this is helpful as you move ahead to the next part of the lab, where you are asked to create and test your own programs. Good luck!\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/10-pseudocode-loops/05-worked-example/"
  },
  {
    "content": " Resources Slides Now that we’ve learned all about using loops in Python, let’s go through a complete worked example to see how all the pieces fit together. As we continue to develop larger and more complex programs, it is helpful to observe the entire process from start to finish so we can see how to easily develop a program one step at a time. Once we’ve created our program, we’ll also perform a bit of testing to make sure that it works correctly.\nProblem Statement For this example, let’s write a program to play a simple number guessing game. Here’s how it works:\nThe game will select two random numbers from $0$ to $100$, one for each player. Then, each player will guess a number in the range, and the game will print either “higher” if that player’s secret number is larger than the guess, or “lower” if the player’s secret number is smaller than the guess. Players will alternate turns until one player correctly guesses their secret number and wins the game.\nThis game is pretty simple, but there are still quite a few different parts that we need to build in order to write the entire program. So, let’s go through the process of building a complete program in Python to play this game.\nRandom Numbers Before we start building our program, we need some way to generate a random number. Thankfully, Python has a built-in library called Random that has many functions for working with random numbers in our programs.\nTo use a library in Python, we must first import it into our code. This is done using a simple import statement at the very top of our program’s code, followed by the name of the library we want to use. So, for this library, we’ll need to have the following import statement at the top of our source code:\nimport random Once we’ve done that, we can use the function random.randint(a, b) to generate a random number that is between a and b, inclusive. Mathematically, we can say that it generates an integer $x$ such that $a \u003c= x \u003c= b$.\nSo, here’s a quick test program we can use to explore how to use random numbers in Python:\nimport random def main(): a = int(input(\"Enter a minimum value: \")) b = int(input(\"Enter a maximum value: \")) x = random.randint(a, b) print(\"A random number between {} and {} is {}\".format(a, b, x)) main() Take a minute to run this program and modify it a bit to make sure you understand how to work with random numbers in Python before continuing.\nBasic Structure In Python, we know that all of our programs must include a main() function and a call to the main() function, so we can start building our solution by creating that basic structure as shown here:\ndef main() main() In the program itself, we need to start by generating two random numbers from $0$ to $100$, one for each player. So, we can create and store those numbers in the main() function, and we’ll also need to import the random library at the top of our file.\nimport random def main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) main() Once we have the secret numbers, then we can sketch out the game itself. We’ll use a while loop to repeat until a player has guessed correctly, and we’ll also use a simple integer variable to keep track of the current player. Inside of the loop, we should get a new guess from a player, and also switch between players. So, let’s add that to our program structure using some comments:\nimport random def main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while( ): # player has not guessed correctly # swap player # get new guess from player # check if secret is higher or lower main() From here, we can start to work on the actual logic in our program.\nBoolean Expression The trickiest part of this program is coming up with the correct Boolean expression to use in our while loop. That helps us determine if the player has guessed correctly and that the loop should stop. However, this is a bit complex since there are two different players, each one with their own secret number. So, in our Boolean expressions, we have to determine what the current player is as well as whether the most recent guess was correct.\nTo do this, we can use the and and or Boolean operators to combine several Boolean expressions together. For example, we can determine if the current player is player 1 using player == 1, and then we can determine if the most recent guess is equal to player 1’s secret number using guess == p1_secret. If we want both of those to be True in order to exit the loop, we can combine them using the and operator. We can do something very similar for player 2 as well. Then, if we want the loop to terminate if either of those is true, we can combine the two statements using the or operator.\nSo, all together, we want to repeat the loop as long as that entire statement is not True. So, the full Boolean expression would be:\nnot ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret)) That’s pretty complex, but it easily encompasses all of the rules of the game!\nHandling Input To get input from the user, we can write a simple read_input() function that is very similar to the ones we saw earlier in this lab. We simply want to make sure the user has provided a value that is between $0$ and $100$, and prompt the user for another input if not. We’ll also add in a parameter to print the current player in the prompt for input.\nSo, our read_input() function might look something like this:\ndef read_input(player): x = int(input(\"Enter a guess for player {}: \".format(player))) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(\"Enter a guess for player {}: \".format(player))) return x Then, in our main() function, we can simply use the new read_input() function to read a player’s current guess as shown here:\ndef main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly # swap player guess = read_input(player) # check if secret is higher or lower main() Checking Guess and Swapping Players Next, we need to add some conditional statements to check if the secret is higher or lower than the guess, and also to swap between players. First, let’s look at swapping players. This is pretty simple, since all we need to do is find out what the current player is, and switch that value to the other player. So, we can do that using a simple if statement as shown here:\ndef main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly if player == 1: player = 2 else: player = 1 guess = read_input(player) # check if secret is higher or lower main() The process for checking a guess is very similar - we can simply check to see if the guess is higher or lower than the secret for the current player, and print the output accordingly. First, we’ll need to figure out the current player:\nif player == 1: # check player 1's secret else: # check player 2's secret Then, in each of those branches, we’ll check the guess:\nif player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") This is a pretty straightforward set of conditional statements, but it goes to show how many lines of code are required even for a simple guessing-game program like this one.\nInitial Testing and Debugging So, at this point, we can put all of the pieces together and test our program. Here is the complete program that we’ve written so far:\nimport random def read_input(player): x = int(input(\"Enter a guess for player {}: \".format(player))) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(\"Enter a guess for player {}: \".format(player))) return x def main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): if player == 1: player = 2 else: player = 1 guess = read_input(player) if player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") main() So, let’s try to run this program and see if it works. Unfortunately, right from the start we have an error in our code, since when we try to execute this program, we’ll get the following error:\nTake a minute to see if you can spot and fix the error before continuing!\nUnfortunately, in our Boolean expression inside of the while loop, we’re referencing the guess variable, but that variable isn’t actually created until later inside the while loop itself. So, we’ll need to set the guess variable to a value outside of the while loop first.\nAlso, we must be very careful about what value we use. If we set guess to be $0$ initially, there is a very small chance that player 1 could win the game immediately if their secret number is $0$, since that is a valid guess. Instead, let’s set guess to be $-1$ so that it will never be equal to a secret number.\nAfter we make that change, when we run the program again, we may notice one other error:\nCan you spot it by looking at this screenshot?\nUnfortunately, our program starts with player 2’s turn instead of player 1. Why is that? Well, if we look closely at our code, we see that we are initially setting the player to player 1, but then immediately switching players inside of the while loop before we prompt for input. If we think about it, we can’t move the code that swaps players to later in the while loop, because then our Boolean expression to determine if the while loop should terminate will be incorrect. So, instead, we can simply initialize the player variable to be $2$, and then it will be switched to $1$ before we prompt for input the first time.\nSo, our final working program’s code with these two changes is shown here:\nimport random def read_input(player): x = int(input(\"Enter a guess for player {}: \".format(player))) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(\"Enter a guess for player {}: \".format(player))) return x def main(): p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 2 guess = -1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): if player == 1: player = 2 else: player = 1 guess = read_input(player) if player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") main() A full example of running this program, complete with a very lucky guess, is shown in the screenshot below:\nTesting - Branch and Path Coverage Now that we have a complete and working program, let’s look at what it might take to test it. Unfortunately, testing a program that uses random numbers can be very tricky, since each time you run the program you might receive different outputs even if you provide the same inputs.\nThankfully, we can still perform some testing to achieve branch and path coverage by choosing our guesses carefully. Here are the basic methods we’ll want to try:\nGuessing $0$ for each player should result in \"Higher\" for output, unless the secret number is $0$. Guessing $100$ for each player should result in \"Lower\" for output, unless the secret number is $100$. Guessing the same value for one player while actually playing the game for the other player will eventually result in an output of \"Correct\". Using a bit of logic, it is always possible to win the game in no more than $7$ guesses. Trying to input an invalid value should result in \"Invalid Input!\" for output at least once. Following those simple strategies and keeping track of the various outputs received, it is pretty easy to eventually test all branches and most, if not all, possible paths through the program.\nTesting - Loop Termination Checking for loop termination on this program is a bit trickier, since the secret numbers are random and the guesses that a player makes are also unpredictable. So, while we can’t say for sure that the program will terminate, we can always prove that there is a possible condition where the loop will terminate, and that condition depends entirely on the user providing the correct input. So, as long as it is possible, we can say that the loop is at least not an infinite loop, and the program will work correctly if the user makes the correct guess.\nThere we go! We’ve just explored a complete example of writing a program in Python, complete with loops and conditional statements. We also introduced random numbers and how we can easily use those in our programs. Beyond that, we explored how to test these programs and correct minor errors found in testing. Hopefully this process is very helpful as we continue to work on larger and more complex programs.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/11-python-loops/05-worked-example/"
  },
  {
    "content": " Resources Slides Let’s go through another worked example to see how we can translate a problem statement into a working program. We’ll also take a look at how we can test the program to verify that it is working as intended.\nProblem Statement Here’s a short and simple game that can be played by two players:\nThree players each guess a positive integer greater than $0$, and then share them simultaneously. The winner is chosen following this formula:\nIf any two players have chosen the same number, the game is a tie. If all players have chosen even numbers, or all players have chosen odd numbers, then the smallest number wins. Otherwise, the largest number wins. This game has some similarities to Rock Paper Scissors, but the logic is quite a bit different. So, let’s work through how we would build this program using conditional statements.\nInitial Program Our first step should be to build a simple program that handles user input. So, we’ll create a new Python program that contains a main() function, a call to the main() function, and three variables to store user input. We’ll also use the input() function to read input, and the int() function to convert each input to an integer. Below that, we’ll add some print statements for testing. At this point, our program should look similar to this:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) # debugging statements print(\"player 1 chose {}\".format(p1)) print(\"player 2 chose {}\".format(p2)) print(\"player 3 chose {}\".format(p3)) main() With this code in place, we’ve already created a Python program that we can run and test. So, before moving on, let’s run this program at least once to verify that it works correctly. This will help us quickly detect and correct any initial errors in our program, and make it much easer to debug logic errors later on.\nSo, when we run this program, we should see output similar to this:\nChecking for Valid Input Now that we have confirmed our program is working, let’s start writing the logic in this program. Deciding which conditional statement to write first is a very important step in designing a program, but it is difficult to learn what works best without lots of practice. If we look at the problem statement above, we see that there are several clear conditions that we’ll have to check:\nAre the numbers all even? If so, which number is smallest? Are the numbers all odd? If so, which number is smallest? Are the numbers not all even or odd? If so, which number is largest? However, there is one more condition that we should also keep in mind. This one isn’t clearly stated in the rules, but implied in the problem statement itself:\nAre all numbers greater than $0$? So, to write an effective program, we should first make sure that all of the inputs are greater than $0$. We can do this using a simple conditional statement. We’ll also remove our debugging statements, as they are no longer needed:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: print(\"All numbers are greater than 0\") main() In this conditional statement, we are checking to see if any one of the numbers is less than or equal to $0$. Of course, using some Boolean algebra and De Morgan’s law, we can see that this is equivalent to checking if all numbers are not greater than $0$. Either approach is valid.\nChecking for Ties Once we know we have valid input, the next step in determining a winner is to first determine if there are any ties. For this, we simply need to check if any two players input the same number. Since there are three players, we need to have three different Boolean expressions to accomplish this. In our program, we could add a conditional statement as shown here:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") else: print(\"Not a Tie\") main() This is a pretty simple Boolean expression that will check and see if any possible pair of inputs is equal. We use the or Boolean operator here since any one of those can be true in order for the whole game to be a tie.\nAll Odds or Evens Next, let’s tackle whether the inputs are all odds or all evens. If we look at the rules above, this seems to be the next most logical thing we’ll need to know in order to determine the winner of the game. Recall that we can determine if a number is even or odd by using the modulo operator % and the number $2$. If that result is $0$, the number is even. If not, the number is odd.\nIn code, we can express that in a conditional statement as shown here:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: print(\"All numbers are even\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: print(\"All numbers are odd\") else: print(\"Numbers are both even and odd\") main() Notice that we are using the and Boolean operator in these conditional statements, because we want to be sure that all numbers are either even or odd.\nIn this example, we’re also choosing to use chained conditional statements with the elif keyword instead of nesting the conditionals. This helps clearly show that each outcome is mutually exclusive from the other outcomes.\nHowever, we chose to nest the program logic inside of the outermost conditional statement, which checks for valid input. This helps us clearly see the part of the program that is determining who wins the game, and the part of the program that is validating the input. Later on, we’ll see how we can rewrite that conditional statement into a loop to prompt the user for new input, so it makes sense for us to keep it separate for now.\nDetermining the Smallest Number Once we know if the numbers are either all even or all odd, we know that the winning number is the smallest number of the three inputs. So, how can we determine which number is the smallest? We can use a couple of nested conditional statements!\nLet’s handle the situation where all numbers are even first. We know that the smallest number must be smaller than both other numbers. So, we can use a couple of Boolean expressions to check if that is the case for each number:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: print(\"All numbers are odd\") else: print(\"Numbers are both even and odd\") main() Here, we start by checking if player 1’s number is smaller than both player 2’s and player 3’s. If so, then player 1 is the winner. If not, we do the same for player 2’s number. If neither player 1 nor player 2 has the smallest number, then we can assume that player 3 is the winner without even checking.\nAs it turns out, we would end up using the exact same code in the situation where all numbers are odd, so for now we can just copy and paste that set of conditional statements there as well:\ndef main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") else: print(\"Numbers are both even and odd\") main() That covers the situations where all players have input either even or odd numbers. We can quickly test this program a couple of times by providing various inputs that match those cases. So, when we run this program, we should see output like this:\nMaking a Function However, as soon as we do that, we should start thinking about ways to simplify this program. This is because we are using the same exact code in multiple places in our program, which goes against one of the key principles of writing good programs: Don’t Repeat Yourself!.\nAnytime we see this happen, we should start thinking of ways to move that code into a new function. This is actually really easy to do in this case: we can simply write a function named smallest() that accepts three numbers as input, representing the three player’s guesses, and then it can print the winning player for us. So, let’s update our program to include a new function, and then call that function from within our conditional statement:\ndef smallest(p1, p2, p3): if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") def main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: smallest(p1, p2, p3) elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: smallest(p1, p2, p3) else: print(\"Numbers are both even and odd\") main() By using the same variable names as the parameters for the smallest() function, we can easily just copy/paste the conditional statement from the main() function into the smallest() function without making any changes to it. We already know it works, so we shouldn’t change it if we don’t have to.\nOnce again, now is a great time to test this program and make sure that everything is working before moving on.\nDetermining the Largest Number The last step is to determine the largest number in the case that the numbers are not all even or odd. Since we’ve already written a function named smallest() to handle the opposite, let’s quickly write another function named largest() to handle this case. We can then call that function in the False branch of our conditional statement handling the logic of the program:\ndef smallest(p1, p2, p3): if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") def largest(p1, p2, p3): if p1 \u003e p2 and p1 \u003e p3: print(\"Player 1 wins\") elif p2 \u003e p1 and p2 \u003e p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") def main(): p1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: smallest(p1, p2, p3) elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: smallest(p1, p2, p3) else: largest(p1, p2, p3) main() There we go! We’ve written a complete program that implements the problem statement given above. Did you think it would end up being this complex? Sometimes even a simple problem statement ends up requiring quite a bit of code to implement it fully.\nTesting - Branch Coverage The next step is to perform some testing of our program to make sure it is fully working. To do that, we need to come up with a set of inputs that would achieve branch coverage, and possibly even path coverage. However, this time our program is spread across three functions, so it makes it a bit more difficult to do. So, let’s focus on each individual function separately and see if we can find a set that work for each of them.\nMain Function First, we see the main function has 5 branches to cover, so we need to come up with 5 different sets of inputs in order to achieve branch coverage. We can keep the inputs very small, just to make our testing a bit simpler. Here are the 5 branches to cover, and an input that will reach each one:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: 2, 4, 6 All Odd: 1, 3, 5 Mixed: 1, 2, 3 Notice how we are trying to come up with the simplest possible inputs for each branch? That will make it easier to combine these inputs with the ones used in other functions to find an overall set of inputs that will achieve branch coverage for the entire program.\nSmallest Function Next, we can look at the function to find the smallest number. This function is called when the inputs are either all even or all odd. So, we know that either inputs 2, 4, 6 or 1, 3, 5 will call this function.\nWithin the function itself, we see three branches, depending on which player wins. So, if we start with the input 2, 4, 6, we’ll see that this will execute the branch where player 1 wins. To execute the other branches, we can simply reorder the inputs:\nPlayer 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 That will achieve branch coverage for the smallest() function, and even overlaps with one of the inputs used in the main() function.\nLargest Function The same applies to the function to find the largest number, but in this case we need a mix of even and odd numbers in the input. So, the input 1, 2, 3 will execute this function, and that input results in player 3 winning. Once again, we can reorder that input a bit to execute all three branches of this function:\nPlayer 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 Overall Program Therefore, based on our analysis, we can achieve branch coverage across the entire program using 9 different inputs:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: Player 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 All Odd: 1, 3, 5 Mixed: Player 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 This will execute each branch of all conditional statements in the program at least once.\nPath Coverage Once we’ve achieved branch coverage, we should also quickly look at path coverage: is there any possible pathway through this program that we haven’t tested yet? As it turns out, there are two, but they are somewhat difficult to find. Can you spot them? See if you can figure it out before continuing on in this page.\nThe paths we missed are situations where the numbers are all odd, but a player other than player 1 wins. While we tested all possible branches in the smallest() function, we didn’t test it using all odd numbers more than once. So, to truly achieve path coverage, we should add two more inputs to our list above:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: Player 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 All Odd: Player 1 Wins: 1, 3, 5 Player 2 Wins: 3, 1, 5 Player 3 Wins: 3, 5, 1 Mixed: Player 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 So, with a total of 11 inputs, we can finally say we’ve achieved both branch coverage and path coverage of this program.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/9-nested-conditionals/05-worked-example/"
  },
  {
    "content": " Resources Slides Python also supports another kind of conditional statement, the if-else statement. Just like in pseudocode, an if-else statement contains a single Boolean expression, but two blocks of code. If the Boolean expression evaluates to True, then one block of statements is executed. If it is False, then the other block will be executed.\nThe general structure of an if-else statement in Python is shown below:\nif \u003cboolean expression\u003e: \u003cblock of statements 1\u003e else: \u003cblock of statements 2\u003e Notice that the else keyword is followed by a colon, just like the first line of the if-else statement. As we’d expect, the first block of statements is executed if the \u003cboolean expression\u003e portion is True and the second block is executed if it is False.\nOnce again, let’s go through a couple of code traces using Python Tutor to explore how an if-else statement works in Python.\nCode Tracing Example - True Here’s a simple Python program that contains an if-else statement:\ndef main(): x = int(input(\"Enter a number: \")) if x \u003e= 0: print(\"Your number is positive!\") else: print(\"Your number is negative\") print(\"Thanks for playing!\") main() This program accepts an input from the user, converts it to an integer, and then determines if the integer is a positive or negative number. Let’s go through this program a couple of times in Python tutor to see how it works. As always, you can click this Python Tutor link:\nWe’ll start with the usual default state:\nLike always, Python will find the main() function and add it to the objects list. Then, it will call the main() function, and we’ll be presented with an input prompt as shown here:\nLet’s assume that the user inputs the string \"5\" here. That means that the integer value $5$ will be stored in the variable named x:\nNow we’ve reached the if-else statement. So, we’ll need to evaluate the Boolean expression x \u003e= 0. Since x is currently storing the value $5$, this expression will evaluate to True. Therefore, we’ll move into the first block of statements in the if-else statement:\nFrom here, we’ll print the message that the user’s input was a positive number, as well as the goodbye message at the end of the program. It will entirely skip the second block of statements in the if-else statement, as we can see here:\nA full execution of this program is shown in the animation below:\nCode Tracing Example - False What if the user inputs a negative value, such as $-7$? In that case, we’ll be at this state in our program:\nFrom here, we’ll evaluate the Boolean expression x \u003e= 0 again. This time, however, we’ll see that it evaluates to False, so we’ll jump down to the second block of statements inside the if-else statement:\nThis will print a message to the user that the input was a negative number, and then it will print the goodbye message. We completely skipped the first block of statements:\nA complete run through this program is shown in this animation:\nSo, as we expect, an if-else statement allows us to run one block of statements or the other, based on the value of the Boolean expression. It is a very powerful piece of code, and it allows us to write programs that perform different actions based on the input provided by the user or the values of other variables.\nnote-1 Python also includes another keyword elif that is used to chain together multiple if-else statements. We’ll cover that topic in a future lab. For now, we won’t need it to complete any of this lab’s activities.\n",
    "description": "",
    "tags": null,
    "title": "Python If-Else",
    "uri": "/x-cis115-labs/7-conditionals/05-python-if-else/"
  },
  {
    "content": " Resources Slides Python also includes several operators that can be applied to one or two Boolean values. These operators make up the basis of Boolean logic, and allow us to construct complex expressions of Boolean values. Let’s quickly review the three basic Boolean operators present in Python.\nAnd Operator In Python, we use the keyword and to perform the Boolean and operation. Just like in pseudocode, this operator will return True if both input values are also True, otherwise it will return False.\nHere’s a quick example of the and operator in Python:\nx = True y = False print(x and y) When we run this Python code, we should see this output:\nFalse Since the variable y is False, the resulting value is also False.\nOr Operator Likewise, the keyword or is used in Python for the Boolean or operation. This operator will return True if either of the input values is True, but it will return False if neither of them are True.\nLet’s look at an example:\na = False b = True print(a or b) When we execute this code, we’ll get this output:\nTrue Since b is True, we know that at least one input is True and the result of a or b is also True.\nNot Operator Finally, Python uses the keyword not to represent the Boolean not operation, which simply inverts a Boolean value from True to False and vice-versa.\nHere’s an example:\nx = True print(not x) print(not not x) When we run this code, we’ll see this printed to the terminal:\nFalse True Since x is True, we know that not x is False. We can then perform the not operation again, on that result, as shown in not not x, which will result in the original value of x, which is True.\n",
    "description": "",
    "tags": null,
    "title": "Python Operators",
    "uri": "/x-cis115-labs/6-booleans/05-python-operators/"
  },
  {
    "content": "Lab 5 Input \u0026 Strings ",
    "description": "",
    "tags": null,
    "title": "Input \u0026 Strings",
    "uri": "/x-cis115-labs/5-input-strings/"
  },
  {
    "content": " Resources Slides The Python programs we’ve written up to this point are very static - each time we run the program, it will perform the same exact operations. Since we’re running these programs on a real computer, it might be helpful to build programs that can read and respond to input from the user, making them much more useful overall. Python includes many different ways to handle user input, but in this lab we’ll just focus on the simple input() function.\nInput in Python The input() function is used to display a prompt the user and then record input. It works very similarly to the INPUT() expression we’ve already seen in pseudocode, but in Python we can display the prompt to the user directly in the input() function itself.\nLet’s look at a quick example:\nname = input(\"Enter your name: \") print(\"Hello \", end=\"\") print(name) Here, we see that the input() function actually accepts a message as an argument, which will be displayed to the user. After the message is printed, the user will be given a cursor to enter text immediately after it. Once the user presses the ENTER key, the input() function will read the input that was entered and store it as a string value or str data type in the name variable.\nFor example, if the user inputs Willie Wildcat at the prompt, this program’s output will look like this:\nEnter your name: Willie Wildcat Hello Willie Wildcat We can see this even more clearly in the terminal. When we first run the program, we’ll see the prompt \"Enter your name:\" printed, followed by a cursor prompting the user to enter something:\nOnce the user types the input and presses ENTER, the rest of the program will run:\nNow we see the cursor is at the next command prompt, ready to run another program.\nNumerical Input Of course, we can also read numerical input in Python using the input() function. To do this, we must simply use either the int() or float() function to convert the input received as a string to the correct data type.\nHere’s a quick example program that requires two inputs for the price and quantity of an item being purchased:\ntext_one = input(\"Enter the price of one item: \") price = float(text_one) text_two = input(\"Enter the quantity of items: \") quantity = int(text_two) cost = price * quantity print(\"The total cost is $\", end=\"\") print(cost) If the user wishes to purchase $3$ items at the price of $2.75$ per item, then the program’s output would look like this:\nEnter the price of one item: 2.75 Enter the quantity of items: 3 The total cost is $8.25 In the program, we simply read each input from the user as a string value, then use the appropriate conversion function to convert it to the correct data type. For numbers including a decimal point, we use float(), but for whole numbers we use the int() function.\nThis works well if the user enters values that make sense. But, what if the user wishes to purchase a fraction of an item? Will this program work? Unfortunately, if the user enters a value with a decimal point for the second input, it can no longer be converted to an integer and we’ll get an error:\nEnter the price of one item: 2.75 Enter the quantity of items: 3.5 Traceback (most recent call last): File \"tutor.py\", line 4, in \u003cmodule\u003e quantity = int(text_two) ValueError: invalid literal for int() with base 10: '3.5' For right now, there’s not much we can do about that error other than write programs that clearly tell the user what type of data is expected, but later we’ll learn how to handle errors like this and prompt the user for input again.\n",
    "description": "",
    "tags": null,
    "title": "Python Input",
    "uri": "/x-cis115-labs/5-input-strings/05-python-input/"
  },
  {
    "content": "In this lab, we covered several major important topics. Let’s quickly review them.\nData Types in Pseudocode string data type stores text. Use STRING(expression) to convert an expression to a string if possible. number data type stores numbers. Use NUMBER(expression) to convert an expression to a number if possible. Math Operators in Pseudocode + Addition - Subtraction * Multiplication / Division MOD Modulo (the remainder of division) Pseudocode Order of Operations Parentheses Multiplication, Division and Modulo from left to right Addition and Subtraction from left to right Data Types in Python str data type stores text (strings). Use str(expression) to convert an expression to a string if possible. int data type stores whole numbers (integers). Use int(expression) to convert an expression to an integer if possible. float data type stored decimal numbers (floating-point). Use float(expression) to convert an expression to a floating-point value, if possible. Math Operators in Python + Addition - Subtraction * Multiplication ** Exponentiation (Power) / Division // Integer Division % Modulo (the remainder of division) Python Order of operations Parentheses Exponentiation Multiplication, Division, Integer Division, and Modulo from left to right Addition and Subtraction from left to right ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/4-math-operators/05-summary/"
  },
  {
    "content": " Resources Slides Python also supports the use of procedures, which allows us to write small pieces of code that can be repeatedly used throughout our programs. In Python, we call these procedures functions. We’ve already seen one example of a function in Python - the print statement is actually a function! Let’s look at how we can create and use functions in Python.\nCreating a Function The process of creating a function in Python is very similar to the way we created a procedure in pseudocode. A simple function in Python uses the following structure:\ndef function_name(): \u003cblock of statements\u003e Let’s break this structure down to see how it works:\nFirst, a function definition in Python begins with the word def, which is short for define. In effect, we are stating that we are defining a new function using the special def keyword. Next, we include the name of the function. Function names in Python follow the same rules as variable names: A function name must begin with a letter or underscore _. Function names beginning with an underscore _ have special meaning, so we won’t use those right now. A function name may only include letters, numbers, and underscores _. After the function name, we see a set of parentheses (). This is where we can add the parameters for the function, just like we did with procedures in pseudocode. We’ll see how to add function parameters later in this lab. Then, we end the first line of a function definition in Python with a colon :. This tells us that the block of statements below the function definition is what should be executed when we run the function. In pseudocode, we used curly braces {} here. Finally, we have the block of statements that are part of the function itself. This block of statements must be indented one level to indicate that it is part of the function and not something else. When we reach the end of the function, we cease to indent the code, which tells Python that we’ve ended the function and are starting something else. So, notice that there is no closing curly brace } or any other marker to indicate the end of the function - only the indentation tells us where the function’s code ends. Indentation in Python So, let’s discuss indentation in Python, since it is very important and is usually something that trips up new Python developers. Most programming languages use symbols such as curly braces {} to surround blocks of statements in code, making it easy to tell where one block ends and another begins. Similarly, those languages also use symbols such as semicolons ; at the end of each line of code, indicating the end of a particular statement.\nThese programming languages use those symbols to make it clear to both the developer and the computer where a particular line or block of code begins and ends, and it makes it very easy for tools to understand and run the code. As an interesting side effect, it also means that the code doesn’t need to follow any particular structure beyond the use of those symbols - many of the languages allow developers to place multiple statements, or even entire programs, on a single line of code. Likewise, indentation is completely optional, and only done to help make the code more readable.\nPython takes a different approach. Instead of using symbols like semicolons ; and curly braces {} to show the structure of the code, Python uses newlines and indentation for this purpose. By doing so, Python is simultaneously simpler (since it has fewer symbols to learn) and more complex (the indentation has meaning) than other languages. It’s really a tradeoff, though most Python programmers will admit that not having to deal with special symbols in Python is well worth the effort of making sure that the indentation is correct, especially since most other languages follow the same conventions anyway, even if it isn’t strictly required.\nSo, how can we indent code in Python? Typically, we use four consecutive spaces for each level of indentation. So, below the function definition def function_name(): shown above, we would place four spaces before the first line of the \u003cblock of statements\u003e, and then continue to do so for each line below that should be included in the function.\nThankfully, most text editors used for programming, such as Codio, Atom, Visual Studio Code, and more, are all configured to convert tabs to spaces. So, we can simply press the Tab key on the keyboard to insert the correct amount of spaces for one level of indentation. Likewise, we can usually use Shift+Tab to remove four spaces.\nFinally, it is worth noting that there is a special symbol that actually is a tab in text, which is represented as \\t in a string. Like the newline symbol, we can’t see it in our UI in most cases, but it is there. Some non-programming text editors, such as Notepad in Windows, will insert that symbol instead of four spaces when we press the Tab key. If we try to run a program that contains those symbols, the Python interpreter may not be able to read our program and will give us an error about inconsistent use of tabs and spaces. If that happens, we’ll need to make sure our program is consistently using only tabs or spaces for indentation. Most editors used for programming have a special function for converting tabs to spaces, and there are lots of online tools available for this as well.\nFunction Example Let’s look at an actual function in Python. In this case, we’ll create the simple hello_world function again in Python:\ndef hello_world(): print(\"Hello World\") Really, this structure is exactly like we’d expect it to be, based on the pseudocode we learned about earlier. We start with the def keyword, then the name of the function. After that, we have parentheses () where the parameters would go, and then a colon : to show the start of the block of statements. Inside of the function, we indent the block of statements that make up the code to be run when this function is run - in this case we just print the string \"Hello World\" to the terminal. That’s really all there is to it!\nCalling a Function Likewise, calling a function in Python is exactly the same as what we saw in pseudocode - we simply state the name of the function, followed by a set of parentheses where we would place the arguments if the function required any parameters:\nhello_world() So, a complete Python program that includes the hello_world function and calls that function would look like this:\ndef hello_world(): print(\"Hello World\") hello_world() Try placing this code in a Python file and see if you can run it. It should work!\nNotice that the function call for hello_world is not indented, and we included a couple of blank lines after the end of the definition of that function before the next piece of code. We do this for two reasons:\nWe do not indent code that is not part of the block of statements within a function. Since the function call for hello_world should not be part of the definition for the function, we don’t want to indent it. In Python, the convention is to include two blank lines at the end of a function definition. So, that is why we included two blank lines in the code. These blank lines are not required, but it is good practice to include them. Code Tracing a Function Call Finally, let’s briefly go through an example of tracing a program that includes a couple of functions and function calls. Here’s a quick example we can use:\ndef foo(): print(\"eye\") def bar(): print(\"to\") foo() bar() foo() To trace this example, copy-paste the code into the tutor.py file in the python folder in Codio, or by clicking this Python Tutor link.\nWhen the program first loads, we should see this setup:\nAgain, this is very familiar to us based on what we’ve seen so far. So, let’s click the Next \u003e button to step through the first part of the code:\nAs we can see, the first thing that Python sees is the definition for the foo function. Instead of keeping a separate list of functions, Python Tutor simply adds that function to the global frame just like any variable. The function itself is added to the Objects list, and then there is an arrow, connecting the variable in the global frame to the function in the objects list. In fact, this is exactly how Python handles functions - they are just treated like variables that are pointers to the function objects themselves! So, when we click Next \u003e again, we’ll see it do the same to the bar function as well:\nAt this point, we are ready to execute the first function call, which will run the foo function. So, when we click the Next \u003e button, we’ll see the arrow jump to the start of that function:\nHere, we see Python tutor do something a bit different than in our own code traces - instead of keeping all of the variables in a single box, it creates a new frame to keep track of the variables that are created in the foo function. When we look an example of a function with parameters, we’ll see where this becomes very useful. For now, we can just ignore it and move on by clicking Next \u003e once again:\nAt this point, the function is ready to print the string value \"eye\" to the terminal. So, if we click Next \u003e once again, we should see that reflected in the output of Python Tutor:\nAt this point, we’ve reached the end of the foo function. So, Python Tutor will remove the foo frame from the list of frames and it will jump back down to where the function was called from when we click Next \u003e:\nHere, we are back to the main piece of our code, and we’re ready to call the bar function. So, we can click Next \u003e once again:\nThis will jump up to the start of the bar function and create a new frame for storing any variables created by bar. We can click Next \u003e again to enter the function:\nAnd then click Next \u003e again to print the string value \"to\" to the output:\nOnce again, we are at the end of a function, so when we click Next \u003e once more:\nWe’ll move back to the main piece of the code, removing the frame for bar. On this line, we see yet another function call, this time to the foo function. Hopefully by this point we can predict what is going to happen, so we can click Next \u003e a few more times to jump to the foo function and execute it. When it is done, we’ll see this output:\nThere we go! We’ve successfully traced the execution of a Python program that contains multiple function calls. The full process is shown in this animation:\nUsing tools like Python Tutor to trace through code is a great way to make sure we understand exactly what our computer is doing when it is running our code.\n",
    "description": "",
    "tags": null,
    "title": "Functions",
    "uri": "/x-cis115-labs/3-functions/05-python-functions/"
  },
  {
    "content": " Resources Slides The print(expression) statement is very powerful in Python, but we really can’t do much with our programs using just a single statement. So, let’s look at how we can use variables in Python as well.\nRecall that a variable is a value that can change. In programming, it is easiest to think of a variable as a place in memory where we can store a value, and then we can recall it later by using that variable in an expression. In a later lab, we’ll learn how to use operators to manipulate the values stored in variables, but for right now we’re just going to focus on storing and retrieving data using variables.\nCreating Variables The process for creating a variable in Python is very similar to what we observed in pseudocode. Once again, we’re going to use an assignment statement to create a variable by storing a value in that variable. An assignment statement in Python looks like a = expression, where a is the name of a variable, and expression is an expression that evaluates to a value that we can store in that variable. For example, let’s consider the Python statement:\nx = \"Hello World\" In that statement, we are storing the string value \"Hello World\" in the variable named x. It’s just like we expect it to work based on what we’ve already learned in pseudocode.\nLet’s review some of the important rules about variables that we’ve learned so far:\nAssignment statements are always written with the variable on the left, and an expression on the right. This is a bit more confusing in Python, since we are used to the equals = symbol being commutative in math, meaning that we can swap the left and right side and it will still be a true statement. However, in Python, the equals = symbol is only used for assignment statements, and it must always have the variable on the left and an expression on the right. The left side of an assignment statement must be a location where a value can be stored. Once again, we’re just going to work with single variables, so we don’t have to worry about this yet. In a later lab, we’ll introduce lists as another way to store data, and we’ll revisit this rule. The right side of an assignment statement must be an expression that evaluates to a value that can be stored in the location given on the left side. Similar to the rule above, right now we’re only working with string values, so we don’t have to worry about this rule yet. We’ll come back to it in a future lab. Using Variables Once we’ve created a variable, we can use it in any expression to recall the current value stored in the variable. So, we can extend our previous example to store a value in a variable, and then use the print(expression) statement to display it’s value. Here’s what that would look like in Python:\nx = \"Hello World\" print(x) Just like in pseudocode, notice that we don’t put quotation marks \" around the variable x in the print(expression) statement. This is because we want to display the value stored in the variable x, not the string value \"x\". So, when we run this code, we should get this output:\nHello World To confirm, feel free to try it yourself! Copy the code above into a Python file, then use the python3 command in the terminal to run the file and see what it does. Running these examples is a great way to learn how a computer actually executes code, and it helps to confirm that your “mental model” of a computer matches how a real computer operates.\nUpdating Variable Values Python also allows us to change the value stored in a variable using another assignment statement. For example, we can write some Python code that uses the same variable to print multiple outputs:\na = \"Output 1\" print(a) a = \"Output 2\" print(a) When we run this code, we’ll see the following output:\nOutput 1 Ouptut 2 So, just like we observed in pseudocode, when we evaluate a variable in code, it will result in the value currently stored in that variable at the time it is evaluated. So, even though we are printing the same variable twice, each time it is storing a different value. Recall that this is why we call items like a a variable - their value can change!\nVariable Names Finally, Python uses many of the same rules for variable names that we introduced in pseudocode. Let’s quickly review those rules, as well as some conventions that most Python developers follow when naming variables.\nFirst, the rules that must be followed:\nVariable names must begin with either a letter or an underscore _. Variable names may only contain letters, numbers, and underscores -. Variable names are case sensitive. Next, here are the conventions that Python developers follow for variable names, which we will also follow in this course:\nVariable names beginning with an underscore _ have a special meaning. So, we won’t create any variables beginning with an underscore right now, but later we’ll learn about what they mean and start using them. Variables should have a descriptive name, like total or average, that makes it clear what the variable is used for. Variables should be named using Snake Case. This means that spaces are represented by underscores _, as in number_of_inputs Try to use traditional variable names only for their specific uses. Some examples of traditional variable names: tmp or temp are temporary variables. i, j, and k are iterator variables (we’ll learn about those later). x, y, and z are coordinates in a coordinate plane. r, g, b, a are colors in an RGB color system. Variables should not have the same name as keywords or any built-in statements or expressions in the language. For example, Python has a print statement, so we should not name a variable print in our language. In general, longer variable names are more useful than short ones, even if they are more difficult to type. Finally, don’t forget that some of the code examples in this course will not follow these conventions, mainly because long, descriptive variable names might give away the purpose of the code itself. We’ll still follow the rules that are required, but in many cases we’ll use simple variable names so that the focus is learning to read the structure of the code, not inferring what it does based solely on the names of the variables.\n",
    "description": "",
    "tags": null,
    "title": "Variables",
    "uri": "/x-cis115-labs/2-print-variables/11-python-variables/"
  },
  {
    "content": " Resources Slides As our programs become more complex, it can become more and more difficult to run them on our “mental model” of a computer without a little bit of help. So, let’s go through an example of code tracing, one of the best ways to work through large blocks of code and keep track of everything that is going on. At the same time, we can also learn more about using variables in our programs!\nMultiple Variables Our programs can also have multiple variables. In fact, there is no limit to the number of variables we can use - it just requires us to come up with a unique name for each one. For example, we could make a program that includes and displays multiple variables like this:\na \u003c- \"one\" b \u003c- \"two\" c \u003c- \"three\" d \u003c- \"four\" DISPLAY(a) DISPLAY(\" \") DISPLAY(b) DISPLAY(\" \") DISPLAY(c) DISPLAY(\" \") DISPLAY(d) This is a pretty complex program - one of the most difficult we’ve seen so far! To work out what it does, we can use a technique called code tracing. Let’s see how it works!\nCode Tracing Code tracing involves mentally walking through the code line by line and recording what each line does. So, we’ll need to keep track of the current values of each variable, as well as the current output that is displayed to the user. We can easily do this by making a couple of boxes on a sheet of paper or in a couple of tabs of a text editor. For this example, we’ll use a simple graphic like this one:\nAs we run the program, we’ll keep track of which line of code we are on, and update the trace as we go. So, let’s start by running the first line of code, a \u003c- \"one\". When we run this line, we’ll need to create a new variable named a and store the value \"one\" in it. In our code trace, we can simply add an entry to the variables section as shown below:\nThere is no right or wrong way to record variables in our code trace. We can use boxes for each value and update it as we go, or just write a short text entry as shown in our example. Any method is valid. In the meantime, we’re using an arrow to keep track of which line we are running in our program, but we can just as easily do so with a finger or other tool in the real world!\nLooking at the next three lines of code, we see that they are all similar. So, we can quickly run them and populate the next four entries in our variables box:\nNow we’ve reached the first DISPLAY(expression) statement in our program. If we recall the way those statements work, we should first evaluate the expression into a value. In our code, our expression is the variable a, which isn’t a value. So, we need to evaluate it by looking up the current value of a and placing it in the current line of code. Then, we can display that value in the output. So, once we’ve run that line of code, our code trace will look something like this:\nThe next line of code is just DISPLAY(\" \"), which is simple since the expression \" \" is just a string value that doesn’t need to be evaluated. So, we’ll need to add a space to the end of our output. This can be tricky, since we really can’t “see” spaces. For now, we’ll just place a dash - in that space until we get the next piece of output.\nNow we are back to a line that contains a variable. So, once again we look at the current value of the variable, place it in the expression, and then update our output. Since we’ve now received more output, we can remove that dash to make it a bit clearer.\nFrom here on out, it should be pretty simple to figure out how the rest of this trace goes. When we are finished, we should have a code trace that looks like this:\nThe whole process is shown below in animated form:\nCode tracing is a great way to train our “mental model” to work just like a real computer. While this may seem like a slow and tedious process right now, remember all of the other things we’ve learned how to do. Reading is initially very difficult, but with time and practice we can go from recognizing individual letters, to sounding out words, and finally reading with ease! The same happens as we learn to program and read code - with practice we’ll be able to do this in our head quickly and easily!\n",
    "description": "",
    "tags": null,
    "title": "Code Tracing",
    "uri": "/x-cis115-labs/2-print-variables/05-code-tracing/"
  },
  {
    "content": " Resources Slides The Science of Learning Programming from Nathan Bean’s CIS 400 Textbook The Power of Believing You Can Improve | Carol Dweck - TED Talk on Mindsets and the Power of “Yet” The New Science of Learning: How to Learn in Haromony with your Brain by Terry Doyle and Todd Zakrajsek - Great Book on Learning Constructivism on Wikipedia - Article about Jean Piaget’s Learning Philosophy Toward a Developmental Epistemology of Computer Programming by Raymond Lister - Introduces the Stages of Learning to Program Video Script Before we launch into the course itself, I wanted to take a few minutes to share some information with you regarding what we know about how students learn to program. This isn’t just anecdotal evidence from computer science teachers like me, but theories and research from education researchers who study how humans learn new skills and abilities throughout their lives.If I had to summarize all of this information in as few words as possible, I’d simply say “do the work.” Learning to program is difficult, and the only way to really get good at it is through constant practice and learning. However, that greatly oversimplifies the information that I want to share, and I’m hoping that you’ll find some helpful takeaways from this video that you can incorporate into your learning process.\nBefore I begin, I want go give all the credit to Nathan Bean for developing this information as part of his CIS 400 course. He graciously allowed me to use his hard work here, and I encourage you to check out his original version, which is available at the URL shown on this slide.\nThe statement “do the work” is a shorter version of a very common quote from educators, which is “the person doing the work is the person doing the learning.” I couldn’t find a solid reference for who said it first, so I’ll just attributed it to various educators throughout time. This really highlights one of the biggest struggles many students run into when learning to program. There are so many guides online, and the answer to many simple problems can be found through a quick Google search. You can just copy and paste the code, and then your program works. However, did you really learn how to write that program and what it does, or just how to find a quick answer? While this may be a useful tactic from time to time, if you rely too much on other people to do your coding, you really won’t learn it yourself. This is just like learning to shoot free throws on a basketball court or beating your best time in a speedrun - you can’t just watch someone do it and expect to do it yourself (believe me, I’ve tried). So, if you aren’t doing the work, you aren’t really learning.\nNext, let’s address a major myth in computer science. I’ve heard this many times: “some people are just natural born programmers, and others simply cannot learn to program.” And yes, on the surface, it may appear to be this way. Some students just seem to have a knack for programming, and you may sit and struggle and not really get anywhere. However, there is no innate skill or ability that makes you good at programming.\nInstead, let’s reframe what it means to learn programming. At its core, programming is learning to write steps to solve problems in a way that a computer can perform those steps. That’s really what we are doing when we learn programming.\nSo, we must focus on learning how to write those steps with the proper exactitude and precision so that they make sense, and we must understand how a computer functions to be able to program that computer effectively. So, when you see someone who is good at programming, it’s not because they are good at some esoteric skill that you’ll never have - they just know how to express their steps properly and know enough about how a computer works to make their program do what they want. That’s really it! And, to be honest, after a single semester of learning to program, you’ll have all the skills you need to do both of those things! If you know how to make conditionals, loops, functions, and use simple variables and arrays, that’s really all you need. Everything else that comes after that is just refining those skills to make your programs more powerful and your coding more efficient.\nSo, how do we learn these skills? Well, there are a couple of important pieces we need to make sure are in the right place first. For starters, we need to have the correct mindset. Many times I’ll see students struggle to learn how to program, and they’ll say things like what you see on this slide. “Its too hard.” “I don’t understand this.” “I give up.” Statements like this are the sign of a “fixed mindset,” and they can be one of the greatest blockers preventing you from really learning to program. Just like learning any other skill, you have to be open to instruction and willing to learn, or else you’ve failed before you even started.\nInstead, we want to focus on building a growth mindset. In the TED talk by Carol Dweck that is linked below this video, which I encourage you to watch, she talks about the power of “yet.” We can turn these statements around by simply adding positive power of “yet” - “I don’t understand this yet.” “I love a good challenge.” “I’ll keep trying until I get it.” Going into a programming project with a mindset that is open to growth and change is really an important first steps. When I feel like I’m getting a fixed mindset, I like to think about how difficult it would be to teach a child to tie their shoes if they don’t want to learn. As soon as I realize that, it is pretty easy to recognize that same problem in myself and work to correct it.\nSo, once we have our growth mindset, how do we actually learn to program? To understand that, let’s dive a bit into the world of educational theory and the work of Jean Piaget. Piaget was a biologist and psychologist who studied how young children acquired new knowledge, and he helped pioneer the concept of Constructivism, one of the most influential philosophies in education. You can read more about Constructivism in the links below this video.\nOne particular thing that Piaget worked on was a theory of genetic epistemology. Epistemology is the term for the study of human knowledge, so genetic epistemology is the study of the origins, or genesis, of that knowledge. Put more clearly, it’s the study of how humans create new knowledge. This concept was inspired by research done on snails - he was able to prove that two previously distinct species of snails were actually the same by moving snails from one habitat to another and observing how they modified their behaviors and how their shells grew to match the snails in the new habitat. Put clearly, the snails displayed an altered behavior based on their environment. They tried to exist in equilibrium with their environment by adapting their behaviors to fit what they now experienced in the word.\nPiaget suspected that something similar happens when humans try to learn something - the brain tries to adapt itself to maintain an equilibrium in its environment, which in this case is the existing knowledge it contains. So, when the brain is exposed to new ideas, it must somehow adjust to account for that new information. Piaget proposed two different mechanisms for how this occurs: assimilation and accommodation. In assimilation, new knowledge can be added to existing structures in the brain. For example, if you are exposed to a new color, such as periwinkle, you can see that it falls somewhere between blue and violet, two colors you already know. So, you can assimilate that new knowledge into the existing knowledge without a major disruption to your mental structure of existing colors. Accommodation, on the other hand, happens when your brain must radically adapt to new information for which no existing structures exist. This can be very difficult, and can lead to a lot of struggle and frustration when trying to get “over the hump” on a new subject. Think about learning algebra or a new language for the first time - you really don’t have anything you can use to help understand this new material, so you just have to keep at it until those new structures are formed in your brain.\nUnfortunately, to achieve accommodation, your brain simply has to build brand new structures to store and represent all of this new information, and that process is difficult and takes time. Put another way, it takes significant stimulus, usually in the form of doing homework, struggling with difficult problems and wrestling with the new information to try and understand it all, to create enough disequilibrium in your brain that, coupled with a growth mindset, will allow accommodation to occur. However, when all the pieces are in the right place, and you work hard and have a growth mindset, then…\nEUREKA! The structures will form, and you’ll get over that huge hurdle, and things will start falling into place. It may not happen all at once, but it does happen (you’ve probably had it happen to you several times already - think about some eureka moments from your past - were they related to learning a new skill?). Of course, there’s a good chance that your brain might form a few incorrect structures in the process, so you’ll have to overcome those as you continue to learn. I still struggle to spell some words because my brain formed incorrect structures when I was still learning. But, if you continue to work hard and be open to learning, you’ll eventually sort those errors out as well.\nLet’s look at one other concept in education, which is called stage theory. Piaget identified four stages that children go through as they learn to reason about the world. Those four stages are shown on this slide. In the sensorimotor stage, the child is just using their senses to interact with the world, without any real understanding of what will happen when they perform an action. This is best represented by babies and toddlers, who touch and taste everything in their surroundings. Next, the preoperational stage is represented in young children as they start to think symbolically about the world, using pictures and words to represent actions and objects. They then progress to the concrete operational stage, where they can begin to think logically and understand how concrete events happen. They can also start to think inductively, building the general principles of the world from their specific experiences. For example, if they observe that cooked spaghetti is better than raw spaghetti, they might reason that other foods like potatoes are better cooked than raw. Finally, the last stage is the formal operational stage. This stage is represented by the ability to work fully with an abstract work, formulating and testing hypotheses to truly understand how the world works and predict how new items will work before experiencing them firsthand.\nMany later researchers built upon this model to show that adults learn in much the same way. They also discovered that the stages are not rigid, and you may exhibit behaviors from multiple stages at any given time. This is called the “overlapping waves” model, and is shown here in this diagram. So, as you learn new skills, you may be at the operational stage in some areas, but still at the preoperational stage in other areas. This explains why some concepts may make sense while others don’t for a while - you just have to keep going until it all fits together.\nSo, how can we apply all of this information to programming? One theory comes from the work of Lister and Teague, who proposed a developmental epistemology of computer programming. Put another way, they applied this theory to computer science education, and gave us a unique way to think about the different stages of learning to program.\nAt the sensorimotor stage, we’re just getting the basics. So, when given a piece of code and asked to trace what it does, we still make lots of errors and get the answer incorrect. If we want to get a program to work ourselves, it usually involves a lot of trial and error, and many times when it does end up working we don’t even know exactly why it worked that time, but we’re building up a baseline of information that we can use to construct our mental model of how a computer works.\nAs we progress into the preoperational stage, we become better at tracing code correctly, but we still struggle to understand what the program itself does. We see each line of code as a separate instruction, but not the entire program. A great analogy is reading a recipe that calls for flour, water, salt, and yeast. Will it make bread? Biscuits? Pie crust? We’re not sure yet, but at least we can recognize the ingredients. To solve problems at this stage, we typically will randomly adjust pieces of our code that we don’t quite understand and see what it does, trying to form a better idea of the importance of each line in the code.\nEventually, we’ll get to the concrete operational stage. At this stage, we can construct our own programs, but many times we are simply piecing together parts that we’ve used before and performing some futile patches and bugfixes as we refine the program. We can also work backwards to figure out what a program does from execution results, but we still aren’t very good at deducing the results from the code itself. However, we’re starting to work with abstraction, though we tend to simplify things to a level that we are more comfortable with.\nFinally, we’ll reach the formal operational stage. At this stage, we can comfortable read and understand code without executing it, quickly seeing what it does and how it works without fully tracing it ourselves. We can also start to form hypotheses for how to build new programs and code, and reason about whether different approaches would work better or worse than others. This is the goal stage for any programmer! Once you have reached this stage, then you’ll feel totally at home working in code and developing your own programs from scratch.\nSo, how can we enable ourselves to be the best learners we can be? There is lots of interesting research in that area, best summarized in the book “The New Science of Learning” that is linked below this video. Let’s go through a few of the big concepts.\nFirst, getting ample and regular sleep is important, because it allows your brain to build those knowledge structures we discussed earlier and store the memories from the day in long-term storage. Without enough sleep, your brain is unable to process memories offline and make them ready for retrieval later on, an important step in learning. Also, consuming large amounts of caffeine or alcohol can disrupt your sleep patterns, so keep that in mind before you pour that next cup of coffee or go out partying. You can also take advantage of modern technology to help you track your sleep - most smart watches and smartphones today can help with that!\nLikewise, regular exercise is important to both your physical and mental health. When you exercise, especially aerobic exercise that gets your heart rate up, your body releases neurochemicals that help your brain cells communicate. In addition, just getting up and moving around regularly helps keep your body healthy, so take regular breaks, and consider getting a standing desk for some extra benefits.\nResearch also shows that engaging your senses is an important part in learning. This is why we, as teachers, try to vary our lessons with pictures, videos, activities, and more. It is also the basis of the cognitive apprenticeship style of learning that we use, which you can learn more about in the links below this video. We show you the code we are writing, engaging your sense of vision, while talking about it so you are also listening, and then you are writing your own version, using your sense of touch. You can build upon this by using your senses while you learn by taking notes during a lecture video, building concept maps, and even printing out and writing on your code and these lecture scripts. All of these processes help engage different parts of your brain and make it that much easier to build new knowledge structures.\nLooking for patterns is another important way to understand programming. There are many common patterns in computer programs, such as using a for loop to iterate through an array, or an if-else statement to determine if a particular variable is set to a valid value. By recognizing and understanding those patterns, we can more quickly understand new programs that use slightly different versions of the same code. Humans are naturally very good at pattern recognition, and it is one of the reasons why we see the same code structures time and time again - not because they are the only way to accomplish that goal, but because that structure is commonly used across many programs and therefore is easier to understand.\nThere is quite a bit of research into how memories are formed and how we can adjust our studying habits to take advantage of that. For example, cognitive science shows that the parts of our brain responsible for memory creation are active up to one hour after a learning experience has ended, such as a lecture video or activity. So, instead of jumping to the next task, you may want to take a little while to reflect on what you just did and let it sink in before moving on. Likewise, to build strong memories, it is important to constantly recall the memory or use the skills you’ve learned to strengthen their structures in the brain. This is why teachers like to throw in a few questions from a previous exam or quiz every once in a while - it helps strengthen those structures by forcing you to recall information you’ve learned previously. On the other hand, many students try to “cram” a bunch of information right before an exam, only to forget it soon after because it wasn’t recalled more than once. As you progress further, we’ll continue to come back to concepts you’ve already learned and build upon them, a process called elaboration that helps reinforce what you’ve already learned while building new, related knowledge.\nFinally, it is important to remember that we must give our brains the space it needs to focus on the task at hand. Multitasking while learning, such as watching YouTube or Twitch, chatting with friends, or listening to a lecture video while coding can all reduce your brain’s ability to form strong memories and do well. In fact, research shows that individuals who try to multitask tend to make 50% more errors and spend 50% more time on both tasks. So, instead of giving yourself distractions, try to find things that will help you focus better - there are some great playlists online for music without lyrics that can help you focus or code better, and you can easily mute notifications on your phone and on your computer for an hour or so while you work.\nSo, let’s summarize what we’ve covered here. First, and most importantly, remember that you can learn to program, just like the many students who have done it before you. However, it can be difficult and frustrating at times, and it will take lots of hard work on your part to make it happen. That means that you’ll need to read and write a lot of code before it really starts to make sense. In short, you must do the work to learn to program.\nThat said, you can help make the process easier by getting good sleep, exercising regularly, and engaging fully with all of the content in the course. That means you’ll need to take your own notes, maybe draw some diagrams, and annotate code you write and code you read to help you understand it. While you are working, try not to multitask so you can focus. If you are given some code to include in your program, don’t copy/paste it - rewrite it, and make sure you completely understand what each line does. Finally, take some time to read code written by others! GitHub is a great place to discover all sorts of code and see how others write code. If you want to write good poetry you have to read lots of good poetry, and the same goes for coding.\nWith that in mind, I hope you are able to make the best of this course and continue to develop your programming skills. If you are interested in this topic and would like to know more about things you can do to be a better learner, let us know! As you can imagine, teachers like me love to talk about this stuff, so don’t be afraid to ask. Good luck!\n",
    "description": "",
    "tags": null,
    "title": "How to Learn Programming",
    "uri": "/00-introduction/05-how-to-learn-programming/"
  },
  {
    "content": " DeepMind\n",
    "description": "",
    "tags": null,
    "title": "DeepMind",
    "uri": "/iii-topics/18-ai/10-deepmind/"
  },
  {
    "content": "Chapter X CIS 115 Labs This section contains the content for CIS 115’s Prelabs.\n",
    "description": "",
    "tags": null,
    "title": "CIS 115 Labs",
    "uri": "/x-cis115-labs/"
  },
  {
    "content": " VPN Off Campus To access CIS Linux while off campus, you must use K-State’s VPN. You do not need to use the VPN when connected to KSU Wireless or KSU Housing wifi. Here is a reference for the K-State VPN including how to install and how to use it: https://www.k-state.edu/it/cybersecurity/vpn/\nResources Slides Video Script Welcome back everyone. In this video, I’m going to talk a little bit about how we can get connected to the CS Linux server. So when we’re working with our webpages, we can actually open up our web page just fine in our local web browser if you’re working on your computer. For this class, we’re going to be hosting our web pages on CS Linux, so we can actually access them throughout the web. Because if we’re just working on our local machines, we’re not going to be able to access that website from anywhere else in the world. In order to achieve this, we’re going to need a tool that allows us to use SSH. The easiest way for Windows is to download something like PuTTY so PuTTY.org, or MobaXterm. If you decide to download or use PuTTY, you’ll be taken to a website once you actually click the download link on their main page to something that looks like this. Now, the file that you’ll actually need, you can kind of ignore all the alternative binary files down here, all you need is the MSI Windows Installer and pick if you’re using a 32 bit machine or 64 bit machine. Most people are going to be using the 64 bit machine. So that’s how you can download PuTTY. If you do a quick Google search for MobaXterm, you’ll actually find the download for that as well. Both of these are 100% free; although, MobaXterm does have a pro version, which essentially allows you to save more connections than the standard version. But for most people, the standard free version will be just fine. If you’re actually a CS major, I encourage you to download and install MobaXterm over PuTTY, because it can actually be a lot more useful and flexible for you in the future for other classes. But PuTTY will work just fine for those as well.\nWhen you actually download and install PuTTY, it’s a pretty basic application. To connect to the Linux server, all you need is the hostname the port and then your Computer Science username and password. You should have already requested and received your CS account by now, but if you haven’t, you can go to selfserve.cs ksu.edu, or you can find that link from our CS homepage and request one. If you happen to forgot your password, or if you try to incorrectly log into your account three times in a row, you will get locked out and your password will be required to be reset. You can do that at password.cs ksu.edu. Once we have all that in place, what you’ll want to do is enter the hostname so linux.cs.ksu.edu into the hostname location and Port 22 for the port, and then click Open. Now, you can also save this connection. So if you type in a name for this, I use CS Linux as my name. So if you type in CS, Linux underneath the saved sessions section there and click Save. You can load this for future sessions that you may actually use this for. For example, like your homework or any other time you might want to connect to CS Linux.\nWhen you click open for the first time, you might see a security alert that looks something like this. Really what this is doing is it’s confirming that you know the server that you’re actually connecting to. And in our case, we know who we’re connecting to so you can just click Yes to actually jump through this particular screen. But that should take you to a screen that looks something like this, where you have a terminal window open for you on CS Linux. Now most of you will either be connected to Cougar or Viper. There are two Linux servers here, both are going to work identical. And even if you’ve connected to Cougar in the past, but you’re now connected to Viper, all of your files should be there just the same. A little helpbit too when you’re trying to actually connect using PuTTY or even MobaXterm. If you are typing in your password and your username into the prompts as you are getting connected through SSH, you won’t see your password being typed. So as you type typically like any a login form, you’ll see like little dots pop up for each character you type. You will not see those here. So if you’re typing and you’re worried that your your typing isn’t actually working- it is. You’re just going to have to be very careful when you enter your password. And that’s also why I listed the password reset website up here, just in case you get locked out of your account.\nNow, for Mac users to connect to CS Linux, it’s pretty much the same process but you don’t actually have to install anything. So on Mac or Linux, please open up a terminal window. On Mac, you can find this underneath your applications and utilities. Once you have that terminal window open, all you’re going to need to do is type in this command here, SSH, and then space, then whatever your eID is. You don’t need an actual underscore there. So in my case, my username or my eID is weeser, than the at symbol linux.cs.ksu.edu, which is the domain name, or the address for the Linux server. eID@linux.cs ksu.edu. What that is telling the SSH command here is your username for this particular server that you’re connecting to. And again, the same thing applies here. When you’re typing into the terminal with your password, you’re not going to see your password being typed. So just make sure you’re very careful when entering the password. And again, if you enter your password incorrectly more than three times in a row, you will be required to reset your password at password.cs ksu.edu. Now that you’re logged in, we can actually start doing a little bit of work in Linux. My screen here looks a little bit different than what yours probably does, because I’m actually using PowerShell in this case. If you’re using PuTTY, or MobaXterm, your screen is probably black. Same thing with you are using Mac or Linux. If you’re using MobaXterm, though, you can actually modify the background color and text color and things like that if you’d like. Before we get rolling in with the HTML stuff, we need to actually be a little bit more confident on how we can actually navigate through Linux.\nNow we’ve used some of these commands in the class before, like cd, which is change directory. But to know where we’re actually currently at, we’re going to use the command pwd. pwd stands for present working directory, which allows us to see where we’re currently at. So I am now in home/w/wieser, which is my default user directory. Now we’ve used like I said cd we’ve used that before. So cd can be used to change directory. Now a couple handy commands here for that is cd ~. cd ~ will take you back to your home directory on CS Linux. Otherwise, you can do cd and then the name of the directory or path that you want to actually switch to. ls is going to show us the stuff in our current directory. If you also type ls -l that will show it in list form, which you’ll actually see on the left hand side here, the folder permissions or file permissions here, the user that this belongs to, the group that this belongs to, and then the last day modified here, and then the name of the file or folder. The folder that we’re actually going to be working with primarily today is the public HTML folder. But we’ll talk about that here in a little bit.\nOther handy commands that we might want to utilize here is going to be the move command. So mv. So it’ll be mv, and then space, the thing that you’re moving, space, the destination where you’re moving it to. You may not have to actually use this command for this class. But it is useful to actually be aware of. cp is copy command works very similar to the move command, but copies the file instead of moving it around. cp works in a very similar way as move where you takes the source and the destination. But this just simply copies the file. rm removes the file. Now, I will put a disclaimer here with rm. rm can be very detrimental to you if you don’t know what you’re doing. So be careful when you’re using rm in any Linux environment. Specifically, if you do rm star, which is basically going to remove everything in the current directory, rm -r is recursive, so it’ll actually go in to subdirectories as well. So just be careful with rm because you can accidentally delete more than you bargained for. And there is no Recycle Bin in Linux. So once it’s gone, it’s gone. So be very careful with the remove command. Cat will just simply output the contents of a file to the terminal itself. And so that can be very useful just to kind of peek at what is in a particular file.\nEditing files on a terminal environment is pretty straightforward. What I’m going to showcase here is nano, which is the most basic command line text editor that we have in Linux. Let’s go ahead and do this in our terminal window here. If you want to just clear your screen, by the way, if you just have a bunch of stuff on there, you can type clear and everything goes away. You can just scroll back up, and all of that reappears though, so it doesn’t really delete anything from your screen, it just moves the scroll bar. Likewise, if you press the up arrow or down arrow, you can actually scroll through the commands that you’ve had previously. So what I want to do here is cd into my public HTML directory. Now I did list a command down there, it says mkdir public HTML, you should not actually have to do that command. But if your public HTML folder happens to get deleted or is not there, that is the command you want us to actually make it. So once you’re in your public HTML directory, you can type in nano index.html. Once you have typed nano index.html, press enter, and you should get a screen that looks something like this. So this is our basic text editor here. And all the commands down here at the bottom are what you can use to actually write out anything, save it, cut, replace, that sort of thing. So some of the basic stuff that you would do with a normal text editor you can do here. So to save contents of our actual file, here, we’re going to use the write out command. Now the write out command can be done by holding the Ctrl key and the O key. So once you press Ctrl O, it will actually prompt you for a file name. And since we already typed out the file name, when we when we said nano, we don’t want to change it or we don’t need to change it here. And then all we need to do here is press enter, and it says wrote zero lines. Well because I haven’t really typed anything yet. But that’s okay. If we press Ctrl X as well here, we will actually cause our program to exit. And so that is the basics of nano here. So we have our new index.html file. We can actually load it up using nano so typing nano, and then the file name. Also, by the way, handy dandy little bit of information when you’re working with Linux, or any terminal by the way, or most terminals. If you start typing the thing that you’re looking for, and you press tab, it will generally autocomplete that for you. So makes things a lot easier to use.\nBut let’s take a look at a another option for us to actually be able to load our webpage on to the Linux server. It is actually really useful for you to be able to use nano and be comfortable with using a command line text editor because sometimes you’ll find yourself on a server that has no interface and it has no graphical capabilities of being able to open up interface that you can actually click through and make edits to a file. So things like nano or even vim which is a more advanced version of that is very useful to be comfortable with if you ever find yourself working on a server like Linux. But if you’re using PuTTY to connect to CS Linux, what I’ll want you to do is also download a program called FileZilla. FileZilla is a secure File Transfer Protocol software that we can use to actually transfer files from our local computer to CS Linux, or vice versa. And so the free version here is just fine for what our purposes are going to be doing here. So save that out. So I will say that when you install FileZilla, it’s going to prompt you to install additional software. That’s why it’s a free software. So make sure you don’t blindly click through the installation because you’ll install some extra stuff on your computer otherwise. If you’re a Windows user, or using MobaXterm, you don’t need to download FileZilla because you can actually use MobaXterm to copy your files over directly. Over here you can kind of see the directory that I did ls on, although you can actually kind of see all the hidden folders now. But here is my public-html folder that I had before that we just created. So once you have FileZilla downloaded, I just wanted to kind of show you the click through for the installation process here. So click I Agree through the agreement. Anyone on the computer that’s just fine, you can add a desktop icon if you would like to. Click Next, choose the install location. Next. And here is if you wanted to actually add the shortcuts here, click Next again. Now here, I think it cycles through different pieces of software, you’ll want to decline this. So don’t install McAfee here. Don’t install this stuff, you don’t need it. So just decline your way through those. But the installation is actually really quick and straightforward.\nAnd once you have it installed, it’ll look something like this. We’re going to connect to CS Linux very similar to what we did with PuTTY. All you’ll need to do is click new site here. And this is going to be for Mac, Linux, and Windows here. So FileZilla works on all of them. I’m going to call this CS Linux again. The host, I want linux.cs.ksu.edu. So the same host that we had before, same port number. But instead of doing FTP, here, we want SFTP. So Secure File Transfer Protocol. So it’s FTP. But the connection is used done using SSH, so it’s encrypted. I am going to go ahead and let it ask for my password here. But I am going to type in my username. You can also change the background color if you want. But then I’m just going to click ok there. So now that has been saved. So if I go up here and click the little triple dots, next to the little server button that I had clicked, and then click on CS Linux. If we type in our password, then now we are connected to CS Linux. And again here, if you try your password, and you don’t connect, and you fail three times in a row, you’re going to have to reset your password. So once you’ve connected, you will see your files here on the left from your personal computer and the files on the right from CS Linux, I’ve gone ahead and made a 115 folder for us to work out of for this particular video, I would encourage you to do the same and make things a little bit easier to work out of. And on the right hand side, I’m going to open up the public-html directory over here on the right hand side where my CS Linux files are. And I can just drag that over from the right to the left, and it will complete the transfer.\nNow I can do the same thing and transfer it back to the right. If I wanted to make edits to index.html, and then copy it back over to the server, I could do that. And then what you’ll want to do here is just overwrite and just kind of depends on what the files done, it’ll tell you a little bit of information about what the file is and what the transfer is. But I typically just say overwrite and then I usually just check the always use this action makes things easier, you don’t have to click through as much. Now that we’ve got our basic file, copy over in CS Linux, we can actually try to go and visit our website as well. Now, the website or the URL that you want to go to is people.cs ksu.edu/~ and then whatever your eID is. So for example, mine can be accessed at people.cs ksu.edu/~weeser. If you’ve been following along with exactly what I’ve been doing so far, you should come up to a completely blank webpage because we haven’t really done anything yet. In our index.html file, which is typically the default homepage file for HTML, doesn’t even have any HTML inside of it yet, but we’ll get there in just a moment. If you’re having any issues getting your web page to be displayed, please contact me or one of the TAs or post in the Microsoft Teams help channels and we can help you out as soon as we can. Other kind of issues that you might actually encounter here is any issues with your folder permissions. So if your public-html directory was not there and you had to make it, you might have some file permission issues there. You might have also accidentally named index.html incorrectly, or you might not have put it in the public-html folder. But if none of this actually fixes your issue here, like I said, please contact us. And if we’re not able to help you fix it, you can actually look at the support pages. If you go to support.cs ksu.edu, you can actually find some help pages that our internal IT department has made to help students get your initial web page started up. These should be all of the tools that we’ll need when we start typing in some HTML for our basic webpage.\n",
    "description": "",
    "tags": null,
    "title": "CIS Linux",
    "uri": "/ii-internet/13-webprog/10-cs-linux/"
  },
  {
    "content": " Resources Slides Video Script The technology that Vinton Cerf and Robert Kahn developed is the transmission control protocol or TCP. TCP allows small networks to talk to each other using a common standard or protocol that determines how they actually interact. The biggest benefit of TCP is there’s no single point of failure in the system. They’re not all talking to a central hub, each computer can talk point to point or host a host and pass the packets along as needed to the next system. And the other important thing about TCP is computers could also acknowledge successful transmission or if the transmission wasn’t received, but expected it could request to retransmit all of that missing data, making the system very robust against errors. And so because of that data transmission was very tolerant of any errors and any lost data.\nBy 1985 small networks had started to connect to each other and larger networks. Were starting to connect all using this TCP network. Work. And so most of the network computers were using TCP by 1985. And there’s a real big push to bring more computers onto the internet. Every few years there were these interconnectivity conferences where small network owners were encouraged to adopt TCP so they could connect to the internet as it was growing. But unfortunately, there really wasn’t much out there. At that time, there were computer systems available, but there wasn’t any way to just publicly access information on those systems.\nSo we really needed one more piece to make the internet into the useful information sharing tool that we know today. The last piece of the puzzle is the creation of the world wide web. The World Wide Web is the interconnected web of webpages that we use today that most of us think of as the internet. And the World Wide Web actually debuted on this very system and next cube from 1990 that makes up the very first web server. And this technology was all developed by one man, Tim Berners-Lee, Tim Berners-Lee was an engineer at CERN in Europe, and in the 1980s. He was really interested in creating a way that they can better present information on the internet. CERN had a lot of research that they wanted to share. And they needed a way to make it available to the general public.\nSo over the next few years, he worked on creating all of the underlying technologies needed to build his vision of the world wide web, including the web browser, the web server, the Hypertext Markup Language, and the hypertext transfer protocol, HTTP, all very core technologies to what we do on the internet today. And so with the development of the World Wide Web, you had personal computers that started to get computer browsers such as mosaic installed on it. This is one of the early web browsers showing what the World Wide Web looked like in the early 1990s. And so mosaic is built on this idea of the hypertext transfer protocol. It’s a protocol for sending and requesting data from the servers connected on the internet’s and so with the work of Tim Berners-Lee had the creation of the first web server, the first web browser and all together they may up the World Wide Web. So let’s take a quick look at a video interviewing Tim Berners-Lee as the World Wide Web turned 25 in the year 2015 and just get some thoughts of his experience developing the World Wide Web in the last 25 years.\n",
    "description": "",
    "tags": null,
    "title": "Part 4",
    "uri": "/ii-internet/11-internethistory/10-part4/"
  },
  {
    "content": " Resources Slides Video Script Unfortunately, with all the computers that we’ve talked about so far, they don’t really look like the computers that we have today, right? These machines took up entire, literally entire rooms and weighed tons and had millions upon millions of different individual parts. And so how did we get from a giant computer that takes up our room to a computer that fits on your wrist? And so the last piece of that puzzle comes to us from John Von Neumann, and some call him the last of the great mathematicians. And his accomplishments are truly outstanding, although you may hear some feedback against calling him the last of the great mathematician. But where does Von Neumann actually come into play with computer science history?\nWell Von Nueman is credited for the Von Neumann architecture. And now really the Von Neumann architecture really sets the stage for modern computing of the way our current computers right now are structured overall. So the Von Neumann architecture contains a few primary parts here, we have the control unit, which is responsible for following and sorting instructions, the arithmetic logic unit, which handles all the calculations, we also have a device that is used for storing memory. And we also have some possible way of inputting and outputting content, right. So we can input whether whatever it may be, that could be a keyboard, that could be a program that we give the computer and we also have some form of output, whether it be a screen, a video, whatever it actually may be. So we think a little bit farther back when we talked about what a computer should be able to do, right? A computer should be able to store stuff It should be able to calculate things, it should be able to be programmable, right, we should be able to accept variable input, and we should be able to output, right. And this pretty much accomplishes all of those things.\nAnd really, nothing has changed since the 1940s, when the Von Neumann architecture was designed and published. Now, I’m personally actually really interested to see how computing continues to evolve. And when we talk about hardware, you may see a few things about you know how some of this has changed a little bit. But the core idea of how our computing devices are now even modern day desktops, laptops and things like that are pretty much the same. There are some minor tweaks and reformulations of this idea, but nothing has drastically changed since then. So really, it’s going to be interesting to see what the future holds. With the structure of competing, right, are we going to, you know, what’s DNA computing going to do? Is that going to change the structure of our bond? Is that going to change or break the Von Neumann architecture? Are we going to gravitate to something completely entirely different? I’m not sure but it’ll be really exciting to see what happens in the next few years.\n",
    "description": "",
    "tags": null,
    "title": "Von Neumann Architecture",
    "uri": "/i-concepts/05-universal-computers/10-von-neumann/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 9.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/10-hci/10-pots-reading/"
  },
  {
    "content": " Error in Video In the video, the values of d and e are swapped at one point. Thankfully, this doesn’t matter since they are commutative and can be used in any order, but it is a bit confusing. We’ll correct this video in the future!\nResources Slides RSA Calculator Worksheet Video Script Let’s take a look at one modern form of encryption called RSA encryption. RSA was developed in 1977, and it was named for the three creators- Ron Rivest, Adi Shamir, and Leonard Adelman. RSA encryption uses the product of two large prime numbers to generate a key that’s used to encrypt data, and the strength of the key really depends on the difficulty of factoring that large number back into its two prime numbers. So for example, if we say our key number is 1071. Can we factor that into the two prime numbers? We could do it eventually, but we’d have to check a lot of different numbers to see what it was. So now imagine that 1071, instead of being a number with just four digits, was a number that had 64 digits in it. That’s really the size of the prime number products that we’re talking about when we do RSA encryption. And so really, the key to RSA encryption is the fact that it’s very, very difficult to factor a large number like that into the two unique prime numbers that are used to create it. So let’s take a look at how RSA encryption works to see why that’s important and why it can create a system that is easily broken if that rule doesn’t hold.\nSo for RSA, we start with two numbers, p and q. So I’m going to start out with p is five, and q is 17. So we’ve created two distinct prime numbers five and 17. Next, we will compute their products. So the product is n, which is qual to p times q, which is five times 17, which is 85. The other thing we’ll need to compute is Euler’s totient. And the totient of two prime numbers is actually just the number minus one. So to calculate Euler’s totient t, we would do p minus one times q minus one, which is going to be four times 16, which is 64. So we have p is five, q is 17, n is 85, and our totient t is 64. So let’s write that here. Again, we have p is five, q is 17, n is 85, and t is 64.\nNow, here’s the really complicated part. We need to choose the number e less than t that is coprime to t so that they share no common factors. Then, we calculate d as the modular multiplicative inverse of e. So that e times x is equal to one mod t. This is really complex mathematics, but what it really means is we need to pick a multiple that is one more than a multiple of t. So if t is 64, we’re looking at 65 129 193, etc. So we’re finding multiples of t, 64, an adding 1, 65. 64 times two is 28, so 129. 64 times three is 193. 64 times four is 256. So we’d look at 257, etcetera. And then we choose one of these that we can factor. So let’s look at 65. Can we factor 65 into two numbers? It turns out we can. So if we set d equal to five, and e equal to 13, we get 65. And e is less than t, and it’s coprime to t. Specifically, e is prime, which is great. Two number are coprime if they don’t share any common factors other than one. And since 13 is prime, it’s also coprime to any other number, which is what we want.\nSo now we found d and e, which are the keys that we actually need to send and receive our ata. So let’s look at our RSA keys. We have two keys, our public key, which is going to be n and remember and n is 85 and e is five. And then we can encode using this, and we have our private key, which is 85 and 13. So let’s take a look at an example to see how this would work. If we want to encrypt the message 42, what we would do is we would take 42 to the power of five, and then we would do mod 85. So remember, the modulo operation means we divide by 85 and we keep the remainder. So if we actually do this on a calculator, you’ll find that this is equal to 77. And if you have a calculator handy, you can try this yourself. So 77 is the message that we can send as an encoded message. On the receiving end, we would take our encoded message 77, raise it to the power of 13, mod 85. And sure enough, if you calculate 77 to the power of 13, and you might need Wolfram Alpha to do this, then mod 85, you will get back the original message 42. That’s how RSA encryption works. It’s really, really simple. It’s mathematics with a little bit of flavor on top of it to make the keys.\nNow, here’s the really tricky part. How do we break RSA encryption? Well, let’s take a look at our keys. Right here in both our public key and our private key, one part of that key is 85. What was 85? Remember that 85 is equal to our two prime numbers, p and q multiplied together. And since p and q are both prime, there is only one way that 85 could be factored. There are no other possible factors. And we know that we use five and 17. So if anybody can factor 85, into five and 17, then they can create t, because t is going to be four times 16, which is 64. And then using t if they have either e or d, they know that e times d would be one more than a multiple of t. And once they have that they could deduce the other half of the key. That’s what’s really important here. So RSA only works if this particular operation is very, very expensive. So to do RSA encryption, we choose numbers p and q, such that they are very, very large. And like I said, we’re talking hundreds of bits, we’re talking multiple digits long, and that’s why there’s so much computing power spent on the search for larger and larger prime numbers. Because for RSA encryption to work, we need those larger and larger prime numbers in order to construct RSA keys that we can use to send and receive data.\nThis is also really important later on when we talk about concepts such as computability. For example, we’re making an assumption here that the only way to factor a very, very large product of prime numbers is trying all possible prime numbers less than that number. So it’s simply brute force. Now, if we wake up tomorrow, and some mathematician has devised a better algorithm for factoring large products of prime numbers into their two primes, then all of the RSA encryption on the internet isn’t as secure anymore, because now there’s an algorithm that can do that quickly. Another fear would be that quantum computers could do this. And so if a quantum computer discovers a way to factor large products of prime numbers very quickly, it could have the same effect on RSA encryption. Now, of course, this is just one example of one encryption algorithm, but it gives you an idea of the fact that modern encryption is really built upon these ideas that there are very difficult calculations for somebody else to make if they don’t know the original numbers, but those calculations can be made very quickly for us if we know the original numbers that we used to build that key. So I hope this has been really informative. I really encourage you to try RSA encryption for yourself. It is very fun to do the math behind this. And just to see that it works exactly like you’d expect. You can go back and pick any two prime numbers for p and q, and go through this process. The hardest part is finding e and d. But there’s some really great helpers online that you can use, and I’ll link to one of those after this video so you can play around with RSA encryption yourself.\n",
    "description": "",
    "tags": null,
    "title": "RSA Encryption",
    "uri": "/iii-topics/16-cryptography/10-rsa/"
  },
  {
    "content": " Resources Slides Video Script So in review, we’ve talked about Alan Turing and the Turing test, along with John Cirillo in Chinese room with the problems and issues that the Turing test actually has. Then, we talked about Newell and Simon’s logic theorist, one of the first AI programs ever to be put out there. Then, we talked a lot about the Dartmouth research projects where organizing the conference to start to kind of build out the idea of AI, and the vast amount of different subtopics, and tools, and projects, and applications of AI, along with things like neural networks with Marvin Minsky, and a bit about the current state of AI. So a lot of things like Deep Blue, AlphaGo, AI in the medical field. So there’s a vast range of different possibilities and applications that we’re currently experiencing, including things like self driving cars. So what’s missing from this discussion, because we could talk for a very long time about AI, and just purely just the applications of AI.\nSo things like philosophical implications of AI, ethical implications. So this is a really big one right now with self driving cars. So if you’ve ever heard of the moral machine, this is a project out there, I would encourage you to go check this out. But it’s for a self driving car. If you’re presented with a situation where, regardless of the decision you make, you’re going to kill something. What do you kill? Do you swerve to miss grandma crossing the streets? But when you swerve, you’re going to hit the little girl playing hopscotch on the sidewalk? Or do you swerve the other way and hit the dog walker walking down the street with a pack of cute little puppies? Or do you just speed on through the intersection and hit grandma? There’s a lot of moral implications here. Because, you know, when it’s a human making that decision, generally speaking, the human is going to be at fault, but when an AI makes that kind of decision, which involves human life, or other forms of life, who’s at fault? Is it the programmer who told the AI to do that type of behavior? Do we put the car in jail? Right? There’s a lot of ethical implications there around AI and the choice of life or death.\nSolvability, right, are there things that a human can do, but the AI can’t, or vice versa? Singularity AAA the idea that we will reach a point where technology is growing faster than what we can actually do. So it basically grows out of control. And this is kind of like the robot overlords situation. If you’ve ever watched the movie iRobots with Will Smith. That’s a really kind of good example of singularity and human like intelligence and robotics. Like robots that have or AI has emotion and things like that. It kind of relates to consciousness as well, right? So we relate to humans being conscious. How to make an AI that has a conscience, or that human like emotion and human level decision? But again, these are some really deep topics that we could talk a lot about. But these are just some points to kind of remember, as you’re kind of going about learning about AI watching the videos that we have for this particular module and moving forward into a world where AI is as ubiquitous and ingrained into our daily routines, and it’s going to continue that way even more so as as we go farther into the future.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/iii-topics/18-ai/11-summary/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "World Wide Web Turns 25: Interview with inventor Sir Tim Berners-Lee",
    "uri": "/ii-internet/11-internethistory/11-www-25th/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Multi-touch Interfaces - Jeff Han on TED Talks",
    "uri": "/i-concepts/10-hci/11-multi-touch-interfaces/"
  },
  {
    "content": " Resources Slides Finally, let’s work through another full example program in Python that uses lists and strings, just to gain some more experience with the various ways we can use the techniques we’ve learned in this lab.\nFor this example, consider the following problem statement:\nWrite a program to construct and print Pascal’s Triangle for a given number of rows. The user should be prompted to enter a positive integer indicating the number of rows, and if the user provides an invalid input the program should prompt for additional input until valid input is received.\nPascal’s Triangle is a simple mathematical construct that begins with the value $1$, and then each value below on the triangle is the sum of the two values immediately above it. The first few rows of Pascal’s Triangle are shown below:\n1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 We can easily do this with loops and lists. So, let’s go through the process of building that program from scratch.\nHandling Input To begin, we can start with our usual program structure consisting of a main() function and a call to the main() function at the bottom of the file:\ndef main(): main() Next, we’ll include the positive_input() function that we’ve used in several previous labs, which handles prompting the user for a positive integer input and will prompt the user for additional input if an invalid value is provided. Once again, we’re doing our best to reuse pieces of code we’ve already written:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def main(): main() In our main() function, we can quickly call the positive_input() function to get the required piece of input from the user and store it in the variable n:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def main(): n = positive_input() main() That’s the basic structure of our program to handle input. It’s very simple and mostly reused code, so it should be quick and easy to get to this point of our development process.\nInitial Setup Next, we should add some of the initial steps to our program. For example, we know that the first row of Pascal’s Triangle is simply the number $1$, so we can create an initial list that contains just that single element, and then print that to the terminal:\ndef main(): n = positive_input() row = [1] print(row) Next, we know we need to create additional rows of Pascal’s Triangle, up to n rows in total. So, we can quickly build a for loop that will handle that in our main() function:\ndef main(): n = positive_input() row = [1] print(row) for i in range(1, n): # update row print(row) Notice that we are starting our range at $1$ instead of $0$. This is because we’ve already printed the first row, so we only want to print additional rows if the value of n is greater than $1$. That’s the basic structure we need in our main() function\nComputing the Next Row Finally, we need to deal with the process of updating our row list to include the next row’s information. While we could do that directly in the main() function, it makes the most sense to create a separate method for that. So, we’ll start by creating a new function update_row() that requires a single parameter:\ndef update_row(row): In this function, we need to use the previous row on Pascal’s Triangle to compute the next row. This is a bit tricky to figure out, but thankfully there are a few helpful rules that we can follow:\nEach successive row is $1$ element larger than the previous row The first item in the row is always $1$ The item at index i+1 of the new row is the sum of the items at index i and i+1 on the previous row. The last item in the row is always $1$ Using those rules, we can write a loop in code that will create a new list for the next row. First, since we’ll be using multiple items from the row list in our loop, we’ll need to start with the generic while loop structure to iterate through the list:\ndef update_row(row): i = 0 while i \u003c len(row): # use list elements i = i + 1 We can also initialize our new list to start with the value $1$ initially:\ndef update_row(row): i = 0 new_row = [1] while i \u003c len(row): # use list elements i = i + 1 Inside of the while loop, we can append new items to our new_row by simply summing the elements at index i and i + 1 of our previous list:\ndef update_row(row): i = 0 new_row = [1] while i \u003c len(row): new_row.append(row[i] + row[i + 1]) i = i + 1 At the end, we’ll need to add the final $1$ to the new row. Finally, since we’re creating a new list instead of modifying the existing one, we’ll need to return that reference back to the main function:\ndef update_row(row): i = 0 new_row = [1] while i \u003c len(row): new_row.append(row[i] + row[i + 1]) i = i + 1 new_row.append(1) return new_row note-1 It may seem like we can simply do row = new_row in the update_row() method instead of returning it, but that actually doesn’t work. This is because the row variable in the update_row() function’s frame is a reference to the previous list in memory. If we update that reference, it will point to the new list in the update_row() function’s frame, but not in the main() frame - that variable still points to the previous list. You can confirm this behavior by testing it in Python Tutor to see how it looks in memory.\nFinal Program The last step is to simply update the for loop in our main() function to call the update_row() function and store the returned list reference back into the row variable. So, our final program looks like this.\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def update_row(row): i = 0 new_row = [1] while i \u003c len(row): new_row.append(row[i] + row[i + 1]) i = i + 1 new_row.append(1) return new_row def main(): n = positive_input() row = [1] print(row) for i in range(1, n): row = update_row(row) print(row) main() Now that we’ve completed this program, let’s test it once and make sure that it produces the correct output.\nLogic Error When we run this program, we should see the following appear in our terminal:\nUh oh! We’ve run into an error! This error is telling us that somewhere we are trying to access an index inside of a list that doesn’t exist. Helpfully, it tells us that we are doing this in the update_row() function, right inside of the for loop:\ndef update_row(row): i = 0 new_row = [1] while i \u003c len(row): new_row.append(row[i] + row[i + 1]) i = i + 1 new_row.append(1) return new_row So, let’s see if we can figure out what is going on here. Let’s assume that it is failing when we are passing in the first row, which is simply the list [1]. On that line of code, we are appending a new item to the end of our new_list that is the sum of row[i] and row[i+1].\nAh ha! At this point, our row only contains a single item, so even if i is initially set to $0$, we cannot access an element that has index $1$ in that list. That’s where our logic error is coming from!\nSince we need to access elements that are at one index higher than i, we must adjust our while loop so that it stops at the element before the last one. We can easily do that by modifying our while loop’s Boolean expression to i \u003c len(row) - 1. If we make that change and try our program again, we should see the correct output:\nThe full, working example code is shown here:\ndef positive_input(): x = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) return x def update_row(row): i = 0 new_row = [1] while i \u003c len(row) - 1: new_row.append(row[i] + row[i + 1]) i = i + 1 new_row.append(1) return new_row def main(): n = positive_input() row = [1] print(row) for i in range(1, n): row = update_row(row) print(row) main() There we go! We’ve written a complete program that will generate Pascal’s Triangle for any given number of rows. It uses both while and for loops and lists to accomplish that goal. Try to work through this entire example and run the program many times along the way to make sure you have a good understanding of why it works before continuing in this lab.\ninfo-1 You might be wondering why we’ve chosen to keep the logic error in this example program instead of simply fixing it in our explanation. As it turns out, that logic error was actually made by the author while writing this example, and we felt that it was best to demonstrate how to quickly identify and resolve such an error instead of simply explaining it away. Hopefully seeing how easy it is to make simple logic errors like this will help you understand that it can happen to anyone, and it is not a big deal to have to fix small bugs along the way.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/x-cis115-labs/13-lists/06-worked-example/"
  },
  {
    "content": "In this lab, we introduced several major important topics in pseudocode. Let’s quickly review them.\nPseudocode While Loops While loops in pseudocode will execute while a Boolean expression evaluates to true.\nREPEAT WHILE(\u003cboolean expression\u003e) { \u003cblock of statements\u003e } Pseudocode For Loops For loops in pseudocode will execute a set number of times.\nREPEAT \u003cn\u003e TIMES { \u003cblock of statements\u003e } Input with Loops Loops can be used to request new input from the user if invalid input is received.\nPROCEDURE positive_input() { DISPLAY(\"Enter a positive number: \") x \u003c- NUMBER(INPUT()) REPEAT WHILE(x \u003c= 0) { DISPLAY(\"Invalid Input!\\n\") DISPLAY(\"Enter a positive number: \") x \u003c- NUMBER(INPUT()) } RETURN x } Testing Loops Loops can be tested for both branch and path coverage. In general, achieving path coverage involves writing code that will enter the loop, and also code that will bypass the loop entirely.\nLoops should also be tested for termination and situations that may result in infinite loops. Using a loop variant and showing that it is monotonically decreasing is a helpful technique.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/10-pseudocode-loops/06-summary/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nPython While Loops While loops in Python will execute while a Boolean expression evaluates to true.\nwhile \u003cboolean expression\u003e: \u003cblock of statements\u003e Range Function The range() function in Python is used to generate a list of numbers. It can be used in three ways:\nrange(stop) - numbers from $0$ up to (but not including) stop range(start, stop) - numbers from start up to (but not including) stop range(start, stop, step) - numbers from start up to (but not including) stop, with step between each number. Python For Loops For loops in Python will execute a set number of times.\nfor \u003citerator variable\u003e in \u003clist\u003e: \u003cblock of statements\u003e Input with Loops Loops can be used to request new input from the user if invalid input is received.\ndef input_percentage(): x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) return x Testing Loops Loops can be tested for both branch and path coverage. In general, achieving path coverage involves writing code that will enter the loop, and also code that will bypass the loop entirely.\nLoops should also be tested for termination and situations that may result in infinite loops. Using a loop variant and showing that it is monotonically decreasing is a helpful technique.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/11-python-loops/06-summary/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nMutually Exclusive Conditional statements are mutually exclusive when only one of the many branches will be executed for any possible input.\nChained Conditionals if condition_1: print(\"1\") else if condition_2: print(\"2\") else: if condition_3: print(\"3\") else: print(\"4\") is equivalent to:\nif condition_1: print(\"1\") elif condition_2: print(\"2\") elif condition_3: print(\"3\") else: print(\"4\") Nested Conditionals if condition_1: if condition_2: print(\"1 and 2\") elif condition_3: print(\"1 and 3\") else: print(\"1 and not 2 or 3\") elif condition_4: if condition_2: print(\"4 and 2\") elif condition_3: print(\"4 and 3\") else: print(\"4 and not 2 or 3\") else: print(\"neither 1 nor 4\") Variable Scope Variable scope refers to what parts of the code a particular variable is accessible in. Python uses function scope, which means that a variable defined anywhere in a function is available below that definition in any part of the same function.\nOther languages use block scope, where variables are only available within the block where they are defined.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/9-nested-conditionals/06-summary/"
  },
  {
    "content": "Lab 6 Booleans ",
    "description": "",
    "tags": null,
    "title": "Booleans",
    "uri": "/x-cis115-labs/6-booleans/"
  },
  {
    "content": " Resources Slides Python also uses various comparators to allow us to compare values of many different data types to produce a Boolean value. We can compare numbers, strings, and many other data types in Python using these comparators.\nSince we’ve already covered the comparators in pseudocode, let’s just briefly go over all of them and discuss any ways they differ in Python compared to pseudocode.\nThe basic comparators in Python are:\n== equal != not equal \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to Notice that the equal comparator in Python now uses two equals signs == instead of a single one. This is because the single equals sign = is used in the assignment statement, and we don’t want to confuse a Boolean comparator for an assignment. So, in Python, as in most other programming languages, we use two equals signs == when comparing values, and one equals sign = when we are storing a value in a variable.\nComparing values Just like in pseudocode, we usually only want to compare values of the same data type using comparators. It really only makes sense to compare strings to strings, and booleans to booleans. However, for the numeric data types int and float, we can easily compare values of either data type together in Python.\nConsider the following example:\nx = 5 y = 5.0 print(x == y) When we execute this code, we’ll get this output:\nTrue Even though x is the int data type and y is the float data type, they both store the same numerical value, and our comparators will work just like we expect. So, we can easily compare both integers and floating-point values in our code.\nnote-1 Behind the scenes, when we compare an int and a float value in Python, Python will convert the values to a common data type, usually the float data type, using the appropriate conversion function. This is known as coercion in programming - the program is essentially forcing a value of one data type into another data type because of an operation. However, it won’t change the data type of the variable involved, just the value it is evaluating.\nStrings in Python can also be compared using the various comparator operators. When two strings are compared using any type of “less than” or “greater than” comparator, they will be compared according to their lexicographic order. In general, this means that each letter will be ordered based on its value in the ASCII encoding standard.\nLet’s look at a quick example:\na = \"First\" b = \"fir\" print(a \u003c b) When we run this code, we’ll see this output:\nTrue This may seem surprising, since we’d expect the word \"fir\" to come before the word \"First\" in a dictionary, since it has fewer letters. However, in Python, the letters \"f\" and \"F\" are not treated identically. According to the ASCII encoding standard, capital letters have a lower value than lower-case letters, so all words starting with a capital \"F\" will come before any words starting with a lower-case \"f\".\nThis can be a bit confusing, so it is always important to remember that we can always write a quick sample program in Python to test how a particular operator will work for a given set of values. If nothing else, we can always count on our computer to produce the same result for the same operation, no matter if it is part of a larger program or a small test program.\nOrder of Operations Finally, Python’s order of operations follow the same rules that we saw in pseudocode. So, when we see an expression that combines mathematical operators with Boolean operators and comparators, we’ll follow this order:\nMath operators (according to their order of operations) Boolean comparators not operator and operator or operator As always, it is considered good practice to include parentheses in any complex expressions to make sure that the intent is clear, regardless of the order of operations.\n",
    "description": "",
    "tags": null,
    "title": "Python Comparators",
    "uri": "/x-cis115-labs/6-booleans/06-python-comparators/"
  },
  {
    "content": " Resources Slides Previously, we saw how important it was to consider many possible test inputs when testing a program that contains a conditional statement. Let’s go through one more example, this time in Python, to get some more practice with creating test inputs for conditional statements.\nExample Program For this example, let’s consider the following program in Python:\ndef main(): a = int(input(\"Enter a number: \")) b = int(input(\"Enter a number: \")) if a // b \u003e= 5: # Branch 1 print(\"{} goes into {} at least 5 times\".format(b, a)) else: # Branch 2 print(\"{} is less than 5 times {}\".format(a, b)) if a % b == 0: # Branch 3 print(\"{} evenly divides {}\".format(b, a)) else: # Branch 4 print(\"{} / {} has a remainder\".format(a, b)) main() This program is a bit trickier to evaluate. First, it accepts two numbers as input. Then, it will check to see if the first number is at least 5 times the second number. It will print an appropriate message in either case. Then, it will check to see if the first number is evenly divided by the second number, and once again it will print a message in either case.\nBranch Coverage To achieve branch coverage, we need to come up with a set of inputs that will cause each print statement to be executed. Thankfully, the branches are numbered using comments in the Python code, so it is easy to keep track of them.\nLet’s start with an easy input - we’ll set a to $25$ and b to $5$. This means that a // b is equal to $5$, so we’ll go into branch 1 in the first if statement. The second if statement will go into branch 3, since a % b is exactly $0$ because $5$ stored in b will evenly divide the $25$ stored in a without any remainder. So, we’ve covered branches 1 and 3 with this input.\nFor another input, we can choose $21$ for a and $5$ for b. In the first if statement, we’ll see that a // b is now $4$, so we’ll go into branch 2 instead. Likewise, in the second if statement we’ll execute branch 4, since a % b is equal to $1$ with these inputs. That means we’ve covered branches 2 and 4 with these inputs.\nTherefore, we can achieve branch coverage with just two inputs:\n$25$ and $5$ $21$ and $5$ Path Coverage Recall that there are four paths through a program that consists of two if statements in a row:\nBranch 1 -\u003e Branch 3 Branch 1 -\u003e Branch 4 Branch 2 -\u003e Branch 3 Branch 2 -\u003e Branch 4 We’ve already covered the first and last of these paths, so we must simply find inputs for the other two.\nOne input we can try is $31$ and $5$. In the first if statement, we’ll go to branch 1 since a // b will be $6$ this time. However, when we get to the second if statement, we’ll find that there is a remainder of $1$ after computing a % b, so we’ll go to branch 4 instead. This covers the second path.\nThe third path can be covered by inputs $20$ and $5$. In the first if statement, we’ll go to branch 2 because a // b is now $4$, but we’ll end up in branch 3 in the second if statement since a % b is exactly 0.\nTherefore, we can achieve path coverage with these four inputs:\n$25$ and $5$ $21$ and $5$ $31$ and $5$ $20$ and $5$ Edge Cases What about edge cases? For the first if statement, we see the statement a // b \u003e= 5, so that clues us into the fact that we’ll probably want to try values that result in the numbers $4$, $5$, and $6$ for this statement. Thankfully, if we look at the inputs we’ve already tried, we can see that this is already covered! By being a bit deliberate with the inputs we’ve been choosing, we can not only achieve branch and path coverage, but we can also choose values that test the edge cases for various Boolean expressions as well.\nLikewise, the Boolean statement in the second if statement is a % b == 0, so we’ll want to try situations where a % b is exactly $0$, and when it is some other value. Once again, we’ve already covered both of these instances in our sample inputs!\nSo, with a bit of thinking ahead, we can come up with a set of just 4 inputs that not only achieve full path and branch coverage, but also properly test the various edge cases that are present in the program!\n",
    "description": "",
    "tags": null,
    "title": "Python Testing",
    "uri": "/x-cis115-labs/7-conditionals/06-python-testing/"
  },
  {
    "content": " Resources Slides Python also includes an operator that can be used to concatenate two strings together. Just like in pseudocode, we can use the plus symbol + between two strings to concatenate them together into a single string, making it much simpler to build more complex strings and outputs.\nA simple example is shown below:\nfirst = \"Hello\" second = \"World\" print(first + second) When executed, this code will display this output:\nHello World As we can see, using the + operator in Python to concatenate two strings together is a quick and easy way to simplify our print statements.\nConcatenating Numbers Just like in pseudocode, Python also requires both sides of the + operator to be strings in order for concatenation to work. So, if we want to concatenate a string with a numeric value, we’ll have to convert it to a string using the special str() function. Here’s an example:\ntext = \"Your total is $\" value = 2.75 print(text + str(value)) When we run this program, we’ll receive the following output:\nYour total is $2.75 However, if we forget to convert the value variable to a string, as in this example:\ntext = \"Your total is $\" value = 2.75 print(text + value) we’ll receive an error instead:\nTraceback (most recent call last): File \"tutor.py\", line 3, in \u003cmodule\u003e print(text + value) TypeError: must be str, not float So, we’ll have to be careful and make sure that we convert all of our numbers to strings before trying to concatenate them together. Of course, if both sides of the + operator are numbers, then it will perform addition instead of concatenation!\nString Formatting Python also includes another method of building strings, and that is the format() method. The format() method allows us to put placeholders in strings that are later replaced with values from variables, effectively creating a way to build “templates” that can be used throughout our program.\nThe easiest way to see how this works is looking at a few examples. Let’s start with a simple one:\nname = input(\"Enter your name: \") print(\"Hello {}\".format(name)) If the user inputs \"Willie Wildcat\" when prompted, then this code will produce this output:\nEnter your name: Willie Wildcat Hello Willie Wildcat There are many important parts to this example, so let’s look at each one individually. First, in the print() statement, we see the string \"Hello {}\". This is an example of a template string, which includes a set of curly braces {} as placeholders for data to be inserted. Each template string can have unlimited sets of curly braces, and each one will be given a different piece of data from the format() method.\nThen, we see a period ., followed by the format() method. Notice that the format method is directly attached to the template string by a period - this is because it is actually a method that operates on the template string object itself. This is a key concept in object-oriented programming, which we won’t cover in detail right now, but we’ll definitely see it come up later as we learn more about programming. This is also why we are referring to format() as a method instead of a function, since it is directly attached to another object.\nWhen executed, the format method will replace the placeholders in the string with the values provided as arguments, working from left to right. The first argument will replace the first placeholder, and so on, until all placeholders are replaced and the arguments are all used.\nThe format() method itself can have unlimited arguments. Each argument corresponds with one of the placeholders in the template string. So, if there are two placeholders, there should also be two arguments.\nnote-1 The Python format() method can do many powerful things, such as place the same argument in multiple placeholders, and each placeholder can define how a value should be presented to the user, among many other features. For right now, we’ll just use simple, empty placeholders in our template strings. Likewise, we’ll just deal with the situation where each placeholder matches to exactly one argument to the format() method.\nThe most powerful use of the string format() method is to insert numerical values directly into strings without having to convert each value directly to the str data type - the format() method handles that conversion for us.\nFor example, we can update our previous program to use the string format() method to display the output in a single print() statement, and we can also add additional information with ease:\ntext_one = input(\"Enter the price of one item: \") price = float(text_one) text_two = input(\"Enter the quantity of items: \") quantity = int(text_two) cost = price * quantity print(\"{} items at ${} each is ${} total\".format(quantity, price, cost)) When we execute this program, we’ll see output that looks like this:\nEnter the price of one item: 2.75 Enter the quantity of items: 3 3 items at $2.75 each is $8.25 total This example shows how easy it is to build complex output strings using a simple template string and the string .format() method.\n",
    "description": "",
    "tags": null,
    "title": "Python Strings",
    "uri": "/x-cis115-labs/5-input-strings/06-python-strings/"
  },
  {
    "content": " Resources Slides Let’s review a couple other concepts related to functions in Python. These will closely mirror what we’ve already learned in pseudocode, so we’ll cover them pretty quickly here.\nMain Function Just like in pseudocode, we can also create a main function in Python. The use of a main function in Python is not required at all - Python is designed as a scripting language, meaning we can write code directly in a Python file without using any functions at all. However, it is generally considered good practice to make sure all code is part of a function, and then we can include a main function as the starting point for any program.\nSo, we can update the example we saw previously to include a main function by simply placing the three function calls in a new function called main, and then including a call to the main function at the bottom of the program:\ndef foo(): print(\"eye\") def bar(): print(\"to\") def main(): foo() bar() foo() main() From here on out in this course, we’ll follow this convention in our complete Python programs. Specifically:\nAll programs must contain a function named main as the starting point of the program. All code in a program must be contained within a function, with the exception of a single call to the main function at the bottom of the program. This will make our Python programs easy to follow, and it will help us later on down the road if we choose to learn another language such as Java or C# that requires a main function.\nFunction Parameters Functions in Python can also require parameters. To include a parameter in a function, we simply have to include the name of the parameter in the parentheses () at the end of the function definition. Multiple parameters should be separated by commas ,. For example, we can update our hello_world function to include a couple of parameters:\ndef hello_world(first_name, last_name): print(\"Hello \", end=\"\") print(first_name, end=\" \") print(last_name) Here, we are defining two parameters, named first_name and last_name, that are used as part of the function. Those parameters can be treated just like any other variable within the function.\nCalling a Function with Arguments Once we have a function that requires parameters, we can call it by including arguments in the parentheses () that are part of the function call. For example, we can call the hello_world procedure above and provide two arguments like this:\nhello_world(\"Willie\", \"Wildcat\") When we run this code, it will place the string value \"Willie\" in the parameter variable first_name, and the string value \"Wildcat\" will be placed in the parameter value last_name within the frame for the hello_world function. When the code in hello_world is executed, we should see the following output:\nHello Willie Wildcat Code Tracing a Procedure with Arguments To see how this works, let’s work through a full example. Here’s a more complex Python program that includes parameters, arguments, and some other variable expressions:\ndef flip(first, last): temp = first first = last last = temp print(first) print(last) def main(): first = \"Willie\" last = \"Wildcat\" flip(first, last) print(first) print(last) main() Once again, before reading the full analysis below, take a minute to read through this code and see if you can guess what it does. It can be a bit tricky if you don’t read it carefully and think about what we’ve learned so far.\nTo trace this example, copy the code into the tutor.py file in the python folder on Codio, or click this Python Tutor link.\nWhen we begin, our code trace will look like this example:\nAs we expect, the first thing that Python will do is scan through the code and record any functions it finds in the global frame. So, after pressing the Next \u003e button a couple of times, we should reach this point:\nNow we are at a function call for the main function. So, when we click the Next \u003e button:\nPython tutor will jump to that function’s code, and it will also create a new frame for variables that are created in the main function. The next two lines deal with creating a couple of variables, so we can click the Next \u003e button a couple of times to execute those lines and stop when we reach the next function call:\nNow we are ready to call the flip function. This function requires two parameters, named first and last. Notice that those parameter names are the same names as the variables that we created in the main function? This is a common practice in programming - sometimes it is simplest to use the same variable names in multiple functions, especially if they are storing the same data. However, it is important to understand that those variables are not related in any way except for the name, as we’ll see in this example. When we click the Next \u003e button to jump to the start of the flip function, we should see the following in our Python tutor trace:\nIt has now created a frame for the flip function, and copied the values of the two arguments into the appropriate parameter variables. Since we listed the arguments first and last in that order in the function call to flip, a copy of the values from those two variables in main will be stored in the same two variable names in flip. It’s an easy way to make sure the arguments are in the correct order!\nThe first three lines in the flip function will swap the values in the first and last parameter variables. So, after we’ve executed those three lines, we should now see this setup in our trace:\nNotice that the values in first and last inside of the flip frame have changed, but the values in the same variables in the main frame have not changed! This is why it is very useful to keep track of variables in frames within a code trace - we can easily tell which variables go with which function, even if they have the same names. So, the next two lines of code in the flip function will simply print out the contents of the first and last parameter variables:\nAt this point, we’ve reached the end of the flip function, so when we click the Next \u003e button again, we’ll jump back down to where we left off in the main function. At the same time, we’ll remove the flip frame from the list of frames, completely removing the first and last parameter variables used in that function:\nNow that we are back in the main function, we can see that the values stored in the first and last variable are unchanged, just like we’d expect. This is important to understand - just because one function uses the same variable names as another function, or that a function’s parameter names match the variable names provided as arguments, they are not related and any changes in the function won’t impact the values outside of the function. So, we can finish the main function by running the last two lines, which will print the current values of first and last to the screen:\nFinally, once the program reaches the end of the main function, it will jump back to the main function call at the bottom of the program. This will remove the main frame from the list of frames. Since there is nothing more to do, the program will end at this point:\nThe whole process can be seen in this animation:\nThere we go! We’ve explored how functions, parameters, and arguments all work in Python. Understanding this process now will make it much easier to write complex programs later on.\n",
    "description": "",
    "tags": null,
    "title": "Main Function, Parameters, \u0026 Arguments",
    "uri": "/x-cis115-labs/3-functions/06-main-parameters-arguments/"
  },
  {
    "content": " Resources Slides Let’s look at one more difficult concept in programming - using variables in the expressions for other variables. Right now we haven’t learned any operators (don’t worry - we’ll cover those in great detail in a future lab), but it is still important for us to understand what happens when we use the value in one variable to create or update the value in another variable.\nLet’s consider this program:\nx \u003c- \"Hello\" y \u003c- x DISPLAY(y) DISPLAY(\" \") x \u003c- \"World\" DISPLAY(x) DISPLAY(\", \") DISPLAY(y) To work out what this program displays, we can once again use code tracing to work through it line by line. The first line is pretty easy - we see that we are simply storing the string value \"Hello\" in a new variable named x, so we can easily update that on our code trace as shown below:\nThe next line is tricky - here we are storing the expression x into the variable named y. As before, we first have to evaluate the expression x to a value, which is simply the value stored in that variable. So, in actuality, we are storing the string value \"Hello\" in the variable y as well.\nThis is important to understand! In the code, and indeed in our “mental model” of a computer, we might start to think that the values stored in variable x and y are connected somehow. However, this is not the case. What the line y \u003c- x says is simply that y now stores a copy of the value that was stored in x when this line is run. Going forward, these two values are not connected in any way, as we’ll soon see.\nSo, after running the second line of code, our code trace should now look like this:\nThe next two lines are pretty simple, since they only display the value stored in y followed by a space. So, after running those two lines, we should see the following on our code trace:\nNow we reach the most important line, x \u003c- \"World\". When we run this line, we’ll update the value stored in x to be the string value \"World\". However, this will not change the value stored in y. This is because y stores a copy of the value that was previously stored in x, and any changes to the value stored in x will not impact the value stored in y at all. So, after running that line, our code trace should show the following:\nOnce we’ve done that, running the next three lines of code is pretty straightforward. We’ll just display the current value stored in in x and y, with a comma and space between them. So, at the end, our code trace should look like this:\nThe entire trace can be seen in the animation below:\nAs we have learned, code tracing is a very important skill, and it helped us discover one of the most important rules about working with variables: when we assign the value of one variable into another, we copy the existing value, but those two variables are not related to each other after the fact.\n",
    "description": "",
    "tags": null,
    "title": "Variables in Expressions",
    "uri": "/x-cis115-labs/2-print-variables/06-variables-in-expressions/"
  },
  {
    "content": " Moral Machine\n",
    "description": "",
    "tags": null,
    "title": "The Moral Machine",
    "uri": "/iii-topics/18-ai/12-moral-machine/"
  },
  {
    "content": " Resources Slides Video Script In the previous video we saw mosaic as an example of one of the first web browsers. It’s really credited with bringing a large number of people to the web because they could easily install it on their personal computers at home. Mosaic was eventually sold to eventually became Netscape Navigator, which was then sold to a new company called Mozilla, and rebranded as Mozilla Firefox. So in a way you can think of mosaic being the early ancestor to Mozilla Firefox. Lynx was another popular text based web browser at the time, and it was actually co-developed at the University of Kansas, so it’s pretty close to home.\nAnother one of the earliest web browsers was line mode. Line mode was really the first widely used web browser of its time, and CERN actually brought it back for the 20th anniversary of the World Wide Web. So if you go to the URL shown on this slide, you can actually browse the web as it looked in the early days in the early 1990s. So next, we move on to the later part. of the world wide web development, which is the rise of the commercial web from 1996 to 1999. As the World Wide Web grew larger and more popular, companies started to take notice and figure out how they could use the World Wide Web to connect new customers make their businesses well known. And eventually they figured out how to sell things on the internet. So for example, this screenshot is from Tiger Direct, which is a computer parts sales website. And this is the very first website that you can find for Tiger Direct using the Wayback Machine to see what it looked like in the early days. And so not only did TigerDirect have early webpages, but Apple computers was there.\nAnd you saw the development of some companies that we have today, such as Amazon, that leads to the era known as the Dot com boom from 1999 to 2001. This graph actually shows the stock market during that time and you can see it peaked right around 2000 before there was a huge crash into 2002 and 2003. So what happened is the internet really had some unprecedented growth from 1999 to 2001. And venture capitalists started investing in companies that really believe they would be the next big thing. In theory with the Dot Com Boom, they thought that if you spent a lot of money up front, then eventually you’d figure out ways to make money down the road. Unfortunately, that really didn’t work out as well as everyone thought, and many companies went bankrupt within a couple of years.\nThere were some survivors, of course. But let’s take a look at some real sobering statistics from the Dot com bust just to show you exactly what’s going on here. Infospace was a really big company in the early days of the World Wide Web and its stock price peaked at 1,300 a share in March 2000. By June 2002. It was down all the way to 2.67 cents, the learning company which was an early computer software company, to behind things such as the Oregon Trail and the common San Diego video games. It was bought for three and a half million dollars in 1999 but sold for just 27 million a year later. Another early product on the worldwide web was geo cities. One of the first places where you could host your own website on the web kind of like WordPress and Tumblr are today, Geo Cities was purchased by Yahoo for 3.5 billion dollars in 1999. But it was officially closed about 10 years later at a total loss. Of course, from the ashes of the Dot Com Bubble rises the internet that we know today.\nAnd the big thing we can think about that has changed the world wide web over the last 20 years is the rise of what we call web 2.0 and social media. With web 2.0. The focus is instead of a very few users knowing how to develop web pages, we have the creation of web content from the masses itself. Think about websites such as Wikipedia, but even Facebook and YouTube where a lot of the content is being generated by users such as you and I. You also have the rise of ubiquitous internet access. You don’t have to To be at a computer in a home anymore, or go to the library to access the internet, almost all of us carry around smart devices that we can access the internet at a moment’s notice. And we have access pretty much anywhere we go in the modern world today. Because of this, we’ve had the rise of mobile devices, and the easy access to data that we never thought it was even possible then. But of course, we’ve also had other things happen, such as the rise of search engines, the power of search engines, such as Google can’t be understated. In short, if Google doesn’t know about it, it’s really hard to find it on the internet. And so because of that, we can still be limited in the scope of things that we can see on the internet.\nBut with all of that today, the internet and the World Wide Web is a really core part of what we do as computer scientists and how we interact as humans today. And so I hope this video was really interesting in giving you some background and what the history of the internet looks like. In the next module, we’ll spend a little bit more time talking about the technologies to make the internet and the World Wide Web possible, as we know it today.\n",
    "description": "",
    "tags": null,
    "title": "Part 5",
    "uri": "/ii-internet/11-internethistory/12-part5/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 4.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/05-universal-computers/11-pots-reading/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 5.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/06-algorithms/11-pots-reading/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 6.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/07-encoding/08-pots-reading/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 8.\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/i-concepts/09-software-engineering/07-pots-reading/"
  },
  {
    "content": "CC 110 - Introduction to Computing - Spring 2023 Previous Versions\nInstructor Contact Information Instructor: Emily Alfs-Votipka (emilyalfs AT ksu DOT edu)\nI use she/her pronouns. Feel free to share your own pronouns with me, and I’ll do my best to use them! Office: DUE 2161 Office Hours: M/W 1:00-3:00 Want to meet with me outside of my regular office hours? https://calendly.com/emilyalfs Preferred Methods of Communication: Email: Please use “cc110-help” ( cc110-help@ksuemailprod.onmicrosoft.com if not on web-mail) for all communication regarding these courses as it allows instructors and TAs to provide a clear and detailed response, as well as easily store and record communication for reference later. You should receive a response within one business day, and hopefully much sooner. Note emailing the instructor or teaching assistants directly may result in longer wait times for your support. Undergraduate Teaching Assistants All TA office hours can be found on the embedded calendar below.\nName Carrie Aponte Nathan Herscovici Emma Lucas John Partridge Ryan Stueve Prerequisites None How to Get Help in this Course CC 110 can be an interesting course due to the large amount of material covered and much of the material is brand new to students. Therefore, you are encouraged to seek help whenever you feel you are being overwhelmed or don’t understand a topic. You are not alone! Most students in CC 110 have never studied anything relating to computer science before, so it is new to everyone. The instructors and TAs are always willing to help students with any questions you may have about the class or other issues related to Computing Science. So please, don’t be afraid to ask questions. Get help early and often!\nHere are the 4 recommended ways to get help on CC 110:\nReview the course materials posted on K-State Canvas and the course website Send assignment questions to the CC 110 Help email ( cc110-help@ksuemailprod.onmicrosoft.com) Visit your professor’s office hours, or the office hours for your TA if available Schedule a one-on-one meeting with your professor/TA Course Overview An overview of the history of computers and programming. Famous historical figures and their impact in modern computing. Introduction to major topics in computer science such as artificial intelligence, high performance computing, cryptography, big data, cyber security, robotics, and more. Brief experience with computer programming concepts.\nCourse Description This course serves as a primary introduction to modern computing and programming by reviewing historical figures and events and the impact they had on modern technology. Students are exposed to a variety of topics in computer science, and gain hands-on experience with some of these topics through the use of some basic programming skills. The goal of this course is to show students the wider world of computing and technology beyond programming, building a broad foundation for later courses to build upon.\nLearning Objectives By the end of this course, each student will be able to:\nDescribe the history of Computing Science and list some of the important devices, innovations, and people that got us to where we are today. Relate Computing Science to a variety of other disciplines and describe how they are interconnected with each other. Apply and use Computing Science tools and techniques to solve real-world problems. Research and learn about new ideas and areas in Computing Science and share those ideas with others. Develop a personal understanding of how Computing Science affects his or her own life. Understand many different subject areas within Computing Science and how they are changing our understanding of the field. Major Course Topics The history of computer science and early computing machines The basics of binary representation, Boolean logic, data encoding, encryption, and error checking Computational thinking, programming, and algorithm design The history and technology behind the internet and how it affects our world Computer science areas such as artificial intelligence, human-computer interaction, high performance computing, data science, robotics, and more Cybersecurity in a modern, interconnected world Other disciplines related to computer science Experience with basic programming concepts Course Structure These courses are being taught 100% online, and each module is self-paced. There may be some bumps in the road as we refine the overall course structure. Students will work at their own pace through a set of modules, with approximately one module being due each week. Material will be provided in the form of recorded videos, online tutorials, links to online resources, and discussion prompts. Some modules will include a coding project or assignment, many of which will be graded automatically through Codio. Assignments may also include portions which will be graded manually via Canvas or other tools.\nGrading In theory, each student begins the course with an A. As you submit work, you can either maintain your A (for good work) or chip away at it (for less adequate or incomplete work). In practice, each student starts with 0 points in the gradebook and works upward toward a final point total earned out of the possible number of points. In this course, each assignment constitutes a portion of the final grade, as detailed below:\n70% Canvas Quizzes 20% Codio Python Labs 10% Codio Python Assignments Letter grades will be assigned following the standard scale:\n90% - 100% → A 80% - 89.99% → B 70% - 79.99% → C 60% - 69.99% → D 00% - 59.99% → F Late Work Warning Read this late work policy very carefully! If you are unsure how to interpret it, please contact the instructors via the help email. Not understanding the policy does not mean that it won’t apply to you!\nSince this course is entirely online, students may work at any time and at their own pace through the modules. However, to keep everyone on track, there will be approximately one module due each week. Each graded item in the module will have a specific due date specified. Any assignment submitted late will have that assignment’s grade reduced by 10% of the total possible points on that project for each day it is late. This penalty will be assessed automatically in the Canvas gradebook.\nThe following table outlines the highest possible score that a module can earn based on when it is complete\nThursday Friday Saturday Sunday Monday Before or at 11:59PM CST 100% 90% 80% 70% 60% After 11:59PM CST 90% 80% 70% 60% 50% Even if a module is not submitted on time, it must still be completed before a student is allowed to begin the next module. So, students should take care not to get too far behind, as it may be very difficult to catch up.\nFinally, all course work must be submitted on or before the last day of the semester in which the student is enrolled in the course in order for it to be graded on time.\nIf you have extenuating circumstances, please discuss them with the instructor as soon as they arise so other arrangements can be made. If you find that you are getting behind in the class, you are encouraged to speak to the instructor for options to make up missed work.\nIncomplete Policy Students should strive to complete this course in its entirety before the end of the semester in which they are enrolled. However, since retaking the course would be costly and repetitive for students, we would like to give students a chance to succeed with a little help rather than immediately fail students who are struggling.\nIf you are unable to complete the course in a timely manner, please contact the instructor to discuss an incomplete grade. Incomplete grades are given solely at the instructor’s discretion. See the official K-State Grading Policy for more information. In general, poor time management alone is not a sufficient reason for an incomplete grade.\nUnless otherwise noted in writing on a signed Incomplete Agreement Form, the following stipulations apply to any incomplete grades given in Computational Core courses:\nStudents may receive at most two incompletes in Computational Core courses throughout their time in the program Students will be given 6 calendar weeks from the end of the enrolled semester’s finals week to complete the course Any modules in a future CC course which depend on incomplete work will not be accessible until the previous course is finished For example, if a student is given an incomplete in CC 210, then all modules in CC 310 will be inaccessible until CC 210 is complete Students understand that access to instructor and GTA assistance may be limited after the end of an academic semester due to holidays and other obligations If a student fails to resolve an incomplete grade after 6 weeks, they will be assigned an ‘F’ in the course. In addition, they will be dropped from any other Computational Core courses which require the failed course as a prerequisite or corequisite. Recommended Texts \u0026 Supplies To participate in this course, students must have access to a modern web browser and broadband internet connection. All course materials will be provided via Canvas and Codio. Modules may also contain links to external resources for additional information, such as programming language documentation.\nSubject to Change The details in this syllabus are not set in stone. Due to the flexible nature of this class, adjustments may need to be made as the semester progresses, though they will be kept to a minimum. If any changes occur, the changes will be posted on the Canvas page for this course and emailed to all students.\nAcademic Honesty Kansas State University has an Honor and Integrity System based on personal integrity, which is presumed to be sufficient assurance that, in academic matters, one’s work is performed honestly and without unauthorized assistance. Undergraduate and graduate students, by registration, acknowledge the jurisdiction of the Honor and Integrity System. The policies and procedures of the Honor and Integrity System apply to all full and part-time students enrolled in undergraduate and graduate courses on-campus, off-campus, and via distance learning. A component vital to the Honor and Integrity System is the inclusion of the Honor Pledge which applies to all assignments, examinations, or other course work undertaken by students. The Honor Pledge is implied, whether or not it is stated: “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” A grade of XF can result from a breach of academic honesty. The F indicates failure in the course; the X indicates the reason is an Honor Pledge violation.\nFor this course, a violation of the Honor Pledge will result in sanctions such as a 0 on the assignment or an XF in the course, depending on severity. Actively seeking unauthorized aid, such as posting lab assignments on sites such as Chegg or StackOverflow, or asking another person to complete your work, even if unsuccessful, will result in an immediate XF in the course.\nUse of AI text and code generators such as ChatGPT and GitHub Copilot in any submission for this course is strictly forbidden unless explicitly allowed by your instructor. Any unauthorized use of these tools is considered plagiarism.\nWe reserve the right to use various platforms that can perform automatic plagiarism detection by tracking changes made to files and comparing submitted projects against other students’ submissions and known solutions. That information may be used to determine if plagiarism has taken place.\nWarning The copying and pasting of code is not allowed. All coding must be done in the Codio IDE. If you paste any code into Codio (other than code which is explicitly given as starter code in the course) a zero will be given. If the violation occurs a second time, an XF will be given for the course.\nAuthorized Aid All graded work is individual effort. You are authorized to use:\ncourse’s materials, direct web-links from this course the appropriate languages documentation (https://docs.python.org/3/ or https://docs.oracle.com/javase/ Links to an external site.) Email help received through 110 help email, CC - Instructors, GTAs Zoom/In-person help received from Instructors or GTA ACM help session (an on campus only resource) Most Tuesdays in EH 1116, 6:30PM. Tutors from the Academic Assistance Center or provided by K-State Athletics Use of on-line solutions whether for reference or code is prohibited. Use of previous semester’s answers, whether your own or another student’s is prohibited. Use of code-completion/suggestion tool’s, other than those we have installed in the Codio editor, is prohibited.\nStandard Syllabus Statements Info The statements below are standard syllabus statements from K-State and our program. The latest versions are available online here.\nStudents with Disabilities At K-State it is important that every student has access to course content and the means to demonstrate course mastery. Students with disabilities may benefit from services including accommodations provided by the Student Access Center. Disabilities can include physical, learning, executive functions, and mental health. You may register at the Student Access Center or to learn more contact:\nManhattan/Olathe/Global Campus – Student Access Center accesscenter@k-state.edu 785-532-6441 K-State Salina Campus – Julie Rowe; Student Success Coordinator jarowe@k-state.edu 785-820-7908 Students already registered with the Student Access Center please request your Letters of Accommodation early in the semester to provide adequate time to arrange your approved academic accommodations. Once SAC approves your Letter of Accommodation it will be e-mailed to you, and your instructor(s) for this course. Please follow up with your instructor to discuss how best to implement the approved accommodations.\nExpectations for Conduct All student activities in the University, including this course, are governed by the Student Judicial Conduct Code as outlined in the Student Governing Association By Laws, Article V, Section 3, number 2. Students who engage in behavior that disrupts the learning environment may be asked to leave the class.\nMutual Respect and Inclusion in K-State Teaching \u0026 Learning Spaces At K-State, faculty and staff are committed to creating and maintaining an inclusive and supportive learning environment for students from diverse backgrounds and perspectives. K-State courses, labs, and other virtual and physical learning spaces promote equitable opportunity to learn, participate, contribute, and succeed, regardless of age, race, color, ethnicity, nationality, genetic information, ancestry, disability, socioeconomic status, military or veteran status, immigration status, Indigenous identity, gender identity, gender expression, sexuality, religion, culture, as well as other social identities.\nFaculty and staff are committed to promoting equity and believe the success of an inclusive learning environment relies on the participation, support, and understanding of all students. Students are encouraged to share their views and lived experiences as they relate to the course or their course experience, while recognizing they are doing so in a learning environment in which all are expected to engage with respect to honor the rights, safety, and dignity of others in keeping with the K-State Principles of Community.\nIf you feel uncomfortable because of comments or behavior encountered in this class, you may bring it to the attention of your instructor, advisors, and/or mentors. If you have questions about how to proceed with a confidential process to resolve concerns, please contact the Student Ombudsperson Office. Violations of the student code of conduct can be reported using the Code of Conduct Reporting Form. You can also report discrimination, harassment or sexual harassment, if needed.\nNetiquette Info This is our personal policy and not a required syllabus statement from K-State. It has been adapted from this statement from K-State Global Campus, and the Recurse Center Manual. We have adapted their ideas to fit this course.\nOnline communication is inherently different than in-person communication. When speaking in person, many times we can take advantage of the context and body language of the person speaking to better understand what the speaker means, not just what is said. This information is not present when communicating online, so we must be much more careful about what we say and how we say it in order to get our meaning across.\nHere are a few general rules to help us all communicate online in this course, especially while using tools such as Canvas or Discord:\nUse a clear and meaningful subject line to announce your topic. Subject lines such as “Question” or “Problem” are not helpful. Subjects such as “Logic Question in Project 5, Part 1 in Java” or “Unexpected Exception when Opening Text File in Python” give plenty of information about your topic. Use only one topic per message. If you have multiple topics, post multiple messages so each one can be discussed independently. Be thorough, concise, and to the point. Ideally, each message should be a page or less. Include exact error messages, code snippets, or screenshots, as well as any previous steps taken to fix the problem. It is much easier to solve a problem when the exact error message or screenshot is provided. If we know what you’ve tried so far, we can get to the root cause of the issue more quickly. Consider carefully what you write before you post it. Once a message is posted, it becomes part of the permanent record of the course and can easily be found by others. If you are lost, don’t know an answer, or don’t understand something, speak up! Email and Canvas both allow you to send a message privately to the instructors, so other students won’t see that you asked a question. Don’t be afraid to ask questions anytime, as you can choose to do so without any fear of being identified by your fellow students. Class discussions are confidential. Do not share information from the course with anyone outside of the course without explicit permission. Do not quote entire message chains; only include the relevant parts. When replying to a previous message, only quote the relevant lines in your response. Do not use all caps. It makes it look like you are shouting. Use appropriate text markup (bold, italics, etc.) to highlight a point if needed. No feigning surprise. If someone asks a question, saying things like “I can’t believe you don’t know that!” are not helpful, and only serve to make that person feel bad. No “well-actually’s.” If someone makes a statement that is not entirely correct, resist the urge to offer a “well, actually…” correction, especially if it is not relevant to the discussion. If you can help solve their problem, feel free to provide correct information, but don’t post a correction just for the sake of being correct. Do not correct someone’s grammar or spelling. Again, it is not helpful, and only serves to make that person feel bad. If there is a genuine mistake that may affect the meaning of the post, please contact the person privately or let the instructors know privately so it can be resolved. Avoid subtle -isms and microaggressions. Avoid comments that could make others feel uncomfortable based on their personal identity. See the syllabus section on Diversity and Inclusion above for more information on this topic. If a comment makes you uncomfortable, please contact the instructor. Avoid sarcasm, flaming, advertisements, lingo, trolling, doxxing, and other bad online habits. They have no place in an academic environment. Tasteful humor is fine, but sarcasm can be misunderstood. As a participant in course discussions, you should also strive to honor the diversity of your classmates by adhering to the K-State Principles of Community.\nFace Coverings Kansas State University strongly encourages, but does not require, that everyone wear masks while indoors on university property, including while attending in-person classes. For additional information and the latest updates, see K-State’s face covering policy.\nDiscrimination, Harassment, and Sexual Harassment Kansas State University is committed to maintaining academic, housing, and work environments that are free of discrimination, harassment, and sexual harassment. Instructors support the University’s commitment by creating a safe learning environment during this course, free of conduct that would interfere with your academic opportunities. Instructors also have a duty to report any behavior they become aware of that potentially violates the University’s policy prohibiting discrimination, harassment, and sexual harassment, as outlined by PPM 3010.\nIf a student is subjected to discrimination, harassment, or sexual harassment, they are encouraged to make a non-confidential report to the University’s Office for Institutional Equity (OIE) using the online reporting form. Incident disclosure is not required to receive resources at K-State. Reports that include domestic and dating violence, sexual assault, or stalking, should be considered for reporting by the complainant to the Kansas State University Police Department or the Riley County Police Department. Reports made to law enforcement are separate from reports made to OIE. A complainant can choose to report to one or both entities. Confidential support and advocacy can be found with the K-State Center for Advocacy, Response, and Education (CARE). Confidential mental health services can be found with Lafene Counseling and Psychological Services (CAPS). Academic support can be found with the Office of Student Life (OSL). OSL is a non-confidential resource. OIE also provides a comprehensive list of resources on their website. If you have questions about non-confidential and confidential resources, please contact OIE at equity@ksu.edu or (785) 532–6220.\nAcademic Freedom Statement Kansas State University is a community of students, faculty, and staff who work together to discover new knowledge, create new ideas, and share the results of their scholarly inquiry with the wider public. Although new ideas or research results may be controversial or challenge established views, the health and growth of any society requires frank intellectual exchange. Academic freedom protects this type of free exchange and is thus essential to any university’s mission.\nMoreover, academic freedom supports collaborative work in the pursuit of truth and the dissemination of knowledge in an environment of inquiry, respectful debate, and professionalism. Academic freedom is not limited to the classroom or to scientific and scholarly research, but extends to the life of the university as well as to larger social and political questions. It is the right and responsibility of the university community to engage with such issues.\nCampus Safety Kansas State University is committed to providing a safe teaching and learning environment for student and faculty members. In order to enhance your safety in the unlikely case of a campus emergency make sure that you know where and how to quickly exit your classroom and how to follow any emergency directives. Current Campus Emergency Information is available at the University’s Advisory webpage.\nStudent Resources K-State has many resources to help contribute to student success. These resources include accommodations for academics, paying for college, student life, health and safety, and others. Check out the Student Guide to Help and Resources: One Stop Shop for more information.\nStudent Academic Creations Student academic creations are subject to Kansas State University and Kansas Board of Regents Intellectual Property Policies. For courses in which students will be creating intellectual property, the K-State policy can be found at University Handbook, Appendix R: Intellectual Property Policy and Institutional Procedures (part I.E.). These policies address ownership and use of student academic creations.\nMental Health Your mental health and good relationships are vital to your overall well-being. Symptoms of mental health issues may include excessive sadness or worry, thoughts of death or self-harm, inability to concentrate, lack of motivation, or substance abuse. Although problems can occur anytime for anyone, you should pay extra attention to your mental health if you are feeling academic or financial stress, discrimination, or have experienced a traumatic event, such as loss of a friend or family member, sexual assault or other physical or emotional abuse.\nIf you are struggling with these issues, do not wait to seek assistance.\nKansas State University Counseling and Psychological Services offers free and confidential services to assist you to meet these challenges. Lafene Health Center has specialized nurse practitioners to assist with mental health. The Office of Student Life can direct you to additional resources. K-State Family Center offers individual, couple, and family counseling services on a sliding fee scale. Center for Advocacy, Response, and Education (CARE) provides free and confidential assistance for those in our K-State community who have been victimized by violence. For Kansas State Salina Campus:\nKansas State Salina Counseling Services offers free and confidential services to assist you to meet these challenges. The Kansas State Salina Office of Student Life can direct you to additional resources. The Kansas State Salina Campus offers several services for students, including health services, counseling, and academic assistance. University Excused Absences K-State has a University Excused Absence policy (Section F62). Class absence(s) will be handled between the instructor and the student unless there are other university offices involved. For university excused absences, instructors shall provide the student the opportunity to make up missed assignments, activities, and/or attendance specific points that contribute to the course grade, unless they decide to excuse those missed assignments from the student’s course grade. Please see the policy for a complete list of university excused absences and how to obtain one. Students are encouraged to contact their instructor regarding their absences.\nCopyright Notice © The materials in this online course fall under the protection of all intellectual property, copyright and trademark laws of the U.S. The digital materials included here come with the legal permissions and releases of the copyright holders. These course materials should be used for educational purposes only; the contents should not be distributed electronically or otherwise beyond the confines of this online course. The URLs listed here do not suggest endorsement of either the site owners or the contents found at the sites. Likewise, mentioned brands (products and services) do not suggest endorsement. Students own copyright to what they create.\n",
    "description": "",
    "tags": null,
    "title": "CC 110 Syllabus - Spring 2023",
    "uri": "/00-introduction/06-cc110-syllabus/"
  },
  {
    "content": "CIS 115 - Introduction to Computing Science - Spring 2023 Previous Versions\nContact Info All emails for the course should be sent to cis115help@KSUemailProd.onmicrosoft.com (sorry I know it’s a long address). This will contact the professors and ALL the TAs for the course and guarantee the fastest response time if contacting via email (please allow one full business day for response). You are welcome to send emails that may contain more sensitive information directly to intended recipients.\nCommunication can also be done through Microsoft Teams. If you have not been invited to join the team for CIS 115, please let any of us know and we will get you added.\nInstructor: Emily Alfs-Votipka (she/her) – emilyalfs@ksu.edu (teaches sections C)\nOffice: 2161 Engineering Hall (DUE) Office Hours: M/W 1:00-3:00 Want to meet with me outside of my regular office hours? https://calendly.com/emilyalfs Instructor: Joshua Weese (he/him) – weeser@ksu.edu (teaches sections B )\nOffice: 2214 Engineering Hall (DUE) Phone: See calendar below Office Hours: weeser.net/calendar Want to meet with me? https://calendly.com/weeser Undergraduate Teaching Assistants All TA office hours can be found on the embedded calendar below.\nName Section Nathan Herscovici B,C Emma Lucas B,C John Partridge B,C Carrie Aponte - Ryan Stueve - Office Hours and Course Schedule Section B - with Dr. Joshua Weese Tuesday 10:15 - 12:05 DUE 1117 Section C - with Emily Alfs-Votipka Tuesday 12:25 - 2:15 DUE 1117 Required Texts “The Pattern on the Stone: The Simple Ideas that Make Computers Work” by W. Daniel Hillis. ISBN 046502596X, newer version is also available and will work fine Free digital version though the KSU Library: https://k-state.primo.exlibrisgroup.com/permalink/01KSU_INST/1bihi0g/alma9942605917302401 “Nine Algorithms That Changed the Future: The Ingenious Ideas That Drive Today’s Computers” by John MacCormick. ISBN 0691158193 “A Byte of Python” by Swwaroop C.H. This book is free! Its accessed at https://python.swaroopch.com/ Download: https://github.com/swaroopch/byte-of-python/releases/latest Required Software We will also be using Python 3 as the language for the programming assignments. It can be found at python.org. Information on downloading and installing Python will be given in class.\nOptional Reading These are books we’ve found to be interesting and/or useful:\n“Tubes: A Journey to the Center of the Internet” by Andrew Blum. ISBN 0061994952 “Blown to Bits: Your Life, Liberty, and Happiness After the Digital Explosion” by Hal Abelson, Ken Ledeen, and Harry Lewis. ISBN 013713559, Creative Commons digital edition available FREE at http://www.bitsbook.com/ “Code: The Hidden Language of Computer Hardware and Software” by Charles Petzold. ISBN 0735611319 “How Not to be Wrong: The Power of Mathematical Thinking” by Jordan Ellenberg. ISBN 0143127535 “The Innovators: How a Group of Hackers, Geniuses and Geeks Created the Digital Revolution” by Walter Isaacson. ISBN 1476708703 How to Get Help in this Course CIS 115 can be an interesting course due to the large amount of material covered and much of the material is brand new to students. Therefore, you are encouraged to seek help whenever you feel you are being overwhelmed or don’t understand a topic. You are not alone! Most students in CIS 115 have never studied anything relating to computer science before, so it is new to everyone. The instructors and TAs are always willing to help students with any questions you may have about the class or other issues related to Computing Science. So please, don’t be afraid to ask questions. Get help early and often!\nHere are the 5 recommended ways to get help on CIS 115:\nReview the course materials posted on K-State Canvas and the course website Send assignment questions to the CIS 115 Help email ( cis115help@KSUemailProd.onmicrosoft.com) OR via Microsoft Teams (The channels are intended for general questions, sharing of code/answers is restricted to direct messages). Visit your professor’s office hours, or the office hours for your TA if available Ask your teammates for help or advice on assignments or projects (be mindful of the honor code!) Schedule a one-on-one meeting with your professor/TA Course Description This course is an introduction to the history, fundamental theories, basic programming, and research areas within Computing Science and its related disciplines. Computing Science has a direct impact on many facets of daily life, but very few of us ever take the time to wonder how it all works. This course aims to fill that void.\nTo accomplish this goal, we will do several hands-on learning activities, have meaningful in-class discussions, write about our own thoughts and opinions on various subjects, and research topics that are central to Computing Science. While doing so, we will try to relate the concepts we are learning to real-world problems and ideas.\nCourse Objectives By the end of this course, each student will be able to:\nDescribe the history of Computing Science and list some of the important devices, innovations, and people that got us to where we are today. Relate Computing Science to a variety of other disciplines and describe how they are interconnected with each other. Apply and use Computing Science tools and techniques to solve real-world problems. Research and learn about new ideas and areas in Computing Science and share those ideas with others, all without direct guidance. Develop a personal understanding of how Computing Science affects his or her own life. Understand many different subject areas within Computing Science and how they are changing our understanding of the field. Major Course Topics The history of Computing Science and early computing machines Computational thinking, programming, and algorithm design The history and technology behind the internet and how it affects our world Traditional Computing Science areas such as artificial intelligence, human-computer interaction, high performance computing, big data, robotics, and more Cybersecurity in a modern, interconnected world Other disciplines and how they relate to Computing Science. Course Structure In short, this course will focus on several learning activities designed to engage and interest students in a variety of topics while helping them think more deeply about each topic and why it is important in Computing Science. This class will require a considerable, but reasonable, amount of effort, not only from the students but the instructors and TAs as well. In addition to exercises and activities, there will be several assignments and group projects to be completed.\nCIS 115 is a studio-type course, meaning that much of the course is done online. It is expected that you complete the online material/readings before you come to class so we can have discussions on that weeks material. Class time will be dedicated to activities, discussions, and programming work. While most work for the course is available online, there will be some content that will be available only in class. There will be about two modules of content delivered each week, along with some Python programming content. Each module given will have a quiz over the content covered so it is important to stay caught up on module content each week (see late policy below)!\nAttendance and Participation in Class Activities Attendance in class is required. The majority of class periods will include hands-on/group activities to be completed in class that will help illustrate the topic of the day. Collaborating and communicating with others in the class is a large part of these activities and is encouraged. Participating in each of these activities is key to learning, so failing to attend class or complete in-class activities and labs will result in a reduced grade for that day’s work. *Simply attending class does not guarantee that you will receive points*\nFace coverings are not required; however, they are encouraged if you are feeling ill. (See general face coverings policy down below)\nNeed to miss a class? Work will never be completely excused, however some exceptions/extensions can be given in 2 situations:\nYou are absent due to a university activity and have given the instructor prior notice of the absence. Excuses after the absence will not be accepted, even for university activities\nYou have a “major life event” that prevents you from completing class, such as an illness or family emergency. These events must be verified through the K-State Office of Student Life. Contact them AS SOON AS YOU CAN once you know you will be away from class. They will work with your instructors while you are gone. Contact your instructor once you are able to discuss make-up work and absences.\nNote Attendance accommodations include all COVID related causes, but Student Life should still be some of the first people you contact.\nAssignments Warning Assignments are to be completed without any collaboration with classmates or other outside help unless otherwise stated. It is crucial that all work you do is your own. Posting (even if you don’t get a response) course content on Stack Overflow, Chegg, or other similar websites is expressly forbidden and will result in an XF. This includes viewing posts as well. It also includes viewing solutions to course content that has not been provided to you through canvas by your instructor or TA.\n*If you are struggling in the course or you have doubts on something, please ask! Your instructors and TAs are here to help!* There will be some programming or written assignments given from time to time that must be completed outside of class. It is acceptable to communicate with other students about the concepts in the assignment if you do not understand it, but you should not discuss the details of how the assignment should be completed. Your submission should be your own work, or the work of your small group if allowed by the instructor. Some work will require you to look up certain programming syntax and techniques on the internet, but there is a fine line between learning and copying! When in doubt, ask!\nGrading 20% - Topic Research and Wiki Article 15% - Programming Labs (Lowest lab is dropped) and Programming Homework 10% - Discussions 30% - Quizzes (Lowest two scores are dropped) Exams 15% - Python Exams 10% - Final Exam Letter grades will be assigned following the standard scale:\n90% - 100% - A; 80% - 89.99% - B; 70% - 79.99% - C; 60% - 69.99% - D; 00% - 59.99% - F\nLate Work Warning Poor planning/procrastination on your part does not constitute as an emergency on ours.\nEvery student should strive to turn in work on time. Late work will receive penalty of 10% of the possible points for each partial day it is late. Some assignments will NOT be accepted late! Others will be limited to a maximum of three days late (not always 3 days). You can see if an assignment is accepted late by seeing if the last available date for that assignment in canvas goes past its due date. Missed class attendance cannot be made up, though as mentioned above some areas will drop the lowest score. If you are getting behind in the class, you are encouraged to speak to the instructor before it becomes too late to recover.\nProgramming Work Warning Programming assignments that are turned in and do not run or that are not in the required format will receive a grade of 0, no exceptions. My recommendation to avoid making this mistake is to check your solution after you submitted it to Canvas. Redownload what you submitted from Canvas and run it again to assure that the program you submitted is working as intended.\nThere will be two primary types of programming assignments: homework and labs. Labs will be only available to be completed during designated class times unless otherwise stated. To get credit for completing a lab, you must have your work checked off by the professor or TA before leaving class. Partial credit is awarded for labs started in class, but not completed in time. No credit is given for a lab if you do not attend class unless a prior arrangement is made given a valid reason (see attendance policy). Homework will be individual work unless otherwise stated and is intended to be done outside of class time. Work that is not your own will be considered a violation of the honor code. Class time may be used for working on homework if you have completed the lab work for that class period.\nTeam Assignments Students will be assigned to a team at the beginning of the semester. Each team will be responsible for completing two major projects during the semester. Some group work will include a REQUIRED peer evaluation component which can adjust that portion of the individual’s grade up to 50%. If a student should fail to contribute to a group assignment at all, their grade for that assignment will be reduced to a zero. Failure to complete the peer evaluation will result in a 10% grade deduction for that assignment.\nTopic Research Each team will be given a topic to research. The team will locate and organize materials to use when presenting the topic to the class. The materials should include both online and offline resources. The team will then create a presentation to share the information about their topic with the class. That research will then be used to write the wiki article.\nWiki Article Each team will use the material collected for the topic research project, as well as information from the resulting class discussions, to create an article to be added to the final course wiki. The article is expected to be a thorough examination of the topic and should be written in such a way that others taking this course can read it and understand the material. The team will be responsible for finalizing the entire draft of the wiki and making sure it has a consistent design and feel to it.\nSafe Zone Statement We are part of the SafeZone community network of trained K-State faculty/staff/students who are available to listen and support you. As a SafeZone Ally, I can help you connect with resources on campus to address problems you face that interfere with your academic success, particularly issues of sexual violence, hateful acts, or concerns faced by individuals due to sexual orientation/gender identity. My goal is to help you be successful and to maintain a safe and equitable campus.\nStandard Syllabus Statements Info The statements below are standard syllabus statements from K-State and our program. The latest versions are available online here.\nAcademic Honesty Kansas State University has an Honor and Integrity System based on personal integrity, which is presumed to be sufficient assurance that, in academic matters, one’s work is performed honestly and without unauthorized assistance. Undergraduate and graduate students, by registration, acknowledge the jurisdiction of the Honor and Integrity System. The policies and procedures of the Honor and Integrity System apply to all full and part-time students enrolled in undergraduate and graduate courses on-campus, off-campus, and via distance learning. A component vital to the Honor and Integrity System is the inclusion of the Honor Pledge which applies to all assignments, examinations, or other course work undertaken by students. The Honor Pledge is implied, whether or not it is stated: “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” A grade of XF can result from a breach of academic honesty. The F indicates failure in the course; the X indicates the reason is an Honor Pledge violation.\nFor this course, a violation of the Honor Pledge will result in sanctions such as a 0 on the assignment or an XF in the course, depending on severity. Actively seeking unauthorized aid, such as posting lab assignments on sites such as Chegg or StackOverflow, or asking another person to complete your work, even if unsuccessful, will result in an immediate XF in the course.\nUse of AI text and code generators such as ChatGPT and GitHub Copilot in any submission for this course is strictly forbidden unless explicitly allowed by your instructor. Any unauthorized use of these tools is considered plagiarism.\nWe reserve the right to use various platforms that can perform automatic plagiarism detection by tracking changes made to files and comparing submitted projects against other students’ submissions and known solutions. That information may be used to determine if plagiarism has taken place.\nStudents with Disabilities At K-State it is important that every student has access to course content and the means to demonstrate course mastery. Students with disabilities may benefit from services including accommodations provided by the Student Access Center. Disabilities can include physical, learning, executive functions, and mental health. You may register at the Student Access Center or to learn more contact:\nManhattan/Olathe/Global Campus – Student Access Center accesscenter@k-state.edu 785-532-6441 K-State Salina Campus – Julie Rowe; Student Success Coordinator jarowe@k-state.edu 785-820-7908 Students already registered with the Student Access Center please request your Letters of Accommodation early in the semester to provide adequate time to arrange your approved academic accommodations. Once SAC approves your Letter of Accommodation it will be e-mailed to you, and your instructor(s) for this course. Please follow up with your instructor to discuss how best to implement the approved accommodations.\nExpectations for Conduct All student activities in the University, including this course, are governed by the Student Judicial Conduct Code as outlined in the Student Governing Association By Laws, Article V, Section 3, number 2. Students who engage in behavior that disrupts the learning environment may be asked to leave the class.\nMutual Respect and Inclusion in K-State Teaching \u0026 Learning Spaces At K-State, faculty and staff are committed to creating and maintaining an inclusive and supportive learning environment for students from diverse backgrounds and perspectives. K-State courses, labs, and other virtual and physical learning spaces promote equitable opportunity to learn, participate, contribute, and succeed, regardless of age, race, color, ethnicity, nationality, genetic information, ancestry, disability, socioeconomic status, military or veteran status, immigration status, Indigenous identity, gender identity, gender expression, sexuality, religion, culture, as well as other social identities.\nFaculty and staff are committed to promoting equity and believe the success of an inclusive learning environment relies on the participation, support, and understanding of all students. Students are encouraged to share their views and lived experiences as they relate to the course or their course experience, while recognizing they are doing so in a learning environment in which all are expected to engage with respect to honor the rights, safety, and dignity of others in keeping with the K-State Principles of Community.\nIf you feel uncomfortable because of comments or behavior encountered in this class, you may bring it to the attention of your instructor, advisors, and/or mentors. If you have questions about how to proceed with a confidential process to resolve concerns, please contact the Student Ombudsperson Office. Violations of the student code of conduct can be reported using the Code of Conduct Reporting Form. You can also report discrimination, harassment or sexual harassment, if needed.\nNetiquette Info This is our personal policy and not a required syllabus statement from K-State. It has been adapted from this statement from K-State Global Campus, and the Recurse Center Manual. We have adapted their ideas to fit this course.\nOnline communication is inherently different than in-person communication. When speaking in person, many times we can take advantage of the context and body language of the person speaking to better understand what the speaker means, not just what is said. This information is not present when communicating online, so we must be much more careful about what we say and how we say it in order to get our meaning across.\nHere are a few general rules to help us all communicate online in this course, especially while using tools such as Canvas or Discord:\nUse a clear and meaningful subject line to announce your topic. Subject lines such as “Question” or “Problem” are not helpful. Subjects such as “Logic Question in Project 5, Part 1 in Java” or “Unexpected Exception when Opening Text File in Python” give plenty of information about your topic. Use only one topic per message. If you have multiple topics, post multiple messages so each one can be discussed independently. Be thorough, concise, and to the point. Ideally, each message should be a page or less. Include exact error messages, code snippets, or screenshots, as well as any previous steps taken to fix the problem. It is much easier to solve a problem when the exact error message or screenshot is provided. If we know what you’ve tried so far, we can get to the root cause of the issue more quickly. Consider carefully what you write before you post it. Once a message is posted, it becomes part of the permanent record of the course and can easily be found by others. If you are lost, don’t know an answer, or don’t understand something, speak up! Email and Canvas both allow you to send a message privately to the instructors, so other students won’t see that you asked a question. Don’t be afraid to ask questions anytime, as you can choose to do so without any fear of being identified by your fellow students. Class discussions are confidential. Do not share information from the course with anyone outside of the course without explicit permission. Do not quote entire message chains; only include the relevant parts. When replying to a previous message, only quote the relevant lines in your response. Do not use all caps. It makes it look like you are shouting. Use appropriate text markup (bold, italics, etc.) to highlight a point if needed. No feigning surprise. If someone asks a question, saying things like “I can’t believe you don’t know that!” are not helpful, and only serve to make that person feel bad. No “well-actually’s.” If someone makes a statement that is not entirely correct, resist the urge to offer a “well, actually…” correction, especially if it is not relevant to the discussion. If you can help solve their problem, feel free to provide correct information, but don’t post a correction just for the sake of being correct. Do not correct someone’s grammar or spelling. Again, it is not helpful, and only serves to make that person feel bad. If there is a genuine mistake that may affect the meaning of the post, please contact the person privately or let the instructors know privately so it can be resolved. Avoid subtle -isms and microaggressions. Avoid comments that could make others feel uncomfortable based on their personal identity. See the syllabus section on Diversity and Inclusion above for more information on this topic. If a comment makes you uncomfortable, please contact the instructor. Avoid sarcasm, flaming, advertisements, lingo, trolling, doxxing, and other bad online habits. They have no place in an academic environment. Tasteful humor is fine, but sarcasm can be misunderstood. As a participant in course discussions, you should also strive to honor the diversity of your classmates by adhering to the K-State Principles of Community.\nDiscrimination, Harassment, and Sexual Harassment Kansas State University is committed to maintaining academic, housing, and work environments that are free of discrimination, harassment, and sexual harassment. Instructors support the University’s commitment by creating a safe learning environment during this course, free of conduct that would interfere with your academic opportunities. Instructors also have a duty to report any behavior they become aware of that potentially violates the University’s policy prohibiting discrimination, harassment, and sexual harassment, as outlined by PPM 3010.\nIf a student is subjected to discrimination, harassment, or sexual harassment, they are encouraged to make a non-confidential report to the University’s Office for Institutional Equity (OIE) using the online reporting form. Incident disclosure is not required to receive resources at K-State. Reports that include domestic and dating violence, sexual assault, or stalking, should be considered for reporting by the complainant to the Kansas State University Police Department or the Riley County Police Department. Reports made to law enforcement are separate from reports made to OIE. A complainant can choose to report to one or both entities. Confidential support and advocacy can be found with the K-State Center for Advocacy, Response, and Education (CARE). Confidential mental health services can be found with Lafene Counseling and Psychological Services (CAPS). Academic support can be found with the Office of Student Life (OSL). OSL is a non-confidential resource. OIE also provides a comprehensive list of resources on their website. If you have questions about non-confidential and confidential resources, please contact OIE at equity@ksu.edu or (785) 532–6220.\nAcademic Freedom Statement Kansas State University is a community of students, faculty, and staff who work together to discover new knowledge, create new ideas, and share the results of their scholarly inquiry with the wider public. Although new ideas or research results may be controversial or challenge established views, the health and growth of any society requires frank intellectual exchange. Academic freedom protects this type of free exchange and is thus essential to any university’s mission.\nMoreover, academic freedom supports collaborative work in the pursuit of truth and the dissemination of knowledge in an environment of inquiry, respectful debate, and professionalism. Academic freedom is not limited to the classroom or to scientific and scholarly research, but extends to the life of the university as well as to larger social and political questions. It is the right and responsibility of the university community to engage with such issues.\nCampus Safety Kansas State University is committed to providing a safe teaching and learning environment for student and faculty members. In order to enhance your safety in the unlikely case of a campus emergency make sure that you know where and how to quickly exit your classroom and how to follow any emergency directives. Current Campus Emergency Information is available at the University’s Advisory webpage.\nStudent Resources K-State has many resources to help contribute to student success. These resources include accommodations for academics, paying for college, student life, health and safety, and others. Check out the Student Guide to Help and Resources: One Stop Shop for more information.\nStudent Academic Creations Student academic creations are subject to Kansas State University and Kansas Board of Regents Intellectual Property Policies. For courses in which students will be creating intellectual property, the K-State policy can be found at University Handbook, Appendix R: Intellectual Property Policy and Institutional Procedures (part I.E.). These policies address ownership and use of student academic creations.\nMental Health Your mental health and good relationships are vital to your overall well-being. Symptoms of mental health issues may include excessive sadness or worry, thoughts of death or self-harm, inability to concentrate, lack of motivation, or substance abuse. Although problems can occur anytime for anyone, you should pay extra attention to your mental health if you are feeling academic or financial stress, discrimination, or have experienced a traumatic event, such as loss of a friend or family member, sexual assault or other physical or emotional abuse.\nIf you are struggling with these issues, do not wait to seek assistance.\nKansas State University Counseling and Psychological Services offers free and confidential services to assist you to meet these challenges. Lafene Health Center has specialized nurse practitioners to assist with mental health. The Office of Student Life can direct you to additional resources. K-State Family Center offers individual, couple, and family counseling services on a sliding fee scale. Center for Advocacy, Response, and Education (CARE) provides free and confidential assistance for those in our K-State community who have been victimized by violence. For Kansas State Salina Campus:\nKansas State Salina Counseling Services offers free and confidential services to assist you to meet these challenges. The Kansas State Salina Office of Student Life can direct you to additional resources. The Kansas State Salina Campus offers several services for students, including health services, counseling, and academic assistance. University Excused Absences K-State has a University Excused Absence policy (Section F62). Class absence(s) will be handled between the instructor and the student unless there are other university offices involved. For university excused absences, instructors shall provide the student the opportunity to make up missed assignments, activities, and/or attendance specific points that contribute to the course grade, unless they decide to excuse those missed assignments from the student’s course grade. Please see the policy for a complete list of university excused absences and how to obtain one. Students are encouraged to contact their instructor regarding their absences.\nSubject to Change The details in this syllabus are not set in stone. Due to the flexible nature of this class, adjustments may need to be made as the semester progresses, though they will be kept to a minimum. If any changes occur, the changes will be posted on the K-State Canvas page for this course and emailed to all students.\nCopyright Notification Copyright 2023 (Joshua L. Weese and Emily Alfs-Votipka) as to this syllabus, all lectures, and course content. During this course students are prohibited from selling notes to or being paid for taking notes by any person or commercial firm without the express written permission of the professor teaching this course. In addition, students in this class are not authorized to provide class notes or other class-related materials to any other person or entity, other than sharing them directly with another student taking the class for purposes of studying, without prior written permission from the professor teaching this course.\n",
    "description": "",
    "tags": null,
    "title": "CIS 115 Syllabus - Spring 2023",
    "uri": "/00-introduction/06-cis115-syllabus/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "What happens when our computers get smarter than we are? | Nick Bostrom",
    "uri": "/iii-topics/18-ai/13-comp-smarter/"
  },
  {
    "content": " https://line-mode.cern.ch/\n",
    "description": "",
    "tags": null,
    "title": "Line Mode Browser 2013",
    "uri": "/ii-internet/11-internethistory/13-line-mode/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "10/GUI Multi-touch Concept Video",
    "uri": "/i-concepts/10-hci/12-multi-touch-concept/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nPython Lists Lists in Python allow us to store multiple elements in a single variable, with each element identified by a unique index within the list.\nLists can be created using square brackets []:\nlist_a = [] list_b = [5, 3, 7] Adding and Accessing List Items New elements can be added to a list using the append() method:\nlist_a = [] list_a.append(4) Items in a list can be accessed and updated using square brackets:\nlist_b = [5, 3, 7] list_b[2] = list_b[0] + list_b[1] Loops with Lists Lists can be iterated using both for loops and while loops:\nlist_b = [5, 3, 7] for i in list_b: print(i) j = 0 while j \u003c len(list_b) print(list_b[j]) j = j + 1 Lists should not be changed while iterating using a for loop.\nFunctions with Lists When calling a function that accepts a list as a parameter, the argument is passed using call by reference instead of call by value. The original list can be modified by the function, but it cannot be replaced with a new list unless the reference to that new list is returned from the function.\nStrings as Lists Strings can be iterated just like a list, and we can use square brackets to access individual characters in a string. However, lists are still passed as call by value when provided as an argument to a function.\nSlicing We can create a slice of a list by specifying a start, end and step value separated by colons. The values may be omitted, and may also be negative.\nlist_b = [5, 3, 7] print(list_b[-1]) print(list_b[0:1]) print(list_b[0:2:2]) print(list_b[::-1]) ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/13-lists/07-summary/"
  },
  {
    "content": "Lab 7 Conditionals ",
    "description": "",
    "tags": null,
    "title": "Conditionals",
    "uri": "/x-cis115-labs/7-conditionals/"
  },
  {
    "content": "In this lab, we covered several major important topics. Let’s quickly review them.\nBooleans in Pseudocode true false BOOLEAN() procedure to convert values 0 is false, and any other number is true Pseudocode Boolean Operators AND OR NOT Pseudocode Boolean Comparators = equal != not equal \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to Booleans in Python True False bool() procedure to convert values If the input is the value False, the value 0, the value None, or anything with 0 length, including the empty string, it will return False. Otherwise, for all other values it will return True. Python Boolean Operators and or not Python Boolean Comparators == equal != not equal \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to Comparators and Strings Strings are compared using lexicographic order\nBoolean Order of Operations Math operators (following their order of operations) Boolean comparators not and or ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/6-booleans/07-summary/"
  },
  {
    "content": "In this lab, we covered several major important topics. Let’s quickly review them.\nPseudocode Conditional Statements if statement IF(\u003cboolean expression\u003e) { \u003cblock of statements\u003e } if-else statement IF(\u003cboolean expression\u003e) { \u003cblock of statements 1\u003e } ELSE { \u003cblock of statements 2\u003e } Python Conditional Statements if statement if \u003cboolean expression\u003e: \u003cblock of statements\u003e if-else statement if \u003cboolean expression\u003e: \u003cblock of statements 1\u003e else: \u003cblock of statements 2\u003e Testing Branch Coverage - all possible branches are executed at least once Path Coverage - all possible paths through branches are executed at least once Edge Cases - values that are near the point where Boolean expressions go from false to true ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/7-conditionals/07-summary/"
  },
  {
    "content": " Resources Slides Python functions are also capable of returning a value, just like we’ve seen in pseudocode. In Python, we use the return keyword, instead of a RETURN() statement, but the concept is the same.\nLet’s look at a quick example of a full Python program that includes a function that returns a value:\ndef square_sum(one, two): one = one * one two = two * two total = one + two return total def main(): text_one = input(\"Enter the first number: \") one = int(text_one) text_two = input(\"Enter the second number: \") two = int(text_two) total = square_sum(one, two) print(\"The sum of squares of {} and {} is {}\".format(one, two, total)) main() To truly understand how this program works, let’s use Python Tutor to explore it step by step. Like before, copy the code into the tutor.py file in the python folder on Codio, or click this Python Tutor link.\nAt the start, our Python Tutor trace will look like this:\nThe first few steps are pretty straightforward, since Python will simply move through the code and record all of the functions it finds. Once we reach the call to the main() function at the bottom, we’ll be at this state:\nSo, we’ll enter the main() function and start executing the code it contains. The first line is an input() expression, so Python will prompt the user for input. In Python Tutor, this will open a box at the bottom where we can enter the input, as shown below:\nLet’s assume that the user would enter 2 for this input. So, we can type that into the box and press ENTER or click submit. Python tutor will refresh the page to accept the input, and then we’ll be at this setup:\nNext, we’ll convert the string value \"2\" that is currently stored in the text_one variable to an integer using the int() function and store it in the variable one. On the next line, it will ask for input once again:\nIn this case, we’ll assume the user is inputting 3, and then we’ll store it and convert it to an integer stored in the variable two:\nAt this point, we’re ready to call the square_sum() function. So, Python Tutor will find the arguments for the function call and prepare to store them in the parameter variables of the function. When we click next, we’ll see this setup in our window:\nRecall that Python Tutor will create a new frame for the square_sum() function in the frames area and store the variables from that function there. This will become important later when we reach the end of the function. Inside of the square_sum() function, we just perform a few mathematical operations, culminating with the total variable storing the sum of the squares of the two arguments, as shown here:\nAt this point, we’ve reached the return statement at the end of the square_sum() function. When we click next on Python Tutor, we’ll see something new appear:\nWhen Python reaches the end of a function, it will record the return value in the function’s frame before leaving the function. This value is what is given back to the main() function. So, when we click next again, we’ll see this state:\nWe’re back in the main() function, and now we can see that the new total variable stores the value $13$, which was the returned value from the square_sum() function. So, on this last line, we’ll see that the program will create an output statement using a template string and the string format() method, and it will display output to the user:\nWhat’s also interesting to note here is the return value of the main() function. Since we didn’t include a return statement at the end of the function, the return value is set to a special value called None in Python. We’ll learn about what that value actually represents in a future course.\nThe entire process is shown in the animation below:\nThis review of how a function returns data should be very helpful as we continue to build more complex programs. Remember - we can always paste any Python code into a tool like Python Tutor to run through it step-by-step and see what it really does.\n",
    "description": "",
    "tags": null,
    "title": "Return in Functions",
    "uri": "/x-cis115-labs/5-input-strings/07-return-functions/"
  },
  {
    "content": " In this lab, we’re going to take what we’ve learned in pseudocode and see how it transfers to a real programming language, Python. We’ve chosen Python because it is very easy to learn, easy to use, and it is used in many different places, from scientific computing and data analysis to web servers and even artificial intelligence. It is a very useful language to learn, and it makes a great first programming language.\nWe’ve already built a pretty effective “mental model” of a computer by working in pseudocode. So, as we work through this lab, we’ll need to constantly pay attention to how a real computer works, and make sure that our “mental model” is accurate. If not, we’ll have to adapt our understanding of a computer to match the real world. This process of adaptation and accommodation is an important part of learning to program - we have to have a good understanding of what a computer actually does when it runs our code, or else we won’t be able to write code that will do what we want it to do.\nAs we learn to write code in a real programming language, it helps to refer to the actual documentation from time to time. So, we recommend bookmarking the official Python Documentation as a great place to start. Throughout this course, we may also include links to additional resources, and those are also worth bookmarking. One of the best parts about programming is that nearly all of the documentation is online and easily accessible, and learning how to quickly search for a particular solution or reference is just as useful as knowing how to do it from memory. In fact, most programmers really only know the basics of the language and a few handy tricks, and the rest of it is just reading documentation and learning when to use it. So, don’t worry about remembering it all right from the start - instead, learn to read the documentation and use the tools that are available, and focus on understanding the basics of the language’s syntax and rules.\n",
    "description": "",
    "tags": null,
    "title": "Python Introduction",
    "uri": "/x-cis115-labs/2-print-variables/07-python-intro/"
  },
  {
    "content": "Pseudocode Procedures A procedure in pseudocode is a piece of code that is given a name, which can then be run by calling it elsewhere in the program.\nTo create a procedure, we use the following structure:\nPROCEDURE procedure_name(parameter1, parameter2) { \u003cblock of statements\u003e } Procedure names follow the same rules as variable names. Procedures may require 0 or more parameters, placed in parentheses after the procedure name. Multiple parameters are separated by commas. When called, a procedure will run the lines of code placed between the curly braces {}. These lines of code are indented to make it clear that they are part of the procedure. To call a procedure, we use the following structure:\nprocedure_name(argument1, argument2) A procedure call is the procedure name, followed by parentheses (). Inside of the parentheses, a matching argument must be included for each parameter required by the procedure. Multiple arguments are separated by commas. Each argument may be an expression that evaluates to a value. The values of each argument are copied into the procedure. When the procedure ends, the original arguments are unchanged. Python Functions A function in Python is a piece of code that is given a name, which can then be run by calling it elsewhere in the program.\nTo create a function, we use the following structure:\ndef function_name(parameter1, parameter2): \u003cblock of statements\u003e Function names follow the same rules as variable names. Functions may require 0 or more parameters, placed in parentheses after the function name. Multiple parameters are separated by commas. When called, a function will run the lines of code indented beneath the function definition. To call a function, we use the following structure:\nfunction_name(argument1, argument2) A function call is the function name, followed by parentheses (). Inside of the parentheses, a matching argument must be included for each parameter required by the function. Multiple arguments are separated by commas. Each argument may be an expression that evaluates to a value. The values of each argument are copied into the function. When the function ends, the original arguments are unchanged. Summary As we’ve seen, procedures in pseudocode and functions in Python are very similar. They allow us to write pieces of code that we can use repeatedly throughout our programs. This makes our programs more organized and modular, and will make it much easier to write more complex programs as we continue to develop our skills.s\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/3-functions/07-summary/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Machine Learning \u0026 Artificial Intelligence: Crash Course Computer Science #34",
    "uri": "/iii-topics/18-ai/14-ml-ai-crash-course/"
  },
  {
    "content": " https://en.wikipedia.org/wiki/Dot-com_bubble\n",
    "description": "",
    "tags": null,
    "title": "Dot-com Bubble on Wikipedia",
    "uri": "/ii-internet/11-internethistory/14-dot-com-bubble/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Google Glass How-to: Getting Started",
    "uri": "/i-concepts/10-hci/13-google-glass/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Machine Learning: Living in the Age of AI | A WIRED Film",
    "uri": "/iii-topics/18-ai/15-ml-wired/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Jacob Tries the Oculus Rift (Warning - Strong Language)",
    "uri": "/i-concepts/10-hci/14-oculus-rift/"
  },
  {
    "content": " Resources K-State Honor \u0026 Integrity System Video Script “On my honor, as a student, I have neither given nor received unauthorized aid on this academic work.” - K-State Honor Pledge\nPlagiarism is a very serious concern in this course, and something that we do not take lightly. Computer programs and code are especially easy targets for plagiarism due to how easy it is to copy and manipulate code in such a way that it is unrecognizable as the original source but still performs correctly.\nAt its core, plagiarism is taking someone else’s work and passing it off as your own without giving appropriate credit to the original source. As a student at K-State, you are bound by the K-State Honor Code not to accept any unauthorized aid, and this includes plagiarized code.\nWhen it comes to plagiarism in computer code, there is a fine line between using resources appropriately and copying code. In this program, you should strive to avoid plagiarism issues by doing the following:\nDo not search for or use any complete solutions to projects in this course found online or from fellow students. Small portions of code may be used or adapted from an online source with proper citation. To cite a piece of code, include a code comment section above it that contains the original source URL and a description of why it was used. In general, copying or adapting small pieces of code to perform auxiliary functions in the assignment is permitted. Copying or adapting code that is the general goal of the assignment should be avoided. For example, if the assignment is to create a bubble sort algorithm, you should write the algorithm from scratch yourself since that is the goal of the assignment. If the assignment is to create a program for displaying data that you feel should be sorted, you may choose to adapt an existing sorting algorithm for your needs (or use one from a library).\nIf you aren’t sure about whether it is OK to use an online resource or piece of code in this course, please contact the instructors using the course discussion forums or help email address. You will not get in trouble for asking, and it will help you determine what the best course of action is. Plagiarism can really only occur when you submit the assignment for grading, so you are welcome to ask for clarification or a judgement on whether a particular usage is acceptable at any time before you submit the assignment.\nCodio has features that will compare your submissions against those of your fellow students. Any submissions with a high degree of similarity may be subjected to additional scrutiny by the instructors to determine if plagiarism has occurred.\nIn this course, any violation of the K-State Honor Code will result in a 0 on that assignment and a report made to the K-State Honor Council. A second violation will result in an XF in this course, as well as any additional sanctions imposed by the K-State Honor Council.\nFor more information on the K-State Honor \u0026 Integrity system, please visit their website, which is linked in the resources section below this video.\n",
    "description": "",
    "tags": null,
    "title": "Plagiarism Policy",
    "uri": "/00-introduction/07-plagiarism/"
  },
  {
    "content": "Lab 8 Web Programming For lab 8, simply refer to Homework 3 - Web Programming. We typically do the first part of that homework together in class for this lab assignment.\n",
    "description": "",
    "tags": null,
    "title": "Web Programming",
    "uri": "/x-cis115-labs/8-web-programming/"
  },
  {
    "content": " Resources Slides Finally, let’s look at how we can rewrite some of our previous Python programs by combining expressions into more complex statements. Just like we saw in pseudocode, Python also allows us to perform multiple actions on a single line of code, provided they can all be combined in some way to create a single statement.\nLet’s consider the example on the previous page, shown here:\ndef square_sum(one, two): one = one * one two = two * two total = one + two return total def main(): text_one = input(\"Enter the first number: \") one = int(text_one) text_two = input(\"Enter the second number: \") two = int(text_two) total = square_sum(one, two) print(\"The sum of squares of {} and {} is {}\".format(one, two, total)) main() There are many ways we can write this program to perform the same work. For example, the square_sum() function can actually be reduced to a single line of code as seen below:\ndef square_sum(one, two): return (one * one) + (two * two) We can perform multiple mathematical operations in a single expression, and as long as we either use parentheses or pay attention to the order of operations, we’ll get the expected answer. We don’t have to store the intermediate values in variables, since Python will do that for us when it evaluates the expression.\nLikewise, in the main() function, we can put the input() expression inside of the int() function, allowing us to read input as a string and convert it to an integer in a single line:\ndef main(): one = int(input(\"Enter the first number: \")) two = int(input(\"Enter the second number: \")) total = square_sum(one, two) print(\"The sum of squares of {} and {} is {}\".format(one, two, total)) Finally, we can also move the function call to square_sum() directly into the format() method in the print() statement. When that line is executed, Python will know it has to call the square_sum() method first and get the returned value before it can print the output.\ndef main(): one = int(input(\"Enter the first number: \")) two = int(input(\"Enter the second number: \")) print(\"The sum of squares of {} and {} is {}\".format(one, two, square_sum(one, two))) Of course, if we really wanted to, we could remove the square_sum() function entirely, and just compute the value directly in main(). However, for this example, we will leave it as a separate function. So, our new program contains this code:\ndef square_sum(one, two): return (one * one) + (two * two) def main(): one = int(input(\"Enter the first number: \")) two = int(input(\"Enter the second number: \")) total = square_sum(one, two) print(\"The sum of squares of {} and {} is {}\".format(one, two, total)) main() Functionally, this code will create the exact same output as the previous code, but it will do so using fewer variables and statements. Each statement is simply more complex, consisting of multiple expressions.\nAs we discussed in pseudocode, each of these approaches to writing code is valid. They simply follow different coding styles, each one with particular benefits and disadvantages to consider. Sometimes it is better to have more variables and shorter expressions, especially if the overall operation involves many steps and is difficult to follow. Other times it is better to combine a few lines of code together as a single statement to make it very clear what the overall operation is trying to accomplish.\nOnce again, the best advice is to simply write code in a way that it is readable to you and to anyone else who has to read it. As long as it is clear and performs correctly, it is a good style to follow. As we further develop our skills and gain experience, our style will continue to change over time.\n",
    "description": "",
    "tags": null,
    "title": "Complex Python",
    "uri": "/x-cis115-labs/5-input-strings/08-complex-python/"
  },
  {
    "content": " Resources Slides First, let’s start with the basics of writing Python code in a file and running those files. This is the first major step toward actually writing a real program, but it can definitely be difficult the first time without prior experience to rely on. So, let’s go through it step by step and make sure we know how to run our programs in Python.\nAt this point, we should already have Python installed on our system. For students using Codio, this is taken care of already. For students using their own computers, refer to an earlier lab to find instructions for installing Python on your system, or contact the instructors for assistance.\nTo make sure that Python is installed and working, we’ll need to open a terminal in our operating system. In Codio, this can be found by clicking the Tools menu at the top, and then choosing Terminal. More information can be found in the Codio Documentation. There may also already be one open for you if you are reading this content from within Codio.\nIf you are working on your own computer, you’ll need to open a terminal on your operating system. This should have been covered in the previous lab when you installed Python. On Windows, look for Windows Terminal or Windows PowerShell (not the old Command Prompt, which requires different commands). On Mac or Linux, look for an application called Terminal. Throughout this course, we’ll call these windows the terminal, even though they may have slightly different names in each operating system.\nOnce we have the terminal open, we should see something like one of these examples:\nAt this point, we should see a place with a blinking cursor, where we can type our commands. This is called the command prompt in the terminal. The first thing we can do is check to make sure Python is properly installed, and we can also confirm that it is the correct version. To do this, we’ll enter the following command and press enter to execute it:\npython3 --version Hopefully, that command should produce some output that looks like this:\nHere, we see that the currently installed Python version is 3.6.9. As long as your Python version number begins with a 3, you have correctly installed Python and are able to run it from the terminal. So, we can continue to the next part of this lab.\nIf you aren’t able to run Python or aren’t sure that you have the correct version, contact the instructor for assistance!\nnote-1 Notice that we have to use the command python3, including the version number, instead of the simpler python command here. This is because some systems may also have Python version 2, an outdated version of Python, installed alongside version 3. In that case, the simple python command will be Python version 2, while python3 will be Python version 3. Unfortunately, most programs written in Python 3 will not run properly in Python 2, so it is important for us to make sure we are using the correct Python version when running our programs.\nThankfully, the command python3 should always be Python version 3, and using that command is a good habit to learn. However, depending on how Python is installed on Windows, it might only work via the python command, which can make it confusing. So, throughout this course, we will use the command python3 to run Python programs, but you may have to adapt to your particular situation.\nNavigating in the Terminal When we open a terminal, it will usually start in our user’s home folder. This may mean different locations for different operating systems. For example, if our current user’s name is \u003cusername\u003e, the terminal will usually start in this location for each operating system:\nWindows: C:\\Users\\\u003cusername\u003e Linux: /home/\u003cusername\u003e Mac: /Users/\u003cusername\u003e Codio: /home/codio/workspace The directory that is open in the terminal is known as the working directory. We can use the pwd command to determine what our current directory is:\nIn this example, we are looking at the Codio terminal, so our working directory is /home/codio/workspace.\nNext, we can see the files and directories contained in that directory using the ls command. Here’s the output of running this command in Codio:\nIn the output, we can see that there is a file named README.txt and a directory named python. In Codio, we’ll place all of our files in the python directory, so we can open that using the cd python command:\nNotice how the python directory is now included in the command prompt in the terminal. Most terminals will show the working directory in the command prompt in some way.\nThat’s the basics of navigating in the terminal, but there is much more to learn. If you’d like to know more, consider checking out some of the resources linked below!\nResources Basic Linux Navigation \u0026 File Management from DigitalOcean Beginner’s Guide to the Bash Terminal by Joe Collins on YouTube note-2 Most of the content in this course will focus on using the commands that are present in the Linux terminal, since they are the most widely-used commands across all platforms. In general, these commands should work well on both Windows and Mac, with a few caveats:\nOn Windows, there is an older Command Prompt tool that does not support the newer Linux commands. Therefore, we won’t be using it. Instead, we only want to use Windows PowerShell, which supports most of the basic Linux commands via aliases to similar PowerShell commands. We can also install the Windows Terminal application for a more modern interface. Windows users may also choose to install the Windows Subsystem for Linux (WSL) to run Linux (such as Ubuntu) directly within Windows. Many developers choose to pursue this option, as it provides a clean and easy to use development environment that is compatible with the Linux operating system. The Mac operating system includes a terminal that uses either ZSH (since OS X 10.15) or Bash (OS X 10.14 and below). This terminal is very similar to the Linux terminal when it comes to navigating the file system and executing programs, which is sufficient for this course. Fully learning how to use these tools is outside of the scope of this class, but we need to know enough to navigate the filesystem and execute the python3 command. If you need assistance getting started with this step, your best bet is to contact the instructors. Each student’s computer is a bit different, so it is difficult to cover all possible cases here.\n",
    "description": "",
    "tags": null,
    "title": "Working in the Terminal",
    "uri": "/x-cis115-labs/2-print-variables/08-terminal/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "AlphaGo - The Movie | Full award-winning documentary",
    "uri": "/iii-topics/18-ai/16-alpha-go/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "Dasher: Information Efficient Text Entry (Demo starts at 6:18) ",
    "uri": "/i-concepts/10-hci/15-dasher/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "DeepMind StarCraft II Demonstration",
    "uri": "/iii-topics/18-ai/17-deepmind-starcraft/"
  },
  {
    "content": " Another type of question included in Codio is a Parsons Problem, where you drag-and-drop snippets of code to build the solution to a problem. These problems are great ways to practice the logic of programming without having to remember how to type each line of code yourself. You can think of them like a puzzle that you have to solve.\nOne important thing to remember about Parsons Problems is that the correct solution depends not only on the order of the code snippets, but how they are indented as well. In programming languages such as Python, the way the code is indented has great meaning, as we’ll learn later in this course.\nIn addition, sometimes there may be more than one valid solution to a problem. There are times when the exact ordering of the code snippets is not as important as making sure some operations happen before others. So, you may find that there are multiple ways to get a correct answer to a problem.\nFinally, many times a Parsons Problem will contain more code snippets than are actually needed to solve the problem. So, part of your work will be to figure out which pieces you need to solve the puzzle, and which pieces can be ignored. So, you may have to think carefully and not just use everything that is given to you by default.\nJust like any other question in Codio, make sure you read the instructions carefully. We may give you hints about how to solve the problem, or whether there are extra pieces of code that can be ignored. You may also be given just one try to get it correct, or you may have multiple tries. Let’s check out an example on this page. Instead of code, we’ll treat this like a numbered list, with some numbers having multiple items beneath them. Place the items in the correct order, and leave out the ones that say “Unused” since they aren’t part of the list. When you are done, your list should look like this:\n1. Item 1 2. Item 2 3. Item 3 3.1. Item 3, Subitem 1 3.2. Item 3, Subitem 2 4. Item 4 You’ll have unlimited attempts to get this question correct!\n",
    "description": "",
    "tags": null,
    "title": "Codio Parsons",
    "uri": "/00-introduction/08-codio-parsons/"
  },
  {
    "content": "Lab 9 Nested Conditionals ",
    "description": "",
    "tags": null,
    "title": "Nested Conditionals",
    "uri": "/x-cis115-labs/9-nested-conditionals/"
  },
  {
    "content": "In this lab, we covered several major important topics. Let’s quickly review them.\nPseudocode Input INPUT() will read input from the user and return what was typed as a string value. INPUT() is terminated by the user pressing ENTER, so next output starts on a new line. Pseudocode String Operators + Concatenation (join strings together). May only be applied to two strings. Returning Data from Procedures RETURN(expression) will return the value of expression to where the procedure was called from. Procedure calls can be used in assignment statements to store return values, or as part of other expressions. Python input input(expression) will display the expression to the user as a prompt, then return what was typed by the user as a string value. input(expression) is terminated by the user pressing ENTER, so next output starts on a new line. Python String Operators + Concatenation (join strings together). May only be applied to two strings. string.format(value1, value2) performs string formatting. The string portion is any valid template string, which contains curly braces {} as placeholders. Each placeholder will be replaced by the matching argument value1, value2, etc. from the format() method. Returning Data from Functions return expression will return the value of expression to where the function was called from. Function calls can be used in assignment statements to store return values, or as part of other expressions. Complex statements Expressions can be combined in many ways within a statement. Expressions can be used as arguments to procedures, and more!\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/5-input-strings/09-summary/"
  },
  {
    "content": " Resources Slides The first statement that we’ll cover in the Python programming language is the print(expression) statement. This statement is used to display output to the user via the terminal. So, when Python runs this statement, it will evaluate the expression to a single value, and then print that value to the terminal.\nFor example, the simplest Python code would be a simple Hello World program, where we use the print(expression) statement to display the text \"Hello World\" to the user:\nprint(\"Hello World\") When we run that program in Python, we’ll see the following output:\nHello World Just like in pseudocode, strings in Python are surrounded by double-quotes \". For now, we’re just going to work with string values, but in a later lab we’ll introduce numerical values and discuss how to use them as well.\nLet’s go through the full process of writing and running that program in Python!\nWriting a Python Program The first step to create a program in Python is to create a text file to store the code. This file should have the file extension .py to indicate that it is a Python program. So, we’ll need to create that file either on our computers or in Codio or another tool if we are using one. For example, in Codio we can create the file in the python folder by right-clicking on it and selecting the New File option. We’ll name the file hello.py:\nOnce we’ve created that file, we can then open it by clicking on it. In Codio and in other online tools, it will open in the built-in editor. On a computer, we’ll need to open it in a text editor specifically designed for programming. We recommend either Atom or Visual Studio Code, which are available on all platforms. Tools like the built-in Notepad tool on Windows, or a word processor like Word or Pages do not work for this task.\nIn that file, we’ll simply place the code shown above, like this:\nThat’s all there is to it!\nRunning a Python Program Once we’ve written the code, we can open the Terminal and navigate to where the code is stored in order to run the program. On Codio, we’ll just use the cd python command to enter the python directory. On a computer, we’ll need to navigate the file system to find the location where we placed our code. We highly recommend creating a folder directly within the home directory and placing all of our code there - that will make it easy to find!\nOnce we are in the correct directory, we can use the ls command to see the contents of that directory. If we see our hello.py file, we are in the correct location:\nIf we don’t see our file, we should make sure we’ve saved it and that our current working directory is the same location as where the file is stored.\nFinally, we can execute the file in Python using the python3 command, followed by the name of the file:\npython3 hello.py If everything works correctly, we should see output similar to this:\nThere we go! We’ve just run our first program in Python! That’s a great first step to take.\nOf course, there are lots of ways that this could go wrong. So, if you run into any issues getting this to work, please take the time to contact an instructor and ask for assistance. This process can be daunting the first time, since there are so many things to learn and so many intricacies we simply don’t have time to cover up front. Don’t be afraid to ask for help!\n",
    "description": "",
    "tags": null,
    "title": "Print Statement",
    "uri": "/x-cis115-labs/2-print-variables/09-print-statement/"
  },
  {
    "content": " ",
    "description": "",
    "tags": null,
    "title": "AI vs. AI. Two chatbots talking to each other",
    "uri": "/iii-topics/18-ai/18-chatbot-vs-chatbot/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 6 - Pattern Recognition\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 6 - Pattern Recognition",
    "uri": "/iii-topics/18-ai/19-9algs-ch6/"
  },
  {
    "content": " Now that you’ve seen a few pages in Codio, let’s take a minute to discuss some of the features of the Codio user interface. Of course, Codio has some amazing documentation, so feel free to check that out as you work with Codio.\nFirst, let’s look at the menu items at the top of the page. There are several available to you that are worth mentioning. For starters, you can click the Codio Icon at any time to go directly to your Codio dashboard. The first item on the Codio menu will take you directly here as well. There you can see all of the projects attached to your account, and create new projects at any time. However, you won’t see the projects attached to the course here, since they must be accessed directly through Canvas.\nUnder the Codio menu, you can also find options to manage your preferences. Here you can adjust things such as the editor settings and theme. Feel free to adjust the settings to match your personal preferences.\nThe Project menu allows you to work with the currently loaded Codio project. Generally you won’t need to access many of these items unless your project stops working. However, they are provided for your use in case you need them.\nThe File menu contains options for manipulating the file tree, such as creating new files, renaming them, saving them, and even downloading and uploading files. As you work on larger projects, you’ll be using many of these options to manage the files within your project.\nNext, the Edit menu gives you access to the Undo and Redo action. Since Codio is a web-based platform, you’ll need to get used to using keyboard shortcuts to handle the Copy and Paste actions. For most systems, you can use CTRL+C for copy and CTRL+V for paste. On Mac, use CMD+C and CMD+V instead.\nThe Find menu contains entries for searching documents and performing a find-and-replace operation. Most of those actions should be pretty self-explanatory.\nThe View menu allows you to customize your view in Codio. Here we’ll find options for managing panels, open tabs, editor settings, and more. Feel free to make use of these options to arrange your Codio view as you prefer. Also, at the bottom of this menu is a Play Guide option, which is very helpful if you accidentally close the guide and need to reopen it.\nUnder the Tools menu, you’ll find an option for accessing the Terminal in your project. The Terminal gives you console access to the box that your project is running on, and allows you to install software and configure it as needed. As you work through the content in this program, we’ll slowly introduce the Terminal and some of the tasks it can perform. In addition, the Tools menu has options for working with SSH and Git, two more tools which will be introduced in later modules. Lastly, it also has an entry for the Command Bar, which is a quick shortcut to the full list of commands that can be performed in Codio. Feel free to check it out if you are looking for a particular command or action.\nThe Education menu is very important, though it only has a single entry. The Mark as Completed option allows you to indicate that you have completed this Codio project or tutorial. Once you select that option, your work will automatically be graded and your grade will be sent to Canvas. From there, you can access the next project or module in the course.\nFinally, the Help menu gives you access to many of the support features in Codio. If you get stuck, you may want to review some of the help options available here. Of course, you can always post a message in the course help forum or email for assistance!\nThere are also a few other items in the interface you should be aware of. First, in the File Tree, there is a Play icon that can also be used to open the guide for the current project.\nIn the guide, there are a couple of options available by clicking the gear icon in the upper-right of the page. First, there is an option to Restore Current Files. This option will restore the contents of any currently open files back to the default contents from when you first opened the project. In addition, this menu also contains another way to mark the current project as completed.\nThat covers most of the major features of the Codio interface that we’ll be using in this course. If you have any questions about how to use Codio, feel free to contact the course instructors for assistance.\n",
    "description": "",
    "tags": null,
    "title": "Codio Interface",
    "uri": "/00-introduction/09-codio-interface/"
  },
  {
    "content": " Just a quick course update!\n",
    "description": "",
    "tags": null,
    "title": "Announcement",
    "uri": "/00-introduction/10-announce/"
  },
  {
    "content": "Lab 10 Pseudocode Loops ",
    "description": "",
    "tags": null,
    "title": "Pseudocode Loops",
    "uri": "/x-cis115-labs/10-pseudocode-loops/"
  },
  {
    "content": " Resources Slides The print(expression) statement in Python works in much the same way as the DISPLAY(expression) statement in pseudocode, but with one major difference. In pseudocode, the DISPLAY(expression) statement will print the value from the expression to the user, but it won’t add anything like a space or newline to the end. In Python, however, the print(expression) statement will add a newline to the end of the output by default. This means that multiple print(expression) statements will print on multiple lines. Let’s look at some examples!\nThroughout this course, we’ll show many different code examples and their output here in the lab. To test them out, feel free to copy the code examples to a Python file and run it yourself. You can even tweak them to do something new and see how Python interprets different pieces of code. In the end, the best way to learn programming is to explore, and running these examples on your own is a great way to get started!\nMultiple Lines In Python, we can print multiple lines of output simply by using multiple print(expression) statements:\nprint(\"a\") print(\"b\") print(\"c\") print(\"d\") will result in this output:\na b c d We can also include a newline symbol \\n in a print(expression) statement in Python. This will add a newline to the output, and then the print(expression) statement will add an additional newline at the end of the value that is printed:\nprint(\"one\\ntwo\") print(\"three\\nfour\") will produce this output:\none two three four Printing On the Same Line What if we want to display multiple print(expression) statements on the same line? To do that, we must add an additional option to the print(expression) statement - the end option.\nFor example, the following code will produce output all on the same line:\nprint(\"Hello \", end=\"\") print(\"World!\") In this example, we set end to be an empty string \"\". When we run this program, we’ll get the following output:\nHello World! In fact, in Python, the print(expression) statement is an example of a function in Python. Functions in Python are like procedures in pseudocode - when we call them, we write the name of the function, followed by a set of parentheses and then arguments separated by commas within the parentheses. So, in actuality, the expression in the print(expression) statement is just the first argument when we call the print function.\nTherefore, the end option that we showed above is just a second argument that is optional - it simply let’s us choose what to put at the end of the output. By default, the end parameter is set to the newline symbol \\n, so if we don’t provide an argument for end it will just add a newline at the end of the value.\nWe can set the value of end to be any string. If we want to include a space at the end of the output, we can add end=\" \" to the print function call.\nIn this course, we won’t spend much time talking about optional parameters and default values in Python functions, but it is important to understand that statements like print are actually just Python functions behind the scenes!\n",
    "description": "",
    "tags": null,
    "title": "Using Print",
    "uri": "/x-cis115-labs/2-print-variables/10-using-print/"
  },
  {
    "content": "Chapter 1 What is Computing Science? In this module, we will dissect what computing science really is. To do this we will step back in time to determine what the motivation was for computing machines, the products of those needs, and\n",
    "description": "",
    "tags": null,
    "title": "What is Computing Science?",
    "uri": "/i-concepts/01-what-is-computing-science/"
  },
  {
    "content": " How to Get Help in this Course CC 110 can be an interesting course due to the large amount of material covered and much of the material is brand new to students. Therefore, you are encouraged to seek help whenever you feel you are being overwhelmed or don’t understand a topic. You are not alone! Most students in CC 110 have never studied anything relating to computer science before, so it is new to everyone. The instructors and TAs are always willing to help students with any questions you may have about the class or other issues related to Computing Science. So please, don’t be afraid to ask questions. Get help early and often!\nHere are the 4 recommended ways to get help on CC 110:\nReview the course materials posted on K-State Canvas and the course website Send assignment questions to the CC 110 Help email ( cc110-help@ksuemailprod.onmicrosoft.com) Visit your professor’s office hours, or the office hours for your TA if available Schedule a one-on-one meeting with your professor/TA ",
    "description": "",
    "tags": null,
    "title": "110 Office Hours",
    "uri": "/00-introduction/11-office-hours-110/"
  },
  {
    "content": "Lab 11 Python Loops ",
    "description": "",
    "tags": null,
    "title": "Python Loops",
    "uri": "/x-cis115-labs/11-python-loops/"
  },
  {
    "content": "Lab 12 Nested Loops ",
    "description": "",
    "tags": null,
    "title": "Nested Loops",
    "uri": "/x-cis115-labs/12-nested-loops/"
  },
  {
    "content": " Resources Slides As we learn to write more complex programs in Python, it is important to make sure we can still mentally execute the code we are writing in our “mental model” of a computer before we actually run it on a computer. After all, if we don’t have at least an idea of what the code actually does before we write it, we really haven’t learned much about programming!\nThankfully, when working in a real programming language such as Python, there are many tools to help us visualize how the code works when we run it. This helps us continue to develop our “mental model” of a computer by looking behind the scenes a bit to see what is happening when we run our code.\nOne such tool is Python Tutor, a website that can quickly run short pieces of Python code to help us visualize what each line does and how it works. This tool is also integrated directly into Codio!\nPython Tutor Example Let’s look at an example of how Python Tutor compares to the manual code traces we performed in a previous lab. For this example, we’re going to use the following code:\nx = \"Hello\" y = x print(y, end=\" \") x = \"World\" print(x, end=\", \") print(y) In Codio, we can see the visualization in a tab to the left. It will visualize the content in the tutor.py file in the python directory, so make sure that the contents of the tutor.py file match the example above before continuing.\nOutside of Codio, this visualization can be found by clicking this Python Tutor Link to open Python Tutor on the web.\nStepping Through Code The initial setup for Python Tutor is shown in the image below:\nThis looks similar to the setup we used when performing code tracing with pseudocode. We have an arrow next to our code that is keeping track of the next line to be executed, and we have areas to the side to record variables and outputs. In Python Tutor, the variables are stored in the Frames section. We’ll learn why that is important later in this lab when we start looking at Python functions.\nSo, let’s click the Next \u003e button once to execute the first line of code. After we do that, we should see the following setup in Python Tutor:\nThat line is an assignment statement, so Pyhton Tutor added an entry in the Frames section for the variable x, showing that it now contains the string value \"Hello\". It placed that variable in a frame it is calling the “Global frame,” which simply contains variables that are created outside of a function in Python.\nWhen we click the Next \u003e button again, we should see this:\nOnce again, the line that was just executed is an assignment statement, so Python Tutor will add a new variable entry for y to the list of variables. It will also store the string value \"Hello\". Just like before, notice that the variable y is storing the same value as x, but it is a copy of that value. The variables are not connected in any other way.\nWe can click Next \u003e again to execute the next line of code:\nOnce this line is executed, we’ll see that it prints the value of the variable y to the output. Python Tutor will look up the value of y in the Frames section and print it in the output, but it won’t evaluate the expression in the code like we did when we performed code tracing in pseudocode. It’s a subtle difference, but it is worth noting.\nOnce again, we can click Next \u003e to execute the next assingment statement:\nThis statement will update the value stored in the variable x to be the string value \"World\". After that, we can run the next statement:\nThat statement prints the value of x to the output, followed by a comma , and a space as shown in the end argument provided to the print function. Finally, we can click Next \u003e one more time to execute the last line of code:\nThis will print the value of y to the output. Once the entire program has been executed, we should see the output Hello World, Hello printed to the screen.\nThe full process is shown in the animation below:\nUsing tools like Python Tutor to step through small pieces of code and understand how the computer interprets them is a very helpful way to make sure our “mental model” of a computer accurately reflects what is going on behind the scenes when we run a piece of Python code on a real computer. So, as we continue to show and discuss examples in this course, feel free to use tools such as Python Tutor, as well as just running the code yourself, as a great way to make sure you understand what the code is actually doing.\n",
    "description": "",
    "tags": null,
    "title": "Python Tutor",
    "uri": "/x-cis115-labs/2-print-variables/12-python-tutor/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 1 - Introduction\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 1 - Introduction",
    "uri": "/iii-topics/15-compression-error-checking/06-9algs-intro/"
  },
  {
    "content": "Read Pattern on the Stone, Chapter 7 - Speed: Parallel Computers\n",
    "description": "",
    "tags": null,
    "title": "Pattern on the Stone Reading",
    "uri": "/iii-topics/14-hpc/04-pots-reading/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 5 - Error Correcting Codes\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 5 - Error Correcting Codes",
    "uri": "/iii-topics/15-compression-error-checking/07-9algs-ch5/"
  },
  {
    "content": "Lab 13 Lists ",
    "description": "",
    "tags": null,
    "title": "Lists",
    "uri": "/x-cis115-labs/13-lists/"
  },
  {
    "content": "Pseudocode In this lab, we introduced a simple pseudocode programming language, based on the one used by the AP Computer Science Principles exam. This pseudocode language includes several statements and rules we’ve learned to use in this lab. Let’s quickly review them!\nDisplay Statement The DISPLAY(expression) statement is used to display output to the user.\nIt will evaluate expression to a value, then display it to the screen. It does not add any additional spaces or newlines after the value is displayed We can display spaces using DISPLAY(\" \"), and we can use the newline symbol to go to the next line DISPLAY(\"\\n\") Assignment Statement The assignment statement, like a \u003c- expression is used to create variables and store values in the variables.\nThe variable must be on the left side, and the right side must be an expression that evaluates to a single value. If the variable does not exist, it is created. Otherwise, the current value of the variable is replaced by the new value. Variable names must begin with a letter, and may only contain letters, numbers, and underscores. Summary This pseudocode language may seem very simple, but we’ve already learned a great deal about how programming works and how a computer interprets a program’s code, just by practicing with this very simple language. In the next lab, we’ll see how these concepts directly relate to a real programming language, Python. For now, feel free to keep practicing by writing programs and pseudocode and running them on your “mental model” of a computer. It is a very important skill to develop!\nPython We also introduced some basic statements and structures in the Python programming language. Let’s quickly review them!\nPrint Statement The print(expression) statement is used to print output on the terminal.\nIt will evaluate expression to a value, then display it to the screen. By default, it will add a newline to the end of the output. We can change that using the end parameter, such as print(expression, end=\"\") to remove the newline. Assignment Statement The assignment statement, like a = expression is used to create variables and store values in the variables.\nThe variable must be on the left side, and the right side must be an expression that evaluates to a single value. If the variable does not exist, it is created. Otherwise, the current value of the variable is replaced by the new value. Variable names must begin with a letter or underscore, and may only contain letters, numbers, and underscores. Variable names beginning with an underscore have a special meaning, so we won’t use them right now. Summary As we’ve seen, the Python language is very similar to the pseudocode language we’ve already learned about. Hopefully the practice we have in reading and writing pseudocode using our “mental model” of a computer will help make it even easier to read and write Python code that is meant to be run on an actual computer.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/x-cis115-labs/2-print-variables/13-summary/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 4 - Public Key Cryptography\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 4 - Public Key Cryptography",
    "uri": "/iii-topics/16-cryptography/11-9algs-ch4/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 7 - Data Compression\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 7 - Data Compression",
    "uri": "/iii-topics/15-compression-error-checking/08-9algs-ch7/"
  },
  {
    "content": "Lab 14 Dictionaries ",
    "description": "",
    "tags": null,
    "title": "Dictionaries",
    "uri": "/x-cis115-labs/14-dictionaries/"
  },
  {
    "content": "Nine Algorithms that Changed the Future Ch 9 - Digital Signatures\n",
    "description": "",
    "tags": null,
    "title": "Nine Algorithms that Changed the Future Ch 9 - Digital Signatures",
    "uri": "/iii-topics/16-cryptography/12-9algs-ch9/"
  },
  {
    "content": "Chapter 2 Early Computing Machines ",
    "description": "",
    "tags": null,
    "title": "Early Computing Machines",
    "uri": "/i-concepts/02-early-computing-machines/"
  },
  {
    "content": "Chapter 3 Bits and Boolean Algebra ",
    "description": "",
    "tags": null,
    "title": "Bits and Boolean Algebra",
    "uri": "/i-concepts/03-bits-and-boolean-algebra/"
  },
  {
    "content": "Chapter 4 Programming ",
    "description": "",
    "tags": null,
    "title": "Programming",
    "uri": "/i-concepts/04-programming/"
  },
  {
    "content": "Chapter 5 Universal Computers ",
    "description": "",
    "tags": null,
    "title": "Universal Computers",
    "uri": "/i-concepts/05-universal-computers/"
  },
  {
    "content": "Chapter 6 Algorithms ",
    "description": "",
    "tags": null,
    "title": "Algorithms",
    "uri": "/i-concepts/06-algorithms/"
  },
  {
    "content": "Chapter 7 Encoding ",
    "description": "",
    "tags": null,
    "title": "Encoding",
    "uri": "/i-concepts/07-encoding/"
  },
  {
    "content": "Chapter 8 Computer Architecture ",
    "description": "",
    "tags": null,
    "title": "Computer Architecture",
    "uri": "/i-concepts/08-architecture/"
  },
  {
    "content": "Chapter 9 Software Engineering ",
    "description": "",
    "tags": null,
    "title": "Software Engineering",
    "uri": "/i-concepts/09-software-engineering/"
  },
  {
    "content": "Chapter Y Weekly Updates Information for Current Students!\n",
    "description": "",
    "tags": null,
    "title": "Weekly Updates",
    "uri": "/y-weekly-updates/"
  },
  {
    "content": "Chapter 10 Human-Computer Interaction ",
    "description": "",
    "tags": null,
    "title": "Human-Computer Interaction",
    "uri": "/i-concepts/10-hci/"
  },
  {
    "content": "Chapter 11 The History of the Internet ",
    "description": "",
    "tags": null,
    "title": "The History of the Internet",
    "uri": "/ii-internet/11-internethistory/"
  },
  {
    "content": "Chapter Z AP Alignment This section contains details and evidence for how this course is aligned with the AP Computer Science Principles course and exam.\n",
    "description": "",
    "tags": null,
    "title": "AP Alignment",
    "uri": "/z-ap-alignment/"
  },
  {
    "content": "Chapter 12 How the Internet Works ",
    "description": "",
    "tags": null,
    "title": "How the Internet Works",
    "uri": "/ii-internet/12-internettech/"
  },
  {
    "content": "Chapter 13 Web Programming ",
    "description": "",
    "tags": null,
    "title": "Web Programming",
    "uri": "/ii-internet/13-webprog/"
  },
  {
    "content": "Chapter 14 High Performance Computing ",
    "description": "",
    "tags": null,
    "title": "High Performance Computing",
    "uri": "/iii-topics/14-hpc/"
  },
  {
    "content": "Chapter 15 Compression \u0026 Error Checking ",
    "description": "",
    "tags": null,
    "title": "Compression \u0026 Error Checking",
    "uri": "/iii-topics/15-compression-error-checking/"
  },
  {
    "content": "Chapter 16 Cryptograpy ",
    "description": "",
    "tags": null,
    "title": "Cryptograpy",
    "uri": "/iii-topics/16-cryptography/"
  },
  {
    "content": "Chapter 17 Cybersecurity ",
    "description": "",
    "tags": null,
    "title": "Cybersecurity",
    "uri": "/iii-topics/17-cybersecurity/"
  },
  {
    "content": "Chapter 18 Artificial Intelligence Image Source: theconversation.com\nImage Source: xkcd.com\n",
    "description": "",
    "tags": null,
    "title": "Artificial Intelligence",
    "uri": "/iii-topics/18-ai/"
  },
  {
    "content": "Chapter 19 Search and Information Retrieval ",
    "description": "",
    "tags": null,
    "title": "Search and Information Retrieval",
    "uri": "/iii-topics/19-search-info/"
  },
  {
    "content": "Chapter 20 Big Data Image Source: theconversation.com\n",
    "description": "",
    "tags": null,
    "title": "Big Data",
    "uri": "/iii-topics/20-big-data/"
  },
  {
    "content": "Chapter 21 Ethics ",
    "description": "",
    "tags": null,
    "title": "Ethics",
    "uri": "/iii-topics/21-ethics/"
  },
  {
    "content": "Chapter 22 Graphics and Video Games ",
    "description": "",
    "tags": null,
    "title": "Graphics and Video Games",
    "uri": "/iii-topics/22-graphics-and-video-games/"
  },
  {
    "content": "CC 110 Textbook This is the textbook for CC 110.\n",
    "description": "",
    "tags": null,
    "title": "Homepage",
    "uri": "/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
