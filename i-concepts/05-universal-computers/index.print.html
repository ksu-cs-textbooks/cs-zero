<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content=" "><meta name=author content="K-State CS Faculty"><meta name=twitter:card content="summary"><meta name=twitter:title content="Universal Computers :: Intro CS Textbook"><meta name=twitter:description content=" "><meta property="og:url" content="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/05-universal-computers/"><meta property="og:site_name" content="Intro CS Textbook"><meta property="og:title" content="Universal Computers :: Intro CS Textbook"><meta property="og:description" content=" "><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Universal Computers :: Intro CS Textbook"><meta itemprop=description content=" "><meta itemprop=datePublished content="2020-08-10T16:23:05-05:00"><meta itemprop=dateModified content="2025-02-13T09:37:13-06:00"><title>Universal Computers :: Intro CS Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cs-zero/i-concepts/05-universal-computers/ rel=canonical type=text/html title="Universal Computers :: Intro CS Textbook"><link href=/cs-zero/i-concepts/05-universal-computers/index.xml rel=alternate type=application/rss+xml title="Universal Computers :: Intro CS Textbook"><link href=/cs-zero/i-concepts/05-universal-computers/tele.html rel=alternate type=text/html title="Universal Computers :: Intro CS Textbook"><link href=/cs-zero/i-concepts/05-universal-computers/embed.html rel=alternate type=text/html title="Universal Computers :: Intro CS Textbook"><link href=/cs-zero/css/fontawesome-all.min.css?1753300004 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/fontawesome-all.min.css?1753300004 rel=stylesheet></noscript><link href=/cs-zero/css/nucleus.css?1753300004 rel=stylesheet><link href=/cs-zero/css/auto-complete.css?1753300004 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/auto-complete.css?1753300004 rel=stylesheet></noscript><link href=/cs-zero/css/perfect-scrollbar.min.css?1753300004 rel=stylesheet><link href=/cs-zero/css/fonts.css?1753300004 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/fonts.css?1753300004 rel=stylesheet></noscript><link href=/cs-zero/css/theme.css?1753300004 rel=stylesheet><link href=/cs-zero/css/theme-auto.css?1753300004 rel=stylesheet id=R-variant-style><link href=/cs-zero/css/chroma-auto.css?1753300004 rel=stylesheet id=R-variant-chroma-style><link href=/cs-zero/css/variant.css?1753300004 rel=stylesheet><link href=/cs-zero/css/print.css?1753300004 rel=stylesheet media=print><link href=/cs-zero/css/format-print.css?1753300004 rel=stylesheet><script src=/cs-zero/js/variant.js?1753300004></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cs-zero",window.index_js_url="/cs-zero/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cs-zero/css/custom.css?1753300004 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cs-zero/i-concepts/05-universal-computers/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cs-zero/i-concepts/><span itemprop=name>CS Concepts</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Universal Computers</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cs-zero/i-concepts/04-programming/10-pots-reading/ title="Pattern on the Stone Reading (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cs-zero/i-concepts/05-universal-computers/01-introduction/ title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 5</div><h1 id=universal-computers>Universal Computers</h1><p><a href=#R-image-e6e30aff38a26fdfb939a8aea9b5c7dc class=lightbox-link><img alt="The ENIAC" class="border lazy lightbox noshadow figure-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e6e30aff38a26fdfb939a8aea9b5c7dc><img alt="The ENIAC" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg></a></p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Universal Computers</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><a href="https://www.youtube.com/watch?v=jbEHZuOxaHg">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/i-concepts/05-universal-computers/slides/5-UniversalComputers.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>Welcome back, everyone. In today&rsquo;s video, we&rsquo;re going to be talking about universal computers. Now to pretty much pick up where we left off a while ago when we were talking about Boolean logic, Claude Shannon had just proposed a way to take electrical circuits and represent any Boolean logical statement with them. And so this was a huge turning point in the history of computer science. But how did we make the leap from Boolean logic on electrical circuits to the modern computers that we have today, and we&rsquo;ll talk a little bit about that gap here today, but there will still be some missing parts that we&rsquo;ll talk about later. But this brings us to Herman Hollerith, who at the time was a United States Census office employee, and he was tasked with coming up with a better way to calculate the census result. Because at the time, calculating the US census was incredibly slow. The 1880 census alone took eight years to tabulate, which really kind of defeats the purpose of a census, right? If you only know how many people you have in your country, eight years after the fact, the census was actually taken.</p><p>And so 10 years later, Herman had actually implemented a new system. And so in 1890, when he tabulated the US Census, then it only took one year to complete versus the eight years from the 1880 census. And this is even taking into account the 30% increase in population over that decade, which is pretty impressive, to say the least. So how did he do it? Well, just as Joseph Marie Jacquard had discovered, punch cards are really great way to organize and calculate information, particularly when you want that information to be read and used by machines. And so Hollerith was inspired by this fact. But really, actually, he was inspired by the way railroad conductors would actually use punch cards to track the gender and age and so forth from people buying tickets for the railroad. So not only did Herman Hollerith develop a new punch card in order to track US Census data, he also developed a machine to actually read it.</p><p>So this is an example of a Hollerith tabulating machine that was used in the 1890 census. So this machine could read the card and tabulate all of the information that was on them, and was also advanced enough to actually infer other facts and keep track of things like the number of married men and women. And depending on the data on the card, there is a compartment down you can kind of see towards the bottom right hand corner there. That was a storage box, for the cards and so depending on what kind of data was actually on the cards, a compartment in this storage box would open. So the operator that was using the machine could take the card from the machine and put it in the corresponding box. So essentially right it was auto sorting all of the census data, which was also pretty cool. But Hollerith continued to improve his designs and created several upgraded machines that could tabulate all sorts of data, not just census and donation, he would go on to create his own company, the Tabulating Machine Company, and a couple decades later, his company would join several under under a new name the Computing Tabulating Recording Company. But this was eventually renamed to be something else, the International Business Machines company, right. And many of you all know this company as IBM. Pretty cool, right?</p><p>This is something that I learned when coming to computer science, I had no idea how IBM got their start, but tabulating machines is pretty much where they come from. Now, this particular image from this slide is from the US Social Security Administration in 1936. This shows several IBM tabulating and sorting machines in use. And so they use these for all sorts of things as time progressed, and each one was able to keep track of all sorts of different kinds of information. One example could be tracking the sales of a particular person or company for the purpose of billing, right, or tabulating sales, and inside of a convenience store or something like that. Does all sorts of things, right. So things that were traditionally done on pen and paper or pencil and paper, and prone to a lot of human error. We could feed these punch cards through these machines and they would auto tabulate everything. For us, and they were pretty popular all the way through the 50s and 60s, until the computer started to take over really, but this pretty long time, right? About 30 years or so, for these tabulating machines, as they kind of took their grip. But we&rsquo;ll talk a little bit here in just a second about the actual first computers that we actually had in the United States. But just as a quick little fun fact, we&rsquo;ve talked briefly in a previous video How pretty much took a country torn by war before we actually started, or the world torn by war, really. Before we started to get a lot of advancements in computing technology. IBM was actually involved with selling these tabulating machines to the Nazi Party in Germany and may have inadvertently aided their attempts to catalog and later persecute the Jews. During the Holocaust, so a little bit of dark history behind IBM and their tabulating machines.</p><p>But anyways, let&rsquo;s talk about the some of the early major computers that we actually had in the US. So, first and foremost, the mark one, the mark one that was really important because we started to see a shift from pure mechanical computers or computers like tabulating machines to something that was a little bit more flexible, a little bit more powerful, as far as what type calculations that could be done. But the mark one was an electromechanical computer, and it was the largest of its type ever built. And its main purpose was actually to aid in the calculating ballistics tables that were needed by the gunners to accurately aim and fire weapons that were being developed for the war because to try to stay ahead, the US was developing weapon at an alarming rate. And the time it would take about 20 hours for a skilled mathematician to analyze a single 60 second trajectory shot. This is way too slow at the pace that weapons are actually being developed. And so the mark one was completed 13 years after it was commissioned in 1944. And proved to be pretty useful, right. So this is also remember back with Grace Hopper when we talked about her. This was the computer that she was commissioned to work on by the US Navy. So then let&rsquo;s chat about the kind of the next step up right. So the mark one was an electro mechanical computer, which had tons of parts, right. Five tons of computer if you can imagine that. And one little But the fun fact that I always like to emphasize here is that the mark one had five horsepower. Right? So it actually had an engine their in order to run it. So if you can kind of imagine having a laptop that had an engine in order for it to actually work kind of crazy to think about that your computer has horsepower.</p><p>But we did take a big leap forward after the mark one was completed. So in 1943, the US Army and the University of Pennsylvania began working on a project that would be the successor to the mark one called the electrical numerical integrator and calculator or any ENIAC right. Scientists like acronyms, and sometimes they&rsquo;re pretty good. Sometimes they&rsquo;re not so great. But when the ENIAC was completed in 1946, it turned out to be about 1000 times faster than the mark one. But the ENIAC was so revolutionary. because it was the first all electric programmable computer that was truly general purpose. And we&rsquo;ll talk about that here in just a little bit. But remember how we were talking about the Difference Engine that Charles Babbage created that was truly are the Difference Engine number two in the analytical engine that were truly general purpose computers, right. And so now we have the first all electric computer compared to the mark one, which still had a lot of the mechanical parts right had five horsepower. But the ENIAC ran almost continuously from 1946 to 1955. So had a pretty good long, long term operation here. Again, right had an insane number of parts right over 17,000 vacuum tubes that were used to run at 70,000 resistors, 10,000, capacitors and over 5 million hand soldered joints. If you have a hard time trying to figure out what&rsquo;s wrong with your computer Now, imagine trying to debug and fix a computer that had so many different moving parts or so many different hand soldered parts is really kind of crazy to think about. But we&rsquo;ll bring up the neck and the mark one and another lecture as well.</p><p>But I do kind of want to highlight a really big important part during this time frame, right? During the mark one and the ENIAC because remember, this is during World War Two, where a lot of the men were overseas fighting the war. And so a really far less known fact in computer science right? Early computer scientists were all women. So in the early days of computer science, the mark one ENIAC the majority of these machines and computers were being serviced, programmed and ran by women during the war. There&rsquo;s this awesome documentary called the Top Secret Rosies, I would highly recommend watching the entire documentary. I&rsquo;m sure you could probably find it streaming online somewhere. But this particular clip that I will show here in just a little bit, is just kind of a summary of the role of these women played during World War Two</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=top-secret-rosies>Top Secret Rosies</h1><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://player.vimeo.com/video/18327205 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="vimeo video" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=top-secret-rosies-website>Top Secret Rosies Website</h1><p><a href=https://sites.temple.edu/topsecretrosies/ rel=external target=_blank title="External Website for Top Secret Rosies">Top Secret Rosies Website</a></p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=electronic-computing-crash-course>Electronic Computing (Crash Course)</h1><a href="https://www.youtube.com/watch?v=LN0ucKNX0hc">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=the-imitation-game>The Imitation Game</h1><a href="https://www.youtube.com/watch?v=xvppZNe6jAQ">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=what-are-universal-computers>What ARE Universal Computers?</h1><a href="https://www.youtube.com/watch?v=Agnx5dd03VA">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/i-concepts/05-universal-computers/slides/5-UniversalComputers.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>So what really is a universal computer? We&rsquo;ve thrown that term around a little bit. We&rsquo;ve also talked about what it means to be a truly general purpose computer or reprogrammable computer compared to a fixed program computer like what the original Difference Engine was. So, this is what made the ENIAC so unique as well as the mark one, although to a lesser extent. is the fact that they are considered the world&rsquo;s first true universal computers. So what do you think it means to be called a universal computer? Well, a universal computer can simulate any real world computer given infinite time and infinite memory. So if you imagine taking your cell phone or even something as small as like the little Raspberry Pi or a smartwatch. And if it was truly a universal computer, if you gave it enough time and enough memory, it could pretty much do anything any other computer could do. So compare that to some supercomputer right like Beocat that we have in the computer science department here at K-State. Right, a universal computer can do anything that Beocat can do, given enough time and give it given enough space.</p><p>So this brings us to Alan Turing. Now, Alan Turing was one of the first people to come up with this idea of a truly universal computer. Now, in 1936, he proposed this idea of an imaginary computer, and this imaginary computer was so simple, it was like it couldn&rsquo;t do anything right. And actually Alan Turing was mocked quite extensive. Simply for coming up with this idea because people thought it was just crazy that it wouldn&rsquo;t work. But now we know this imaginary computer to be known as the Turing machine. But in reality, this Turing machine, this simple machine that he kind of came up with, was able to do and calculate any value that could be done by any other computer, even though it was crazy simple. So let&rsquo;s take a look at an example of what a Turing machine might look like right because it was an imaginary computer an imaginary machine.</p><p>So a Turing machine itself consisted of a an infinitely long tape, and this tape is divided. It has individual squares on it, just kind of like a roll of film wood and a classic non digital camera anyways, but each individual square you could would be either a one or a zero or it could be blank if it hadn&rsquo;t had any data written to it yet. Now the machine actually works by moving back and forth along the tape and reading and writing ones and zeros depending on the value that actually reads out from the tape. But how does it actually know where to go? Well, if you can see here in the picture, there&rsquo;s this little controller in the system as well.</p><p>Now this controller would have had a program pre loaded onto it. And so we could write this program using these commands here and it&rsquo;s relatively simple, right? We have eight different commands right, move left, and move right, right one, right, zero, read. So the read is if this square is zero, or if this square is one, go to Step x in the program. And then we also have just a straight, go to Step whatever, and stop. So the program itself right could only consist of these eight steps and here in another video, we&rsquo;ll take a look at an example of these eight steps in action. But it&rsquo;s really important to emphasize how cool this actually is right? The simplicity of these eight basic steps represent a universal computer. And this universal computer right is just a can accomplish just as much as something a supercomputer could do like Beocat. So, given enough time, and memory, a Turring machine with these eight basic steps, and only reading and writing ones and zeros could accomplish any problem.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=alan-turing>Alan Turing</h1><a href="https://www.youtube.com/watch?v=7TycxwFmdB0">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=modern-turing-machines>Modern Turing Machines</h1><a href="https://www.youtube.com/watch?v=E3keLeMwfHY%3fstart%3d200">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=turing-machine-example>Turing Machine Example</h1><a href="https://www.youtube.com/watch?v=25l4D3THmec">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/i-concepts/05-universal-computers/slides/5-UniversalComputers.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>Hello everyone in this video we&rsquo;re going to take a look at a detailed example on how a Turing machine may actually perform a common operation that we would do with a regular program. Remember that our Turing machine has eight simple instructions that it can execute using the control arm or the the reader that the machine or the program is actually loaded on. But it can simply move left or right one, it can write ones and zeros and it can also read and also jump around in the program as well. So these eight simple steps remember represent a truly universal computer given enough time, and given enough memory, it can perform any operation any other real world computer could actually do. So here&rsquo;s an example of a basic program on our Turing machine. So our reader or the Turing machine itself would be preloaded with this program. In this situation, we&rsquo;re going to assume that we start with two elements or two items or two pieces of data on our tape. And these items, remember, all we&rsquo;re dealing with here are ones and zeros, nothing else.</p><p>So we&rsquo;ll start with two binary digits on our tape. And then the program has just a finite number of steps here, so steps one through 11. And you can see here we jump around a little bit. For example, in step one, if we read a one on the tape, then we&rsquo;re going to jump to step number five in our program. So the go to number five isn&rsquo;t a step to number five in our tape, it is go to number five in our actual programs, line five in our program. For this example we&rsquo;re actually going to do here is we&rsquo;re going to step through our program overall and try to figure out what kind of operation it&rsquo;s actually trying to perform is just looking at this straight up. It&rsquo;s kind of hard to tell what we&rsquo;re actually trying to accomplish or what the Turing machine is actually trying to accomplish.</p><p>So let&rsquo;s work out this example here. So since we only start with two binary digits on our tape, that really means we only have four possible combinations in total, right, we only have two binary digits to the power of two is four. So this is the number of combinations of those two digits that we might actually have. So let&rsquo;s go ahead and write to these different combinations out here. We have 0 0. We have 0 1, 1 0, and finally, 1 1. So I&rsquo;m going to go ahead and label these different cases here. So we can kind of keep track of them a little bit better. So this is case A, B, C, and let&rsquo;s call this one over here. D Now this is a little bit different than how we would normally actually read things. In this case for my Turing machine, I&rsquo;m going to read my inputs or start my inputs from left to right. So if we start out our program here at step number one, I&rsquo;m going to go ahead and just work on example A here first or this data A here first, to our head, our reader, our Turing machine, starts looking at the first square out. Step number one, and our program says if one, go to Step Five. Now, the data that we have here is actually just a zero, so we&rsquo;re not going to jump to step five. So we&rsquo;ll actually just continue on and go to step number two.</p><p>Now notice that my head over here, or where my Turing machine is actually reading from does not actually move until I tell it to. Now step two does tell us to move left. And so you can either imagine this as the head moving left, or the tape moving in the opposite direction. And so what that actually causes us to do is we&rsquo;re going to no longer be in that spot are going to move on to this square. So then let&rsquo;s continue on to our next step here. So we already move left and so we&rsquo;ll keep on executing our program sequentially. So at step number three, we have if 0, go to step nine. So if 0 is true. So we were reading a 0 here, I&rsquo;m going to jump from step three, all the way down to step nine. Step nine, says move left. So we&rsquo;re going to move our tape over here to this empty square. And then we&rsquo;re going to go down to the next step, step 10. Step 10 says write a 0. So my, machine is going to write a zero here. And then we&rsquo;ll continue on to our next step of our program, and our Turing machine stops. So our output here, this is our output, what our machine actually wrote out as a result of running our program, given the starting data.</p><p>Let&rsquo;s continue on. Let&rsquo;s go and look at another example here. So if we look at our second data set here, we are going to again, start at our first position here. And start out at number one on our slides over here or on our on our list over here. So if one, go to Step five, and so this indeed is a one. So that is that is good. And so we&rsquo;re going to skip steps two, three and four, and go down to step five. Step five tells us to move left. So I&rsquo;m going to move left here. And that&rsquo;s step five. And then step six says move left again, though, we&rsquo;re going to stop that, move our Turing machine, head over one. Step seven, tells us to write a one. And then we go down to step eight, and that says, Stop. So this was the result of doing our data B over here. This particular example. So our first one, we read two zeros and output at zero. In this case, we read a one. And then we, we moved over to zero, but we didn&rsquo;t actually read this one, right? Remember, we didn&rsquo;t actually read the second data piece, we only read our first piece of information, and then we skipped over zero and then wrote a one in our empty spot. So let&rsquo;s do more examples.</p><p>You still have C, and D to go. So again, we&rsquo;re going to start out over here at our first piece of information. Step one, right, step one, go to Step five, so that&rsquo;s not true. So we&rsquo;re going to jump down here to step number two. Step number two says move left. So we&rsquo;re going to move left one Then continue on to Step three. That three says if zero go to nine, well, that&rsquo;s not true because we&rsquo;re at a, our, our current carrying machine tape square has a one on it, it will go down to step four, which says if one go to Step six, which is true, though, that is true. So we&rsquo;re going to go to step number six, then that tells us to move left, go on to Step seven. Step seven, tells us to write a one and then the top. So very similar case as what we had for be here where we read a one, skip to zero, wrote one. Here, we wrote as we read a zero, move left, write a one and then output it. And then finally, just to kind of put this last the this dataset to rest here, let&rsquo;s check out D. This will be the final indicator for what kind of operation that we&rsquo;re actually trying to showcase here.</p><p>So just like what we&rsquo;ve done before, we&rsquo;re going to start out at our first square on our Turing machine tape. And then of course, start out at our first step in our program. So if one go to step number five, so our square that we&rsquo;re at is indeed a one. So we&rsquo;re going to skip all the way down here to step number five. Step number five, says, move left though, I&rsquo;m going to move the machine over one. Step six says move left. I&rsquo;m going to move over one again. Then, step seven says write a one. Oh, well, let&rsquo;s try to one here and that square and then Stop. So that&rsquo;s pretty much it for our particular Turing machine example, for this particular program, we&rsquo;ve covered all of the different combinations of data that we possibly could have on our tape for this particular program.</p><p>Now, what kind of operation Could you imagine would actually be represented here? Oh, really, the hint is how the program or what the program outputted when we actually read our ones and zeros out, the only time that we actually out voted a, we wrote out a zero was when both of our inputs here were heroes. Right? So when we had two zeros, so remember, zero meaning false and one meaning true in binary, so, zero and zero is zero. So starting to look like a Boolean operator. So if we come down and look at B. So we have for a we had zero whatever the operator is zero, and that equals zero. So for B, we had, we had one , zero, which is one, for C, we had zero, one. And that was a one. And then for D, we had one, one, which is one. Now, what is the binary or not that sorry, not the binary, the Boolean operator that unifies all of these statements. Well, it&rsquo;s not AND right, because if and was the operator here, this would output false ,right, so one and zero would be zero not one, or true and false is false. So it&rsquo;s not that and it&rsquo;s not the exclusive OR either because exclusive OR would have made D equal false. So one XOR one would be to write because XOR is one or the other, but not both. So really the only to the left, the only Boolean operator that takes two operands right, left hand and right hand side, the only one that we have left is OR so if we put OR here, zero or zero is 0, 1, OR zero is one, zero OR one is one, and one OR one is one. So this Turing machine is simply OR Or you can, if you remember from the Boolean algebra, right, it&rsquo;s For our examples that we&rsquo;re going to be doing in class other examples that we&rsquo;ll be doing in class will have you try your shot at trying to analyze a Turing machine program to figure out what kind of Boolean operator it may be, or even making your own Boolean operator program as as a Turing machine.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=von-neumann-architecture>Von Neumann Architecture</h1><a href="https://www.youtube.com/watch?v=KY-H-i-tyvU">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/i-concepts/05-universal-computers/slides/5-UniversalComputers.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>Unfortunately, with all the computers that we&rsquo;ve talked about so far, they don&rsquo;t really look like the computers that we have today, right? These machines took up entire, literally entire rooms and weighed tons and had millions upon millions of different individual parts. And so how did we get from a giant computer that takes up our room to a computer that fits on your wrist? And so the last piece of that puzzle comes to us from John Von Neumann, and some call him the last of the great mathematicians. And his accomplishments are truly outstanding, although you may hear some feedback against calling him the last of the great mathematician. But where does Von Neumann actually come into play with computer science history?</p><p>Well Von Nueman is credited for the Von Neumann architecture. And now really the Von Neumann architecture really sets the stage for modern computing of the way our current computers right now are structured overall. So the Von Neumann architecture contains a few primary parts here, we have the control unit, which is responsible for following and sorting instructions, the arithmetic logic unit, which handles all the calculations, we also have a device that is used for storing memory. And we also have some possible way of inputting and outputting content, right. So we can input whether whatever it may be, that could be a keyboard, that could be a program that we give the computer and we also have some form of output, whether it be a screen, a video, whatever it actually may be. So we think a little bit farther back when we talked about what a computer should be able to do, right? A computer should be able to store stuff It should be able to calculate things, it should be able to be programmable, right, we should be able to accept variable input, and we should be able to output, right. And this pretty much accomplishes all of those things.</p><p>And really, nothing has changed since the 1940s, when the Von Neumann architecture was designed and published. Now, I&rsquo;m personally actually really interested to see how computing continues to evolve. And when we talk about hardware, you may see a few things about you know how some of this has changed a little bit. But the core idea of how our computing devices are now even modern day desktops, laptops and things like that are pretty much the same. There are some minor tweaks and reformulations of this idea, but nothing has drastically changed since then. So really, it&rsquo;s going to be interesting to see what the future holds. With the structure of competing, right, are we going to, you know, what&rsquo;s DNA computing going to do? Is that going to change the structure of our bond? Is that going to change or break the Von Neumann architecture? Are we going to gravitate to something completely entirely different? I&rsquo;m not sure but it&rsquo;ll be really exciting to see what happens in the next few years.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pattern-on-the-stone-reading>Pattern on the Stone Reading</h1><p>Read Pattern on the Stone, Chapter 4.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cs-zero/commit/90d7ea6f00b3d4b118ebed9b5a23784dc93b2d12>Feb 13, 2025</a></p></div></div><script src=/cs-zero/js/clipboard.min.js?1753300004 defer></script><script src=/cs-zero/js/perfect-scrollbar.min.js?1753300004 defer></script><script src=/cs-zero/js/theme.js?1753300004 defer></script></body></html>