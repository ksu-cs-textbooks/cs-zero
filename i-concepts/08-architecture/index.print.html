




	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="Intro CS Textbook">
    <meta name="author" content="K-State CS Faculty">
    <title>Computer Architecture :: Intro CS Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/index.html" rel="canonical" type="text/html" title="Computer Architecture :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/index.xml" rel="alternate" type="application/rss+xml" title="Computer Architecture :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/tele.html" rel="alternate" type="text/html" title="Computer Architecture :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/embed.html" rel="alternate" type="text/html" title="Computer Architecture :: Intro CS Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fontawesome-all.min.css?1701376071" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fontawesome-all.min.css?1701376071" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/nucleus.css?1701376071" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/auto-complete.css?1701376071" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/auto-complete.css?1701376071" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/perfect-scrollbar.min.css?1701376071" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fonts.css?1701376071" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fonts.css?1701376071" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/theme.css?1701376071" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/theme-auto.css?1701376071" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/variant.css?1701376071" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/print.css?1701376071" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/format-print.css?1701376071" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/ie.css?1701376071" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/url.js?1701376071"></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/variant.js?1701376071"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cs-zero/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cs-zero/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cs-zero/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/custom.css?1701376071" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cs-zero/index.html"><span itemprop="name">Intro CS Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/index.html"><span itemprop="name">CS Concepts</span></a><meta itemprop="position" content="2"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Computer Architecture</span><meta itemprop="position" content="3"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 8</div>
<h1 id="computer-architecture">Computer Architecture</h1>

<p>
<a href="#image-f38efbbcc8d543d1d5a6c0b4db11ff94" class="lightbox-link">
<img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/KL_National_INS4004.jpg" alt="Intel 4004" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-f38efbbcc8d543d1d5a6c0b4db11ff94">
<img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/KL_National_INS4004.jpg" alt="Intel 4004" class="lightbox-image" loading="lazy">
</a></p>

            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Computer Architecture</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=PkxU9e8RDdw">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/01-introduction/../slides/8-Computer_Architecture.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>In previous videos, we&rsquo;ve talked about computers such as the ENIAC and the mark one, which were electromechanical computers and electronic computers that had hundreds of components and thousands of individually solder joints. While those machines were very powerful, a failure of any one of those components or joints could cause problems for several hours as engineers tried to solve it.</p>
<p>This problem was really best summed up by Jack Morton, the Vice President of Bell Labs. In 1957. He wrote a paper celebrating the 10th anniversary of the invention of the transistor and said the following. For some time now, electronic man has known how in principle to extend greatly his visual tactile and mental abilities through the digital transmission and processing of all kinds of information. However, all of these functions suffer from what has been called the tyranny of numbers. Such systems because of their complex digital nature, require hundreds, thousands and sometimes 10s have thousands of electronic devices.</p>
<p>All of that changed about a year later due to the work of Jack Kilby. Jack Kilby, he was born in Jefferson City, Missouri, but actually grew up in Great Bend Kansas and was trained as an electrical engineer. In 1958, he was hired by Texas Instruments to try and work on solving this tyranny of numbers problem. Based on his work, he came up with the idea of printing components directly on a circuit board that was made of some sort of semiconductor material. In that way, the joints and the components were all solidly connected together, so that you didn&rsquo;t have to worry about each individual component or joint failing on the chip. This became known as the integrated circuit. Let&rsquo;s take a look at another video showing Jack Kilby&rsquo;s integrated circuit and what it did.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="ic-invention-integrated-circuits---jack-kilby">IC Invention (Integrated Circuits - Jack Kilby)</h1>


<a href="https://www.youtube.com/watch?v=62JMBnT2HUc">YouTube Video</a>


            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="integrated-circuits">Integrated Circuits</h1>


<a href="https://www.youtube.com/watch?v=T79FYkePjMM">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/03-integrated-circuits/../slides/8-Computer_Architecture.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>The device that Jack Kilby pioneered is shown here, it is the first integrated circuit. What we have here is a piece of germanium with several components printed directly on to the semiconductor material and a few wires coming off of it. And while it may not look like much now, if you connect the wires up properly, you can actually see a sine wave on an oscilloscope produced by this device. They call this device an integrated circuit because the circuit between all of the components and the wiring is all connected directly onto the piece of germanium.</p>
<p>Now, of course, you might realize that we don&rsquo;t make computer circuits out of germanium today, and so there&rsquo;s a little bit more work that needed to be done. This lies in the work of another engineer named Robert Noyce. Robert Noyce worked at Fairchild Semiconductor and was working on a similar idea to Jack Kilby&rsquo;s. However, he decided that instead of using germanium he would build an integrated circuit using silicon a very similar element. And it turns out that using silicon was a much better choice, and he was able to overcome some of the design flaws of Kilby&rsquo;s design working independently at about the same time.</p>
<p>A few years later, Robert Noyce left Fairchild Semiconductor along with Gordon Moore, another engineer to create their own company focused on developing and building these integrated circuits. Do you want to guess what that company is? That company is Intel. It was founded by Robert Noyce, Gordon Moore and Andy Grove, pictured here in 1968. And unlike Fairchild Semiconductor, who didn&rsquo;t really see as much value in the integrated circuit, Intel very quickly realized that the integrated circuits would be the future. And so they focused on designing, creating and manufacturing these new integrated circuits using semiconductors.</p>
<p>Gordon Moore is another important engineer in the history of computer science. You&rsquo;ve probably heard of Gordon Moore based on his namesake Moore&rsquo;s law in 1960 Five Gordon Moore wrote a paper called cramming more circuits onto integrated components. And in that paper, he discussed what the future of these integrated circuits might look like. He predicted that the number of circuits on a chip could double about every year to 18 months for another 10 years at most. And of course, it turns out he was much more correct than even he thoughts shown in the graph. Here we have the number of transistors on a particular chip versus the date of introduction. And you&rsquo;ll notice that throughout the lifetime of computers all the way through about 2010 Moore&rsquo;s Law held very fast, it was a very good way of measuring the quick growth of power among computer chips.</p>
<p>So in 1971, Intel finally released their first central processing unit or CPU, the Intel 4004, which is pictured here. This chip may look very small, but it had 2300 transistors built on it all in the size of a small finger. And the circuits inside of here are 10 times smaller than the human hair. This was a really revolutionary chip and it was used in a variety of places. In fact, one of the first devices to use this chip was an adding machine such as the ones you see at banks or accounting offices today. This chip is a better example of a microcontroller. A microcontroller is a chip that includes everything a device needs to think in function all on a single little chip.</p>
<p>And so this is a chip similar to an Intel 4004 that&rsquo;s had the top shaved off. And so if that chip is the size of a finger, this little interior part is the size of the fingernail on that finger. And inside of there is where the transistors actually lie. And so here you can see those filaments connecting to the wires that are smaller than a human hair that make this device work. These microcontrollers form the basis of today&rsquo;s modern computers, but that&rsquo;s only part of the story. The other part of the story is looking at how we make today&rsquo;s modern computers actually react to input and operate in the real world will take Look at that in the rest of this module.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="cramming-more-components-onto-integrated-circuits">Cramming More Components onto Integrated Circuits</h1>

<p>This paper is by Gordon E. Moore.</p>
<p><a href="https://www.cs.utexas.edu/~fussell/courses/cs352h/papers/moore.pdf" target="_blank">Cramming More Components onto Integrated Circuits</a>
</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="the-story-of-the-intel-4004">The Story of the Intel® 4004</h1>

<p>The history of the Intel® 4004</p>
<p><a href="https://www.intel.com/content/www/us/en/history/museum-story-of-intel-4004.html" target="_blank">The Story of the Intel® 4004</a>
</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="von-neumann">Von Neumann</h1>


<a href="https://www.youtube.com/watch?v=TfusBOludRI">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/06-von-neumann/../slides/8-Computer_Architecture.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>Up to this point in this class, we&rsquo;ve talked about a certain type of computer called a fixed program computer. However, a fixed program computer has some limitations. A fixed program computer can only perform one task without being completely rebuilt and redesigned for another task. While this may seem very powerful, it is actually very limiting. So examples of fixed program computers would be Babbage&rsquo;s Difference Engine. It is designed and built for one particular purpose. Of course, Babbage did design another computer, the analytical engine that would have been different it would have been programmable.</p>
<p>And this lies in the modern work of John von Neumann. John von Neumann was a researcher, a mathematician and engineer he was involved in a lot of fields, and his research was directly involved in the Manhattan Project, among other things. His work was also inspired by the work of Alan Turing, and he ended up working on the Edvac which was a successor To the computer. And as he was working on these systems, he started to see a way that he could design a computer that would not only be able to perform tasks based on this wiring, but also it could store program instructions in memory, just like it stores data and use those instructions to change what the computer is doing. This is the idea behind what we call a stored program computer.</p>
<p>In a stored program computer, the computer program itself can be stored in memory, just like the programs data. So no longer do we need to have separate bits of memory for storing the code that we&rsquo;re running on our computer and the data we&rsquo;re operating on, we can treat them as one in the same and this is a really revolutionary idea because it vastly simplifies the architecture of our computer down to just a few simple parts. We call this type of architecture von Neumann architecture. And in von Neumann architecture, a very simplistic view of a computer looks like this diagram. We need to have Some sort of an input device where we can collect data and input from the user. We have a central processing unit that contains a control unit that keeps track of the instructions we&rsquo;re executing, and an arithmetic and logic unit that actually performs the calculation. That CPU is connected to a memory unit that stores not only the data that needs to be operated on, but the program instructions that make up the program that it is running. And then finally, the device needs some sort of output so that it can render its output out to the user either through a printout or a monitor or a sound. These parts make up modern von Neumann architecture. And if you think about your modern computers today, they are all built using this same idea. We have input devices, such as mice and keyboards, and speakers and microphones. We have a CPU, we have RAM and hard drives for our memory units. And then we have our output devices, our monitors, our speakers, all the different ways that we get data out of our computer is von Neumann architecture. In fact, there&rsquo;s a really Bad joke in computer science that asks, Is there anything new in computer science? Yeah, not much since von Neumann. And it actually is kind of true.</p>
<p>Of course, over time, computer architecture has changed a little bit in some of the details. For example, a lot of older computer systems use what&rsquo;s called a system bus to connect the CPU, the memory and the input and output devices. So in this case, when the CPU wants to get some sort of data from memory, it sends a command to the control bus that both the memory and input and output are watching. And the CPU can send a control that says I would like data, then in the address bus, it can place the data address that it would like to receive. And then the input or output device or the memory can react to that control and place the data desired into the data bus so that the CPU can receive it. And a lot of different computer systems use this particular setup and it&rsquo;s really powerful if you want to add more memory are more input and output devices. As long as you can connect them to the system bus. They can all communicate.</p>
<p>Of course, this particular system might have a flaw, can you see what it is? One major flaw with this system is if the system bus becomes overloaded, or if you have too many devices connected to it, or if the system bus is the slowest part of the computer, it very quickly can become a bottleneck. And so more modern computer designs have changed things a bit, so the CPU and memory are more directly connected, so that we don&rsquo;t have this system bus that becomes the limiting factor in our computer speed. This also leads to the concept of what we call the computer memory hierarchy. One of the things we have to remember with computer memory is the faster and more powerful the memory is, the more expensive it becomes. And therefore as much as we&rsquo;d like to fill our computers up with the fastest, most powerful memory available, it would very quickly become too expensive. So instead, we try and we try and create a hierarchy of our memory where we have a little bit of the very, very fast memory Such as your processors registers, and the cash on your processors, usually in the size of a few kilobytes to a few megabytes. And then as we go down, we have some fast memory. But it&rsquo;s a lot slower than that, such as our Ram or random access memory, where we might have a few gigabytes of that. And then we go further down the capacity where we have larger capacity, but slower. And so your hard drives or SSDs, are usually an order of 40 times as slow as the random access memory, which is again, an order of magnitude slower than the cache and the registers built into the CPU. And so one of the things we deal with a lot in computer science is building programs that can take advantage of this computer memory hierarchy. Can we design a program that acts upon data that&rsquo;s stored in the processor cache, instead of constantly loading and unloading data from that cache? If you study things such as high performance computing, you&rsquo;ll deal with this issue very, very often.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="parts-of-a-computer">Parts of a Computer</h1>


<a href="https://www.youtube.com/watch?v=YfvKz4eIdj0">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/07-computer-parts/../slides/8-Computer_Architecture.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>Let&rsquo;s spend a little bit more time looking at modern computer hardware and talking about some of the things that are related to what we&rsquo;ve already discussed in this lab. On our modern CPUs, one of the things we have to keep in mind is the instruction set architecture or ISA, that is built around the ISA determines how the CPU actually interprets the binary ones and zeros in the program code and turns that into instructions that it can follow to perform the calculations needed. One of the most common instruction set architectures is the x86 in ISA, a that was developed all the way back in the 1980s as part of the IBM compatible computers. And for about 20 or 30 years, almost every computer supported the x86 ISA or something very similar. In the mid 2000s, we had the development of 64 bit architectures such as x86, IA-64, and some other architecture sets, and so most modern computer processors today use some variant of a 64 bit operating system and a 64 bit ISA.</p>
<p>There are of course, some other instruction set architectures that are built for various types. For example, most mobile phones and small devices such as Raspberry Pi&rsquo;s use the arm instruction set architecture, which is a very different is a very much focused on low power devices. Macintosh used to use power PC, and in fact, they&rsquo;ve recently announced that they&rsquo;re planning on moving to the ARM-ISA very soon. And then of course, for smaller embedded systems there are things such as the MIPS-ISA, which is really good for small embedded chips and circuits.</p>
<p>Of course, every modern computer also includes a motherboard. A motherboard is the main chip that connects all the other devices of the system together. This slide shows some of the other parts of a modern computer motherboard, such as the CPU socket, memory slots, the northbridge and southbridge chips also today, just known as the chipsets. The on board graphics processor and sound card and some of the expansion slots where you can plug in things such as your larger graphics card or a sound card or anything else that you might have. Let&rsquo;s talk a bit more about the hardware you might find in a modern computer system.</p>
<p>The first part we should talk about is the central processing unit or CPU. This is what actually does all of the computation and calculation on your computer and is basically the brains of the operation. CPUs have a lot of different features you can look at such as the architecture or instruction set architecture that they use, the clock speed, that they have, the number of cache memory chips that they use, and the number of processing cores that are available. And central processing units come in a variety of styles and a variety of costs. And they&rsquo;re all basically the brains of your computer.</p>
<p>The next piece we can talk about is the memory usually referred to as the ram or random access memory. This is the memory that your computer uses to store the program it&rsquo;s running and the data that is currently operating on the ram can also vary based on the size and the speed at which you can access data. There&rsquo;s also different types and classes of memory. And they&rsquo;re even advanced features such as registered in ECC memory, which does error correction.</p>
<p>Beyond that, you could also have the storage devices such as your hard drive or solid state drive. These are for more long term storage of data even while the computer is turned off. They can vary based on the capacity of the drive, the interface that it connects to your computer with, and even things such as the speed that it can read and write data. For some drives. We also worry about the latency or how long it takes to get that first piece of data off of the drive once we request it. There are also more advanced things you can do with your hard drives such as create a raid raids allow you to get better performance or better security by mixing multiple drives together.</p>
<p>And there&rsquo;s so much more we could talk about CD drives or optical disk drives. We could talk about graphics cards, sound cards, wireless cards, network cards, all sorts of peripherals that go on your computer. So I think encourage you to take a look at the computer that you&rsquo;re using right now to watch this video and think about all the different parts that make up that computer and how they look in your system.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="finite-state-machines">Finite State Machines</h1>


<a href="https://www.youtube.com/watch?v=5Ako-fbBMok">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/08-architecture/08-finite-state-machines/../slides/8-Computer_Architecture.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>So far, we&rsquo;ve looked at the parts of a modern computer all the way from the integrated circuit to the CPU and RAM that we have in our modern computers. But we still haven&rsquo;t talked about how we can use those computers to represent real world systems and actually do something useful. To do that, we have to look at one more thing from computer science called the finite state machine. a finite state machine is a theoretical device that has a limited number of states. And those states can be changed based on the transitions that we get based on some inputs.</p>
<p>For example, take a look at the finite state machine diagram on this slide. Do you recognize it? This diagram shows what we might see if we mirrored a door as a finite state machine. A door has two states open and closed and it has two transitions the closed door state which allows us to take an open door and make it closed and the open door state which takes a closed door and makes it opened So obviously, we can use finite state machines to represent all sorts of different real world ideas, like the ones on this slide. This slide lists a few different things that you might come in contact with during your daily lives. And all of these things can be represented using finite state machines if we think about them in just the right way.</p>
<p>So let&rsquo;s go through an example of what it would take to create a finite state machine diagram for one of these devices. The one that I like to do is the one for a stoplight. So let&rsquo;s take a look at that. Imagine for example that we have a crossroads where two roads meet and there&rsquo;s a stoplight that helps control traffic that comes to this crossroad. We can represent a finite state machine of a stoplight by thinking about the states that are stoplight could have most stoplights we know today have three states, a red states, a green state and a yellow state. So a modern stoplight will start at the red state and then it will go to the green states. Then after a certain time, it will go to yellow. And then finally, it will go back to red. That&rsquo;s a pretty simple finite state machine, but it does help explain exactly how a stop light works. Of course, this is just for a single stoplight. at a crossroads like what shown here, we probably actually have two stoplights that are working in tandem to control both directions. So that might be represented by a few more states.</p>
<p>For example, let&rsquo;s say both stoplight start out initially as red. Then one stoplight switches to green and allows traffic to pass in that direction. After a certain amount of time that stoplight will go to yellow, and then we will go back to red red. However, notice that this state is different than the previous red red state because now we&rsquo;re going to go to green red Then of course, we go to yellow red. And finally, this state will go back to red, red. So now we&rsquo;ve gone from three states to six states to represent a two direction stoplight.</p>
<p>But of course, there&rsquo;s more to it than that. For example, let&rsquo;s say that this green light would be on the main highway, we don&rsquo;t want to always interrupt that traffic flow if there&rsquo;s nobody waiting. So we might have another state here, that is a wait state, we get to red green. And then we wait until we get some sort of sensor input saying there&rsquo;s a car on the other road that needs to pass. Then we could switch to yellow and red, and then switch the other road to green for a little bit to allow that car to pass. And of course, we could also have stoplight states. And so for example, green, we might still need to have the stoplight, say walk and then flash. And then don&rsquo;t walk before we get to the yellow states. And then of course, we can have buttons for the stoplights. We can have buttons for the crosswalks, there could be a lot of different things going on here that are all different states that we have to model within our finite state machine.</p>
<p>So as you can see, even a simple stoplight controller with two directions could have as many as 10 or 15 unique states that describe how it works. This is the real power of a finite state machine. It allows us to easily describe how real world devices work. And then we can build computer programs to represent the states and transitions of that device and run it on a computer simulation. So if you want to follow along, see if you can do one of these or two of these as an example by creating a finite state machine diagram yourself. I think you&rsquo;ll find it to be a very valuable exercise and understanding exactly how a finite state machine works.</p>

            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cs-zero/-/commit/c80453205407381a0e84aa3f8c8e12ac91f73e2c">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/clipboard.min.js?1701376076" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/perfect-scrollbar.min.js?1701376076" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/theme.js?1701376076" defer></script>
  </body>
</html>
