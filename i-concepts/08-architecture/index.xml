<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Architecture :: Intro CS Textbook</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/index.html</link><description/><generator>Hugo</generator><language>en-us</language><managingEditor>altcs@ksu.edu (K-State CS Faculty)</managingEditor><webMaster>altcs@ksu.edu (K-State CS Faculty)</webMaster><lastBuildDate>Thu, 27 Jun 2024 12:25:42 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Integrated Circuits (Part 1)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/01-introduction/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/01-introduction/index.html</guid><description>Resources Slides Video Script In previous videos, we’ve talked about computers such as the ENIAC and the mark one, which were electromechanical computers and electronic computers that had hundreds of components and thousands of individually solder joints. While those machines were very powerful, a failure of any one of those components or joints could cause problems for several hours as engineers tried to solve it.</description></item><item><title>IC Invention (Integrated Circuits - Jack Kilby)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/02-ic-jack-kilby/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/02-ic-jack-kilby/index.html</guid><description/></item><item><title>Integrated Circuits (Part 2)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/03-integrated-circuits/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/03-integrated-circuits/index.html</guid><description>Resources Slides Video Script The device that Jack Kilby pioneered is shown here, it is the first integrated circuit. What we have here is a piece of germanium with several components printed directly on to the semiconductor material and a few wires coming off of it. And while it may not look like much now, if you connect the wires up properly, you can actually see a sine wave on an oscilloscope produced by this device. They call this device an integrated circuit because the circuit between all of the components and the wiring is all connected directly onto the piece of germanium.</description></item><item><title>Cramming More Components onto Integrated Circuits</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/04-cramming-components/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/04-cramming-components/index.html</guid><description>This paper is by Gordon E. Moore.
Cramming More Components onto Integrated Circuits</description></item><item><title>The Story of the Intel® 4004</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/05-intel-4004/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/05-intel-4004/index.html</guid><description>The history of the Intel® 4004
The Story of the Intel® 4004</description></item><item><title>Von Neumann Architecture</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/06-von-neumann/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/06-von-neumann/index.html</guid><description>Resources Slides Video Script Up to this point in this class, we’ve talked about a certain type of computer called a fixed program computer. However, a fixed program computer has some limitations. A fixed program computer can only perform one task without being completely rebuilt and redesigned for another task. While this may seem very powerful, it is actually very limiting. So examples of fixed program computers would be Babbage’s Difference Engine. It is designed and built for one particular purpose. Of course, Babbage did design another computer, the analytical engine that would have been different it would have been programmable.</description></item><item><title>Computer Hardware</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/07-computer-parts/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/07-computer-parts/index.html</guid><description>Resources Slides Video Script Let’s spend a little bit more time looking at modern computer hardware and talking about some of the things that are related to what we’ve already discussed in this lab. On our modern CPUs, one of the things we have to keep in mind is the instruction set architecture or ISA, that is built around the ISA determines how the CPU actually interprets the binary ones and zeros in the program code and turns that into instructions that it can follow to perform the calculations needed. One of the most common instruction set architectures is the x86 in ISA, a that was developed all the way back in the 1980s as part of the IBM compatible computers. And for about 20 or 30 years, almost every computer supported the x86 ISA or something very similar. In the mid 2000s, we had the development of 64 bit architectures such as x86, IA-64, and some other architecture sets, and so most modern computer processors today use some variant of a 64 bit operating system and a 64 bit ISA.</description></item><item><title>Finite State Machines</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/08-finite-state-machines/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/08-architecture/08-finite-state-machines/index.html</guid><description>Resources Slides Video Script So far, we’ve looked at the parts of a modern computer all the way from the integrated circuit to the CPU and RAM that we have in our modern computers. But we still haven’t talked about how we can use those computers to represent real world systems and actually do something useful. To do that, we have to look at one more thing from computer science called the finite state machine. a finite state machine is a theoretical device that has a limited number of states. And those states can be changed based on the transitions that we get based on some inputs.</description></item></channel></rss>