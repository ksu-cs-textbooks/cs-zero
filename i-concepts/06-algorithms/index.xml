<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms :: Intro CS Textbook</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/index.html</link><description/><generator>Hugo</generator><language>en-us</language><managingEditor>altcs@ksu.edu (K-State CS Faculty)</managingEditor><webMaster>altcs@ksu.edu (K-State CS Faculty)</webMaster><lastBuildDate>Wed, 08 Oct 2025 15:23:13 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/01-introduction/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/01-introduction/index.html</guid><description>Resources Slides Video Script In this module, we’re going to learn about algorithms. But before we can discuss algorithms, let’s take a look at something that you might be very familiar with and see how it actually relates to the idea of an algorithm. For example, we can ask ourselves, how do you shuffle cards? It’s something that is really hard to describe. But once you see it, and you can observe other people doing it, it’s pretty easy to understand what’s going on. But to really know how to shuffle cards, we have to ask ourselves, what items do we need? What tools do we need? Do we need any skills and do any prior knowledge for example, we need to know what a deck of cards is, we need to know what shuffling means we need to know how to manipulate the cards in such a way that they will become shuffled. And of course, even then, the terminology we use is still very difficult. In years past, when I’ve asked students how to shuffle cards, they’ll usually tell me something like cut the deck and then hold them up like this and then ruffle the cards together and it will work. But of course, if you don’t know that cutting the deck means separating the top half from the bottom half and not taking a pair of scissors and cutting them in half. That might be really hard to understand.</description></item><item><title>The Weird Truth About Arabic Numerals (SciShow)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/02-arabic-numerals/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/02-arabic-numerals/index.html</guid><description/></item><item><title>What is an Algorithm?</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/03-what-is-an-algorithm/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/03-what-is-an-algorithm/index.html</guid><description>Resources Slides Video Script So what is an algorithm in computer science? A good definition for an algorithm is a finite list of specific instructions for carrying out a procedure or solving a problem. If you think about it, every computer program we write consists of many different algorithms. Because as we’ve learned, writing a computer program is exactly that. It’s giving the computer a list of very specific instructions that we’d like it to carry out so that it can perform a task or solve a problem for us. So let’s look at an example of what an algorithm looks like. One of the most common algorithms used today is Euclid’s algorithm. Euclid was a Greek mathematician from 300 B.C, and his algorithm was developed to find the greatest common divisor of two numbers. That greatest common divisor if you studied algebra is used to reduce fractions. And even today in our computers and calculators. We use a modified version of this algorithm to do exactly this task. It really is one of the most efficient ways to To do this, so let’s explore what Euclid’s algorithm looks like and take a look at an example.</description></item><item><title>Insertion Sort</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/04-insertion-sort/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/04-insertion-sort/index.html</guid><description>Resources Slides Video Script In these next couple of videos, we’re going to introduce the concept of sorting algorithms. Sorting algorithms are used when we want to arrange sets of data in order either from smallest to largest or largest to smallest in our computer programs. As it turns out, there are many different ways that we can sort our data using different algorithms. And each of those algorithms have unique characteristics that make them suitable for certain types of data in certain situations. To really explore sorting algorithms, we’re going to perform these sorting algorithms using a deck of cards. So if you have access to a deck of cards, I encourage you to go find one and take out maybe 8 or 10 cards in a certain order. I have the cards Ace through 10 here, and you’ll be able to follow along with our examples on these next few videos. Before we get started, I’d like you to take the cards that you have selected, shuffled them up a little bit, and then lay them out in front of you and try and sort them in order from smallest to largest. And while you do that, I’d like you to think in your mind about the exact steps that you’re following. For example, are you looking for the smallest card and moving it to one side, or looking for the largest card and moving it to the other side? Or are you trying to arrange little bits of it at a time and slowly put those pieces together until they form the full sort of deck of cards, it might be really interesting to see how the method that you naturally follow matches up with one of these algorithms that we’re going to take a look at. In particular, we’re going to look at four different sorting algorithms, insertion Sort, bubble sort, merge, sort, and quicksort.</description></item><item><title>Bubble Sort</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/05-bubble-sort/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/05-bubble-sort/index.html</guid><description>Resources Slides Video Script The next algorithm we’re going to look at is bubble sort. Bubble sort might seem similar to Insertion Sort, but it’s actually quite the different algorithm. So in bubble sort, what we will do is we will start by comparing two side by side elements in the list of data. And then if they’re out of order, we will swap them. You can see in the animation above me how those two red boxes move to compare two side by side items. And if they’re out of order, it will swap them just like so. Then we’ll repeat that once we get all the way to the end of the array. We’ll start back over at the beginning, and we’ll go through it multiple times until it is entirely sorted. Or as the algorithm says here, we’ll continue until we go all the way through the array and we don’t make any more swaps. So let’s go take a look at how to perform bubblesort using our deck of cards. The next algorithm we will look at is the bubble sort algorithm as we do bubblesort keep track of how many times you swap to different cards as that will become really important as we analyze these algorithms later on in this module.</description></item><item><title>Complexity (Part 1)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/06-complexity/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/06-complexity/index.html</guid><description>Resources Slides Video Script So far, we’ve looked at two different algorithms for sorting decks of cards, Insertion Sort, and bubblesort. So let’s take a minute and try and decide which of those algorithms do you think is faster for a computer? a better question might be, which of those two algorithms was faster for you as it person to perform? Those are really tough questions to answer, aren’t they? And so we need some way that we can analyze our algorithms and compare them apples to apples to see exactly which algorithm might be faster or more efficient on a computer. To do that, we use something called Big O notation. Unfortunately, when I refer to big O notation, I’m not talking about the giant robot anime from the early 2000s. Instead, I’m talking about the notation that we use to express the complexity of an algorithm. And specifically when we talk about complexity, we’re talking about the number of steps required to perform the algorithm based on the worst case size of the inputs.</description></item><item><title>Merge Sort</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/07-merge-sort/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/07-merge-sort/index.html</guid><description>Resources Slides Video Script The next algorithm we’re going to look at is merge sort. Merge Sort is a very unique algorithm because it’s an example of the divide and conquer paradigm of creating algorithms. In fact, Merge Sort was actually written way back in the 1950s and 60s to allow us the ability to sort data that didn’t even fit on a single data storage media at the time. So for example, with merge sort, we could sort the data on three different disks full of data very independently and very efficiently. The process for merge sort is pretty simple. We start by taking our data and splitting it in half, and we keep repeatedly splitting it in half until we get down to one or two items. Then we make sure those items are in order, and then we will merge those two items together all the way down until we get to our final results. So let’s take a look at how we can perform Merge Sort using our deck of cards. The next sorting algorithm we’ll look at is merge sorts. Remember that merge sort is a divided conquer algorithm. So it takes place in two phases. The first phase is the divide phase.</description></item><item><title>Quick Sort</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/08-quicksort/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/08-quicksort/index.html</guid><description>Resources Slides Video Script The last sorting algorithm we’re going to look at is quicksort. Quicksort is the newest of these algorithms being first published in 1961. Quicksort is a little bit different than the other sorting algorithms, because it requires us to choose a pivot element from the list and then sort based off of that pivot elements, it’s really kind of hard to understand conceptually without seeing it in action. So let’s take a look at how we perform quicksort using our deck of cards. The last sorting algorithm we’ll look at in this class is quicksort. Quicksort is a very unique algorithm. It’s like a divide and conquer algorithm, but it has some really interesting quirks and how it works that make it work really fast with random data. So let’s take a look at how quicksort works and see if we can get it to sort our deck of cards. The first step in quicksort is to choose a pivot element. And this is actually one of the key things about quicksort is choosing a pivot element most quicksort algorithm Don’t even put any thought into it, they just pick the last element or the first element in the list and call that the pivot.</description></item><item><title>Complexity (Part 2)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/09-complexity-2/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/09-complexity-2/index.html</guid><description>Resources Slides Video Script So now that we’ve learned about merge sort and quicksort, let’s take a look at the complexity of one of these algorithms. Just to understand how that works. For this example, we’re going to look at the complexity of merge sort. Let’s consider the example where we’re doing merge sort on eight numbers. So here we have the numbers 1,2,3,4,5,6,7,8. So the first step of Merge Sort would have us divide those in half into groups, 1,2,3,4, and group 5,6,7,8, then we would divide each of those in half again, ending up with four groups 1-2,3-4,5-6, and 7-8t. So this diagram helps us understand the complexity of this algorithm. And we need to measure two things. We need to measure how many swaps it can make, and then we need to measure how many divisions it makes. So let’s look at swaps first, these are all in the correct order, but we have to assume worst case. So in the worst case, we would make 1,2,3,4 swaps. So we know we need four swaps for one of our numbers. And we need to compare that to the size of the input, which is eight. So how does four compared to eight, an easy way to think of it is four is just our input size eight divided by two. That’s pretty easy. The second step is a little trickier. Because what we need to do is we need to look at how many times we have to divide the numbers to get all the way down to groups of two. And in this case, we have three levels. So we have three here, but how does three compared to eight?</description></item><item><title>Heuristics</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/10-heuristics/index.html</link><pubDate>Mon, 10 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/10-heuristics/index.html</guid><description>Resources Slides Video Script So far in this module, we’ve studied algorithms, and remember that an algorithm is a specific set of steps that we can use to solve a problem. However, what if we’re faced with a problem that we can’t solve? Either because it’s impossible, or because we have so much data that we can’t possibly find the one right answer using an algorithm. In that case, we would use something we call a heuristic. A heuristic is an experience based technique we can use to find a satisfactory solution to a problem, which may or may not be the absolute best solution to that problem. For example, if we have a particular person, and we’d like to know what their height is, we could actually get out a tape measure and measure it. Or we could use a heuristic and say, well, you’re standing next to that door and you look like you’re about six feet tall. That would be an experience based technique or a heuristic to estimate how tall someone is. We of course, use heuristics every day. For example, we use the rule of thumb when Trying to measure things. We can take educated guesses based on our previous experience, we can use our common sense and find answers that seem logical. We can try an answer and see if we can work backwards and prove that that is an answer to the question. Or we can even take our problem and try and do a simpler problem first and use that information to solve our larger problem.</description></item><item><title>Pattern on the Stone Reading</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/11-pots-reading/index.html</link><pubDate>Wed, 27 May 2020 10:53:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/06-algorithms/11-pots-reading/index.html</guid><description>Read Pattern on the Stone, Chapter 5.</description></item></channel></rss>