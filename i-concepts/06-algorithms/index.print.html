




	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="Intro CS Textbook">
    <meta name="author" content="K-State CS Faculty">
    <title>Algorithms :: Intro CS Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/index.html" rel="canonical" type="text/html" title="Algorithms :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/index.xml" rel="alternate" type="application/rss+xml" title="Algorithms :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/tele.html" rel="alternate" type="text/html" title="Algorithms :: Intro CS Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/embed.html" rel="alternate" type="text/html" title="Algorithms :: Intro CS Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fontawesome-all.min.css?1693232204" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fontawesome-all.min.css?1693232204" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/nucleus.css?1693232204" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/auto-complete.css?1693232204" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/auto-complete.css?1693232204" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/perfect-scrollbar.min.css?1693232204" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fonts.css?1693232204" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cs-zero/css/fonts.css?1693232204" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/theme.css?1693232204" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/theme-auto.css?1693232204" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/variant.css?1693232204" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/print.css?1693232204" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/format-print.css?1693232204" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/ie.css?1693232204" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/url.js?1693232204"></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/variant.js?1693232204"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cs-zero/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cs-zero/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cs-zero/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cs-zero/css/custom.css?1693232204" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cs-zero/index.html"><span itemprop="name">Intro CS Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/index.html"><span itemprop="name">CS Concepts</span></a><meta itemprop="position" content="2"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Algorithms</span><meta itemprop="position" content="3"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 6</div>
<h1 id="algorithms">Algorithms</h1>

<p>
<a href="#image-f4b10c8289e27e1f30bc9d094db007a1" class="lightbox-link">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Diagram_for_the_computation_of_Bernoulli_numbers.jpg/1280px-Diagram_for_the_computation_of_Bernoulli_numbers.jpg" alt="Ada Lovelace" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-f4b10c8289e27e1f30bc9d094db007a1">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Diagram_for_the_computation_of_Bernoulli_numbers.jpg/1280px-Diagram_for_the_computation_of_Bernoulli_numbers.jpg" alt="Ada Lovelace" class="lightbox-image" loading="lazy">
</a></p>

            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Algorithms</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=b5Zzom-lOHE">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/01-introduction/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>In this module, we&rsquo;re going to learn about algorithms. But before we can discuss algorithms, let&rsquo;s take a look at something that you might be very familiar with and see how it actually relates to the idea of an algorithm. For example, we can ask ourselves, how do you shuffle cards? It&rsquo;s something that is really hard to describe. But once you see it, and you can observe other people doing it, it&rsquo;s pretty easy to understand what&rsquo;s going on. But to really know how to shuffle cards, we have to ask ourselves, what items do we need? What tools do we need? Do we need any skills and do any prior knowledge for example, we need to know what a deck of cards is, we need to know what shuffling means we need to know how to manipulate the cards in such a way that they will become shuffled. And of course, even then, the terminology we use is still very difficult. In years past, when I&rsquo;ve asked students how to shuffle cards, they&rsquo;ll usually tell me something like cut the deck and then hold them up like this and then ruffle the cards together and it will work. But of course, if you don&rsquo;t know that cutting the deck means separating the top half from the bottom half and not taking a pair of scissors and cutting them in half. That might be really hard to understand.</p>
<p>And so in this module, we&rsquo;re going to talk about algorithms and specifically, why it&rsquo;s very important when you&rsquo;re writing an algorithm for a computer to be very specific and very explicit about the steps you want it to take. Otherwise, it will not do exactly what you want it to do. So first, we can talk about where the word algorithm comes from. And the word algorithm comes from the name Al - Khwarizmi, which is a shorter version of the name of Abu Abdallah Muhammad ibn Musa al-Khwarizmi . He was a mathematician in the 9th century A.D in Persia. And one of the things he did is he wrote a lot of books on contemporary mathematics. And one of his books was very unique because it included a set of steps to solve some common mathematical problems. And those steps form the basis of what we now call an algorithm for solving those problems. And so in the next video after this, we&rsquo;re going to see a little bit more about The history of Al-Khwarizmi and why he is so important and so interesting in the field of computer science.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="the-weird-truth-about-arabic-numerals-scishow">The Weird Truth About Arabic Numerals (SciShow)</h1>


<a href="https://www.youtube.com/watch?v=Ar7CNsJUm58">YouTube Video</a>


            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="what-is-an-algorithm">What is an Algorithm</h1>


<a href="https://www.youtube.com/watch?v=xY9dQG4Sh6c">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/03-what-is-an-algorithm/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>So what is an algorithm in computer science? A good definition for an algorithm is a finite list of specific instructions for carrying out a procedure or solving a problem. If you think about it, every computer program we write consists of many different algorithms. Because as we&rsquo;ve learned, writing a computer program is exactly that. It&rsquo;s giving the computer a list of very specific instructions that we&rsquo;d like it to carry out so that it can perform a task or solve a problem for us. So let&rsquo;s look at an example of what an algorithm looks like. One of the most common algorithms used today is Euclid&rsquo;s algorithm. Euclid was a Greek mathematician from 300 B.C, and his algorithm was developed to find the greatest common divisor of two numbers. That greatest common divisor if you studied algebra is used to reduce fractions. And even today in our computers and calculators. We use a modified version of this algorithm to do exactly this task. It really is one of the most efficient ways to To do this, so let&rsquo;s explore what Euclid&rsquo;s algorithm looks like and take a look at an example.</p>
<p>So Euclid&rsquo;s algorithm consists of four simple steps. The first step is you start with two numbers labeled A and B. In the second step, if either of those numbers is zero, the answer is obviously the other number. However, if neither of those numbers is zero, we&rsquo;ll take the smaller number, and we&rsquo;ll subtract it from the larger number. Then we&rsquo;ll repeat those steps two through four until an answer is found. So what we will repeatedly do is take the larger number, subtract the smaller number from it, which will make the larger number smaller. And we repeat that process over and over and over again until we find an answer. So let&rsquo;s take a look at an example and see how this works. So let&rsquo;s look at an example of finding the greatest common divisor of 1071 and 462. So we&rsquo;ll start with our two numbers 1071 and 462. Now, we know that we need to label these numbers A and B. So I&rsquo;m going to label 1071 as A, and I&rsquo;m going to label 462. as B. In the algorithm, we see the first step is to see if either of these numbers are zero. So looking at these numbers, 1071 and 462, neither of them zero, so we can move on to Step three, which is subtracting the smaller number from the larger one. So we&rsquo;ll replace a with 1071. And we&rsquo;ll subtract 462 from that. And that will give us the result 609. So now our numbers are 609 and 462. Once again, we start over at step two, we see that neither of these numbers are zero. So we do the same thing again, A is still our larger number. So we&rsquo;ll do 609 minus 462 and we will get 147 and B will still be 462.</p>
<p>So we can keep repeating this process. Now B is the smallest number, so we&rsquo;ll do 462 minus 147 and we will get 315. Now we have 315, 315 is again, let the larger number, so we&rsquo;ll subtract 147 again, and this time we will get 168. And 168 is greater than 147 again, so we will subtract 147. And we will get, I&rsquo;ll go over here to a second column, we will get 21. So now our numbers are 147 and 21. So once again, we need to subtract 21 from 147. And I&rsquo;ll just kind of do this quickly. We&rsquo;ll get 126 then we&rsquo;ll get 105. Then we&rsquo;ll get 84, 63, 42. then we will get 21. And we&rsquo;ll notice that here, they&rsquo;re both the same number. So if we subtract that again, we&rsquo;ll get zero. And so now that we have zero as one of our numbers, we know that the greatest common divisor of 1071 and 462 is 21. This slide shows that example worked out a little bit clearer so you can follow it. If you&rsquo;re interested in the greatest common divisor algorithm written by Euclid, I encourage you to pick just two random numbers and see if you can perform this same process. It should work on any two random numbers you pick, but we were very careful in picking 1071 and 462. So we got a larger number as the greatest common divisor. Don&rsquo;t be surprised if you find out the answer is something small like two or three. That is pretty common as well.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="insertion-sort">Insertion Sort</h1>


<a href="https://www.youtube.com/watch?v=cz69Cjg4LUY">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/04-insertion-sort/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>In these next couple of videos, we&rsquo;re going to introduce the concept of sorting algorithms. Sorting algorithms are used when we want to arrange sets of data in order either from smallest to largest or largest to smallest in our computer programs. As it turns out, there are many different ways that we can sort our data using different algorithms. And each of those algorithms have unique characteristics that make them suitable for certain types of data in certain situations. To really explore sorting algorithms, we&rsquo;re going to perform these sorting algorithms using a deck of cards. So if you have access to a deck of cards, I encourage you to go find one and take out maybe 8 or 10 cards in a certain order. I have the cards Ace through 10 here, and you&rsquo;ll be able to follow along with our examples on these next few videos. Before we get started, I&rsquo;d like you to take the cards that you have selected, shuffled them up a little bit, and then lay them out in front of you and try and sort them in order from smallest to largest. And while you do that, I&rsquo;d like you to think in your mind about the exact steps that you&rsquo;re following. For example, are you looking for the smallest card and moving it to one side, or looking for the largest card and moving it to the other side? Or are you trying to arrange little bits of it at a time and slowly put those pieces together until they form the full sort of deck of cards, it might be really interesting to see how the method that you naturally follow matches up with one of these algorithms that we&rsquo;re going to take a look at. In particular, we&rsquo;re going to look at four different sorting algorithms, insertion Sort, bubble sort, merge, sort, and quicksort.</p>
<p>The first example is insertion sort. In insertion sort, there&rsquo;s basically three steps. And you can see in this graphic up above how they work. First, we&rsquo;ll choose an element from our array, and we&rsquo;ll place it in the correct place in our destination. So we go through we take the card, we put it where we want, and we repeat until our array is empty and we have completely sorted the cards. So let&rsquo;s take a look at it. An example of how to do that using a deck of cards. Let&rsquo;s take a look at how to use a deck of cards to simulate insertion sorts. Here I&rsquo;ve selected 10 cards out of a deck of cards, and I&rsquo;ve arranged them in a random order. If you want to follow along at home, feel free to grab either a suit out of a deck of cards, or you can grab just 10 cards in numerical order. In this case, I&rsquo;m using the ace is one at the low end of the scale. So to do insertion sort, all we have to do is take each value out of our initial array and place it where it would go in the final array. So the first value we&rsquo;ll have is a nine and we know that that needs to go in the 9th position here. Then we have the 4 we know that the 4 has to go before the 9. Now we have the 8 and we know that the 8 goes between the 4 and the 9. We get a three. It needs to go before the 4. We get to it goes before the three now we get a 5 the 5, does not go here does not go here, but it goes after the four. So we&rsquo;ll move all of these down and make room for the 5. The ace, of course goes here at the beginning, the 10, we look through, and we see that it goes all the way at the end. Then we have the seven, we see that goes here between the 5 and the 8. And then likewise, the sixth would go there as well.</p>
<p>So that&rsquo;s what insertion sort looks like when we as a person does it. But what if a computer was trying to do insertion sort? Let&rsquo;s take a look and see what that would look like. So now let&rsquo;s do Insertion Sort like a computer would do it. Instead of knowing exactly where the cards might go. A computer has to only compare two cards at a time and see what should go. So the computer would start by grabbing the 5 and placing it in our destination. Then the computer would grab the ace and say, does the ace go below or before the 5? It does. So we&rsquo;ll put the ace before the 5. That&rsquo;s all the computer does. Next, the computer grabs the three and says, &ldquo;Does the three go before the ace?&rdquo; Nope. Does the three go before the 5? Yes. So it would place the 3 before the 5. Then it would do the same thing for the 10. It would see does the 10 go before the ace? No. Does it go before the 3? No. Does it go before the 5? No, it goes at the end. So go ahead and see if you can do insertion sort and keep track of how many times you ask yourself does this card go before this card? Does this card go before this card that will give you an idea of how many steps it would take a computer to do insertion sorts a little bit later, we will analyze what that looks like using some complexity. The analysis with our algorithms doesn&rsquo;t go there doesn&rsquo;t go there doesn&rsquo;t go there doesn&rsquo;t go there must go at the end. And we can repeat this process for all the rest of these cards by going from the front to the back, and figuring out where each card belongs. That&rsquo;s an example of how to do Insertion Sort using a deck of cards. See if you can do it yourself and follow along and understand how this algorithm works.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="bubble-sort">Bubble Sort</h1>


<a href="https://www.youtube.com/watch?v=QAkhFY5r13A">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/05-bubble-sort/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>The next algorithm we&rsquo;re going to look at is bubble sort. Bubble sort might seem similar to Insertion Sort, but it&rsquo;s actually quite the different algorithm. So in bubble sort, what we will do is we will start by comparing two side by side elements in the list of data. And then if they&rsquo;re out of order, we will swap them. You can see in the animation above me how those two red boxes move to compare two side by side items. And if they&rsquo;re out of order, it will swap them just like so. Then we&rsquo;ll repeat that once we get all the way to the end of the array. We&rsquo;ll start back over at the beginning, and we&rsquo;ll go through it multiple times until it is entirely sorted. Or as the algorithm says here, we&rsquo;ll continue until we go all the way through the array and we don&rsquo;t make any more swaps. So let&rsquo;s go take a look at how to perform bubblesort using our deck of cards. The next algorithm we will look at is the bubble sort algorithm as we do bubblesort keep track of how many times you swap to different cards as that will become really important as we analyze these algorithms later on in this module.</p>
<p>So to do bubblesort, we start off by looking at the first two cards, the seven and the eight. And we ask ourselves are these two cards out of order, the seven should come before the eight. So we know that these two cards aren&rsquo;t out of order, so we won&rsquo;t do anything. Then we will shift one position over and look at these two cards, the eight and the four. And once again, we ask ourselves are these two cards out of order, the eight shouldn&rsquo;t go before the four. So they&rsquo;re out of order, and they need swapped. So that&rsquo;s one swap that we have done so far. Now we&rsquo;ll look at the eight and the two, we see that those are out of order. So we&rsquo;ll swap those that&rsquo;s two swaps. The eight also goes after the ace. So that&rsquo;s three stops, swaps. Then we have the eight goes after the three, which is four swaps. Now we&rsquo;re looking at the eight and the 10. And in this case, the eight does go before the 10 so We won&rsquo;t do anything here.</p>
<p>Now we&rsquo;ll look at the 10 and the nine, and we see that those are out of order and need swapped. And likewise, the 10 goes before goes after the six, and goes after the five. And so now we&rsquo;ve made it all the way through our list of cards. And we noticed that the highest card, the 10, has bubbled to the end of the list. And that&rsquo;s the really important part about bubblesort. Each time you go through, at least one more card should be bubbled to the correct spot at the end. So once we&rsquo;ve made it to the end, we&rsquo;ll start all the way over here at the beginning and try it again. So now we look at the seven and the four. Those are out of order and need swapped. We&rsquo;ll look at the seven and two. Those needs swaps. The seven in the ACE get swapped the seven and the three gets swapped, but now the seven and the eight don&rsquo;t get swapped. Likewise the eight and the nine are in the correct order, but the nine in the six are out of order. Needs swapped, and the nine and the five are out of order and need swaps.</p>
<p>So now we&rsquo;ve made it through twice. And we now have two cards, the nine and the 10 that have bubbled to the end of the array been placed in the correct order. So now we&rsquo;ll repeat this process once again, we see the four needs swapped with the two, the four and the ace needs swapped the four and the three needs swapped, the four and the seven are okay, the seven and the eight are okay, the eight and the six need swapped as well as the eight and the five. So now we have the eight in the right spots. We&rsquo;ll start over again. We&rsquo;ll put the ace in the two, the two and the three, right, the three and the four, right, the four and the seven are right, but the seven and the six are out of order. And the seven in the five are out of order. And now we have four cards in the right spot. And if we start over again, we&rsquo;ll notice the ace and tour Okay, two and three are okay, three and four. Okay, the four and the six are okay, but the six and the five out of order. And now we have five cards in order here. But look, we&rsquo;ve already got the array sorted even though we still had a few cards that we weren&rsquo;t sure about.</p>
<p>We know that if we went through it again, we would not make any swaps. And that&rsquo;s one of the powerful features of bubblesort is that once we make it all the way through our list of numbers without making a swap, we know that it&rsquo;s in the correct order, and we can stop working. See if you can do the bubble sort algorithm on your own using a deck of cards to understand how this algorithm works. And remember, while you do that, keep track of how many times you have to swap two numbers because that will help us in our analysis in the next video.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="complexity">Complexity</h1>


<a href="https://www.youtube.com/watch?v=Fiein5rZ-6M">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/06-complexity/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>So far, we&rsquo;ve looked at two different algorithms for sorting decks of cards, Insertion Sort, and bubblesort. So let&rsquo;s take a minute and try and decide which of those algorithms do you think is faster for a computer? a better question might be, which of those two algorithms was faster for you as it person to perform? Those are really tough questions to answer, aren&rsquo;t they? And so we need some way that we can analyze our algorithms and compare them apples to apples to see exactly which algorithm might be faster or more efficient on a computer. To do that, we use something called Big O notation. Unfortunately, when I refer to big O notation, I&rsquo;m not talking about the giant robot anime from the early 2000s. Instead, I&rsquo;m talking about the notation that we use to express the complexity of an algorithm. And specifically when we talk about complexity, we&rsquo;re talking about the number of steps required to perform the algorithm based on the worst case size of the inputs.</p>
<p>To understand worst case, let&rsquo;s consider the instance of bubble sort. So here are five different lists of cards that we could give as input to bubble sort. And let&rsquo;s say we want to sort them from two all the way on the far side to the ace over here on the near side. So the final order would be 2,3,4,5,6, all the way up to 10, jack, queen, king, ace. Looking at these five inputs, which one do you think would be the worst case for bubble sort. So of course, we can analyze this. And if we count the steps required to perform bubble sort, we&rsquo;ll find that the fourth input is the worst case. And if we look closely at that output, we see something very unique. It turns out that that output is actually the deck of cards sorted completely backwards. And so that means that every step it would need to swap two cards that are out of order. So the first time through is bubble sort. We will bubble the ace all the way up to the end, which will require 12 swaps. Then the king which will be 11 swaps, then the queen, which will be 10, then nine, then eight, so on all the way until we get it sorted. And if we add that all up, it turns out that we make 78 swaps in order to sort that deck of cards.</p>
<p>So the important part of big O notation is not finding that for a specific input, but finding that answer for a number of inputs and then graphing them. So this is a graph that shows along the bottom the size of the input in terms of the number of cards, and on the side, we have the number of steps that it takes to perform bubblesort. And so if we look at that graph, where there is 13 at the bottom, which is one suit of cards, we can go up and we see that 78 is about where that is. So if we look at this line, what sort of a function would we use in mathematics to create this line. As it turns out, this line follows the polynomial x^2. So we would say that insertion sort and bubblesort both run in big O of n^2. That means that for every n inputs, we expect it to take around n squared steps in order to solve the problem. Now you&rsquo;ll notice that there are two more algorithms on this slide that we haven&rsquo;t talked about yet. mergesort and quicksort.</p>
<p>Do you suppose that there is a way that we can sort a deck of cards that is faster than big O(n^2)? A good way to think of n^2 is n^2 means that we would take every card and compare it to every other card in times in which is n squared. Can we do that faster? Let&rsquo;s take a look at mergesort and quicksort. And see if that&rsquo;s possible.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="merge-sort">Merge Sort</h1>


<a href="https://www.youtube.com/watch?v=gqnlpFmShOw">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/07-merge-sort/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>The next algorithm we&rsquo;re going to look at is merge sort. Merge Sort is a very unique algorithm because it&rsquo;s an example of the divide and conquer paradigm of creating algorithms. In fact, Merge Sort was actually written way back in the 1950s and 60s to allow us the ability to sort data that didn&rsquo;t even fit on a single data storage media at the time. So for example, with merge sort, we could sort the data on three different disks full of data very independently and very efficiently. The process for merge sort is pretty simple. We start by taking our data and splitting it in half, and we keep repeatedly splitting it in half until we get down to one or two items. Then we make sure those items are in order, and then we will merge those two items together all the way down until we get to our final results. So let&rsquo;s take a look at how we can perform Merge Sort using our deck of cards. The next sorting algorithm we&rsquo;ll look at is merge sorts. Remember that merge sort is a divided conquer algorithm. So it takes place in two phases. The first phase is the divide phase.</p>
<p>So we&rsquo;ll start with our set of 10 cards, and we need to divide it in half. So we&rsquo;ll have one group of five cards over here. And we&rsquo;ll have one group of five cards over here. Then we&rsquo;ll repeat that process for each group. So we&rsquo;ll look at this group, and we&rsquo;ll divide it in half, we&rsquo;ll have a set of three cards, and a set of two cards. Likewise, here, we will have a set of three cards, and a set of two cards. And finally, these groups of three can be divided once again into a set of two and a set of one. And likewise here, we&rsquo;ll have a set of two and a set of one. So now we&rsquo;ve divided all of our groups into sets that are at least two cards or smaller. The next phase is to actually sort each of these individual groups by swapping the cards If needed, so let&rsquo;s look at each group, the two and the four are out of order. And so we will swap them. So the two comes before the four. Since 10 only has one card, we don&rsquo;t do anything, the six and the nine are in the correct order, as are the three in the seven, the eight is all by itself, so we don&rsquo;t need to swap anything. And finally, the five and the ace are also out of order, so we will swap them.</p>
<p>So in total, we only did two swaps, we only had to swap two of the possible four pairs of cards that we could swap, but that&rsquo;s all we really have to do. The last part of merge sort the conquer phase is where we merge all of these groups back together in sorted order. To do that, we pick two groups. And usually we just go down the row and we merge them back together by choosing the smallest card at the front of the group and putting it back in the destination. So with these two groups, we know that the two is the smallest. So it will go down first, then the four, then the 10. Likewise, we have this group over here, we know the three is the smallest, followed by the seven, followed by the eight. So now we have undone the division step that divided these into smaller bits. Now we&rsquo;ll do the merge step where we merge these two groups together, and these two groups together. So once again, we will look at the front card in each of our two and see which one&rsquo;s smaller. In this case, it&rsquo;s the two. So the two goes first, followed by the four than the six than the nine, and finally the 10.</p>
<p>And so you can see that actually, a lot of the sorting happens in this merge phase more than anything else. Likewise, we can do the merge phase over here, where the ace will come first than the three, then the five, then the seven, and the eight. So we&rsquo;re almost there, we have one more set of merging that we need to do. And so once again, we&rsquo;ll look at the front card and each one, and we will see which one is smaller and merge it first, so the ace is smaller, so it will go first, followed by the two, then we&rsquo;ll have the three. Now we&rsquo;re looking at the four and the five, we take the four, the five and the six, we would take the five. Likewise, we would take the six before the seven than the seven before the nine, the eight before the nine. And then finally, the nine and the 10. Go here at the end.</p>
<p>And so that&rsquo;s how we perform merge sorts. We divide everything out, we swap if needed, and then we conquer by doing that merge step to merge everything back together. And as we merge, we find that that&rsquo;s where a lot of the sorting happens by putting things back together using the front element, whichever is smaller until we get into sorted order. So once again, see if you can do merge sort on your own using Your own deck of cards and keep track of how many swaps you make and how many times you have to merge things back together. And we&rsquo;ll use that in our analysis in a later video.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="quick-sort">Quick Sort</h1>


<a href="https://www.youtube.com/watch?v=4JAZLBriCFY">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/08-quicksort/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>The last sorting algorithm we&rsquo;re going to look at is quicksort. Quicksort is the newest of these algorithms being first published in 1961. Quicksort is a little bit different than the other sorting algorithms, because it requires us to choose a pivot element from the list and then sort based off of that pivot elements, it&rsquo;s really kind of hard to understand conceptually without seeing it in action. So let&rsquo;s take a look at how we perform quicksort using our deck of cards. The last sorting algorithm we&rsquo;ll look at in this class is quicksort. Quicksort is a very unique algorithm. It&rsquo;s like a divide and conquer algorithm, but it has some really interesting quirks and how it works that make it work really fast with random data. So let&rsquo;s take a look at how quicksort works and see if we can get it to sort our deck of cards. The first step in quicksort is to choose a pivot element. And this is actually one of the key things about quicksort is choosing a pivot element most quicksort algorithm Don&rsquo;t even put any thought into it, they just pick the last element or the first element in the list and call that the pivot.</p>
<p>So we&rsquo;re going to take our six, and we&rsquo;re going to call that our pivot element. Then we simply go through all the rest of the cards and sort them into two piles. All of the cards that are less than six go on one side, and all of the cards that are greater than six, go on the other side. And you notice that I&rsquo;m not changing the order at all, I&rsquo;m not doing any other sorting in those groups. I&rsquo;m just putting them into those groups in the order that they come. So now we have our six that was our pivot elements, we have all of the items that are less than six on one side, and we have all of the items that are greater than six on the other side. This is where the divide and conquer part comes into this algorithm. We will do the same thing for each of these two groups. We&rsquo;ll choose the pivot element, which is the last card and we will sort in this case the pivot element is five and all of the rest of Have the cards are less than five. So we don&rsquo;t really gain a whole lot there, we just move this down to the next group. Here, we would choose the pivot element has eight. And so we would end up sorting the seven and the nine after the eights are, my my apologies, we would end up sorting the nine to 10 after the eight, whereas the seven would go before us.</p>
<p>So now we can do this again, we&rsquo;ll pick this item as our pivot. And we will notice that very quickly, the ace goes before the three and the four. And notice I&rsquo;m not changing anything else, I&rsquo;m just arranging them in the order that they come. So now we&rsquo;ve had six as a pivot, we&rsquo;ve had five as a pivot to as a pivot, and eight as a pivot. So now we need to look at the other groups. We have a single group here, so that would become the pivot and gets locked in place. We have a group of two here where that becomes the pivot and gets locked into place. We have a group of one here where that becomes a pivot, and we have a group of two here where that becomes the pivot And now we can lock the others in place. And tada, it&rsquo;s already sorted. That seemed to go very, very quickly.</p>
<p>So let&rsquo;s shuffle this up and try again and see if quicksort really is just that fast. So let&rsquo;s walk through quicksort. Again very quickly and see if it works just like we think. We&rsquo;ll start by selecting our pivot element as three. And then we will put all of the elements that are greater than three on one side. And again, I&rsquo;m not changing the order of them, I&rsquo;m just grabbing them as they come. And then we&rsquo;ll put all of the elements that are less than three on the other side. So now we&rsquo;ve divided and we&rsquo;ve set it up like that, in this item, we have two, so the two will become the pivot, the ace doesn&rsquo;t move and an ace becomes the pivot. We&rsquo;re already done with that side. Here are the four will become the pivot, and we know that everything is greater than the four after we look at It so the four will get locked in over here. The six will become the next pivot, and we will shuffle things around such that the six is in the correct spot. The five is a single so it&rsquo;s going to get locked in place, we&rsquo;ll choose the seven is the pivot, everything is greater than seven, it will get locked in place, which is the eight is the pivot, it will get locked in place, then we will choose the 10 is the pivot and finally the nine will get locked.</p>
<p>So again quicksort works very quickly. But let&rsquo;s take a look at an example where quicksort may not work as well. And then in the later video, we&rsquo;ll analyze why that doesn&rsquo;t work. Alright, so now we have one more list of cards that we&rsquo;re going to start with quicksort. And obviously, looking at this, you realize immediately that this is sorted, but the computer would know that without checking, so we&rsquo;re going to do our quicksort algorithm and see what happens. So we&rsquo;ll pick the 10 as the first pivot, and we&rsquo;ll put everything less than 10 on one side and everything greater than 10 on the other side, and we noticed that everything left is less than 10. So nothing moves. So now we&rsquo;ll do the nine. And now we&rsquo;ll have to do the same thing by looking at every single card and making sure that it&rsquo;s less than nine, and it is, and then we&rsquo;ll do eight, and we&rsquo;ll make sure that everything is less than eight. And it is we&rsquo;ll do seven, we&rsquo;ll make sure everything is less than seven.</p>
<p>And as we go through this process, you&rsquo;ll notice that this feels an awful lot like so, like Insertion Sort. We&rsquo;re comparing each card to each other card and trying to figure out where it fits. And so as it turns out, quicksort has this really weird Worst case where if the data is already sorted quicksort is actually very inefficient. And it runs pretty much the same as Insertion Sort with a few extra steps. So in the next video, we&rsquo;ll do some analysis of mergesort and look at its complexity. And then we&rsquo;ll also look at the complexity of quicksort and see why it has this really bad worst case.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="complexity-part-2">Complexity Part 2</h1>


<a href="https://www.youtube.com/watch?v=j1sJiv5hVtc">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/09-complexity-2/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>So now that we&rsquo;ve learned about merge sort and quicksort, let&rsquo;s take a look at the complexity of one of these algorithms. Just to understand how that works. For this example, we&rsquo;re going to look at the complexity of merge sort. Let&rsquo;s consider the example where we&rsquo;re doing merge sort on eight numbers. So here we have the numbers 1,2,3,4,5,6,7,8. So the first step of Merge Sort would have us divide those in half into groups, 1,2,3,4, and group 5,6,7,8, then we would divide each of those in half again, ending up with four groups 1-2,3-4,5-6, and 7-8t. So this diagram helps us understand the complexity of this algorithm. And we need to measure two things. We need to measure how many swaps it can make, and then we need to measure how many divisions it makes. So let&rsquo;s look at swaps first, these are all in the correct order, but we have to assume worst case. So in the worst case, we would make 1,2,3,4 swaps. So we know we need four swaps for one of our numbers. And we need to compare that to the size of the input, which is eight. So how does four compared to eight, an easy way to think of it is four is just our input size eight divided by two. That&rsquo;s pretty easy. The second step is a little trickier. Because what we need to do is we need to look at how many times we have to divide the numbers to get all the way down to groups of two. And in this case, we have three levels. So we have three here, but how does three compared to eight?</p>
<p>That&rsquo;s a little trickier to answer. But let&rsquo;s think about what it would look like if we had four levels. How many numbers would we need to get all the way to four levels and fill four levels all the way up? As it turns out, to do that we would need to double the amount of numbers we would need to have 16 in order to fill up four layers. So how does three relate to eight in the same way that four relates to 16? This can be kind of tricky, but it actually lies in the idea of powers. Consider this, two to the power of three is eight. And likewise, two to the power four is 16. That&rsquo;s where our answer lies. And it actually makes sense. We&rsquo;re dividing these in half. And we do that three times for eight numbers. Likewise, if we&rsquo;re dividing it in half, we would do it four times to get the 16 numbers. So how do we express this in terms of our number eight? This relies on a little bit of algebra and calculus, but the answer is in logarithms, and so this would be the logarithm of base two of N. And so that tells us that two to Two the whatever it is, is equal to eight. So we can put this all together by combining in divided by two and log base two event. And usually when we do this, we ignore the divided by two. And so we just end up with the answer in times log of in. And here specifically, we&rsquo;re using lg as the shorthand for log base two. If you&rsquo;re familiar with calculus, you know that In is log of e.</p>
<p>In computer science, we usually use lg as a shorthand for log base two. So as you can see, based on this analysis, mergesort runs in the complexity of nlog(n) if we graph that we find that nlog(n) is actually quite a bit shorter than n^2, meaning that as the input gets larger, Merge Sort will take many fewer steps to complete, then algorithms such as bubble sort, and Insertion Sort. Quicksort is a little bit difference. Quicksort has this really interesting worst case, where if the numbers are already sorted, and you always pick the pivot item as the last element in the list, then you&rsquo;ll end up basically doing Insertion Sort every single time. And so it&rsquo;s worst case is actually big O of n^2. However, in practice, if you pick a pivot item that is close to the middle of your input, then the average case for quicksort is big O of nlog(n) and in practicality, quicksort is usually the fastest of the sorting algorithms on random input data. So let&rsquo;s take that idea a little bit further, we can look at these different sorting algorithms and determine exactly when they might be useful.</p>
<p>For example, Insertion Sort might be pretty useful in certain cases where there&rsquo;s a small set of numbers, or maybe while we&rsquo;re getting numbers one at a time and we just want to insert them in the proper place in an array bubblesort is really useful when we know the data is nearly sorted, because we only have to bubble a few items around till we get to the point where bubblesort has Completed because there&rsquo;s no more swaps to make. Merge Sort is really good when we know nothing about our data, or if we&rsquo;re worried about the size of our data not being big enough, or not being small enough to fit in memory. And of course, quicksort besides that really bad worst case is generally the fastest performing algorithm. So as long as we&rsquo;re sure that we&rsquo;re not going to run into that worst case, very often, we can generally use quicksort as a really great sorting algorithm in our code.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="heuristics">Heuristics</h1>


<a href="https://www.youtube.com/watch?v=s0Lck_HNAJA">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://ksu-cs-textbooks.github.io/cs-zero/i-concepts/06-algorithms/10-heuristics/../slides/6-Algorithms.pdf">Slides</a>
</li>
</ul>
<h4 id="video-script">Video Script</h4>
<p>So far in this module, we&rsquo;ve studied algorithms, and remember that an algorithm is a specific set of steps that we can use to solve a problem. However, what if we&rsquo;re faced with a problem that we can&rsquo;t solve? Either because it&rsquo;s impossible, or because we have so much data that we can&rsquo;t possibly find the one right answer using an algorithm. In that case, we would use something we call a heuristic. A heuristic is an experience based technique we can use to find a satisfactory solution to a problem, which may or may not be the absolute best solution to that problem. For example, if we have a particular person, and we&rsquo;d like to know what their height is, we could actually get out a tape measure and measure it. Or we could use a heuristic and say, well, you&rsquo;re standing next to that door and you look like you&rsquo;re about six feet tall. That would be an experience based technique or a heuristic to estimate how tall someone is. We of course, use heuristics every day. For example, we use the rule of thumb when Trying to measure things. We can take educated guesses based on our previous experience, we can use our common sense and find answers that seem logical. We can try an answer and see if we can work backwards and prove that that is an answer to the question. Or we can even take our problem and try and do a simpler problem first and use that information to solve our larger problem.</p>
<p>The whole idea of heuristics lies in this graph on trade offs. This graph is very common in business circles. For example, in a business, it&rsquo;s usually said that you can have fast good or cheap, pick two. So you can have things that are fast and good. You can have things that are fast and cheap. And you can have things that are good and cheap, but not necessarily fast. I usually like to apply this diagram to fast food. You can think about your favorite fast food restaurants and place them somewhere in this diagram. Are they fast and good, but not necessarily cheap? Are they fast and cheap, but maybe not the best food you&rsquo;ve had? Or are they good and cheap, but sometimes it takes a little bit to get your food It&rsquo;s really interesting to think about this diagram and the different things that we interact with in the world. Algorithms usually lie on the scale of good, they find the one right answer. They may be fast. They may be cheap in terms of memory or processor usage, but they generally will find the one right answer. For heuristics, we&rsquo;re looking closer to the fast and cheap side of this diagram, we can find an answer that is quick and we can find one that is very cheap to compute, but it may or may not be as good as the one right answer we could find using an algorithm. We just hope that it&rsquo;s good enough to be useful for our needs.</p>
<p>Let&rsquo;s take a look at one common problem in computer science and see how we can apply a heuristic to solve this problem is called the Traveling Salesman Problem. The idea behind the Traveling Salesman Problem is that everyday a salesman has to set out from home and would like to visit all the towns on the map and make it home as soon as possible. And so here we have a very simple map that contains four towns and edges between the towns are the roads that are labeled with the distance between each town. So looking at this map, can we find a way that we can find a route between all four of these towns that is the shortest as possible. There are some algorithms that we can use to solve this problem. For example, we could use a brute force algorithm, we can just compute every possible path, which would be in the time of big O of n!. If you know what factorial is, you know that that&rsquo;s a very big number. For example, eight factorial would require 40,320 steps to solve this problem. It&rsquo;s a very, very, very large number. You using some advanced programming techniques, such as dynamic programming, we can cut this algorithm down to big O of 2^n, which is still a big number for eight cities that requires 256 steps, but it&rsquo;s not easy and it&rsquo;s not cheap to perform. However, there is this really cool heuristic that we can use.</p>
<p>For the Traveling Salesman Problem. We can just pick any city as our City. In this example, we&rsquo;ll use B. And then we&rsquo;ll just go to the next closest city we haven&rsquo;t been to yet. And from that city will go to the next closest city from there. And we&rsquo;ll repeat this process until we visited all of the cities. So here&rsquo;s a graphic showing what the greedy solution might look like. We start at City B, and we noticed that City A is the closest city that we haven&rsquo;t been to, then from A, we can either go 42 miles to city C, or 35 miles to city D. So we&rsquo;ll go 35 miles to city D. And finally, from there, the only city we haven&rsquo;t been to a C, and so that will get us all of our diagram. So this solution requires 67 miles to complete the path is this the fastest way we could visit all four cities. As it turns out, there is a better solution to this. We&rsquo;ll look at that in just a minute. So this greedy algorithm runs in big O of (d*n) where d is the number of dimensions in the graph and ins the number of cities. So on a two dimensional graph with eight cities We would have 16 steps. That&rsquo;s much, much less than the 256 or 40,000 steps that we saw in an earlier example. Now, of course, the time that it takes to do this can vary widely based on how the data is presented and how it&rsquo;s sorted. But this is a pretty simple example. And actual optimal solution to this problem would require us to start at either city A or C,B,D. And of course, here we find an optimal solution of 62 miles.</p>
<p>So why is the Traveling Salesman Problem so important in computer science? Well, let&rsquo;s consider one use of this problem, which is deliveries. For example, delivery companies, such as Amazon and UPS and FedEx and the United States Postal Service basically have to solve the Traveling Salesman Problem every single day. They have a set of locations that they need to visit, and they want to visit those locations in the most efficient way possible. And so these companies have invested lots of time and resources in computer systems that can help them solve this problem very efficiently. They come up with some very unique solutions. For example, there&rsquo;s some information online about how ups, for example, solves this problem such that its trucks don&rsquo;t have to make many left turns, because they found that the time they spent waiting at a turn before they can make a left turn is wasted. And so they try and build the routes in such a way that they&rsquo;re always making right turns so that it&rsquo;s very quick and efficient. So heuristics are just one example of ways that we can solve problems in computer science without using a particular algorithm that gets the right answer. Of course, heuristics are just another form of an algorithm. But the important thing to remember is with a heuristic we&rsquo;re trying to find a best answer that may not exactly be the most correct answer possible. But heuristics are at the core of a lot of what we do in computer science today, such as artificial intelligence and machine learning. All of the things that are related to that build upon this idea of heuristics, we&rsquo;re trying to find an answer that seems most likely, which may or may not be the actually correct answer that we&rsquo;re thinking of.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="pattern-on-the-stone-reading">Pattern on the Stone Reading</h1>

<p>Read Pattern on the Stone, Chapter 5.</p>

            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cs-zero/-/commit/c80453205407381a0e84aa3f8c8e12ac91f73e2c">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/clipboard.min.js?1693232208" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/perfect-scrollbar.min.js?1693232208" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cs-zero/js/theme.js?1693232208" defer></script>
  </body>
</html>
