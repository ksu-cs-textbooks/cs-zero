<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Let’s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.
Don’t sweat it! This is a lot of conceptual information to digest at once. However, we don’t expect you to become proficient in this right away! This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you’ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science."><meta name=author content="K-State CS Faculty"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><meta name=twitter:title content="Deeper Dive :: Intro CS Textbook"><meta name=twitter:description content="Let’s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.
Don’t sweat it! This is a lot of conceptual information to digest at once. However, we don’t expect you to become proficient in this right away! This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you’ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/index.html"><meta property="og:site_name" content="Intro CS Textbook"><meta property="og:title" content="Deeper Dive :: Intro CS Textbook"><meta property="og:description" content="Let’s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.
Don’t sweat it! This is a lot of conceptual information to digest at once. However, we don’t expect you to become proficient in this right away! This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you’ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="CS Concepts"><meta property="article:modified_time" content="2026-01-07T10:02:21-06:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><meta itemprop=name content="Deeper Dive :: Intro CS Textbook"><meta itemprop=description content="Let’s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.
Don’t sweat it! This is a lot of conceptual information to digest at once. However, we don’t expect you to become proficient in this right away! This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you’ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science."><meta itemprop=dateModified content="2026-01-07T10:02:21-06:00"><meta itemprop=wordCount content="3191"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><title>Deeper Dive :: Intro CS Textbook</title><link href=https://textbooks.cs.ksu.edu/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/index.html rel=canonical type=text/html title="Deeper Dive :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/index.xml rel=alternate type=application/rss+xml title="Deeper Dive :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/tele.html rel=alternate type=text/html title="Deeper Dive :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/embed.html rel=alternate type=text/html title="Deeper Dive :: Intro CS Textbook"><link href=/cs-zero/css/auto-complete/auto-complete.min.css?1767801774 rel=stylesheet><script src=/cs-zero/js/auto-complete/auto-complete.min.js?1767801774 defer></script><script src=/cs-zero/js/search-lunr.min.js?1767801774 defer></script><script src=/cs-zero/js/search.min.js?1767801774 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cs-zero/searchindex.en.js?1767801774"</script><script src=/cs-zero/js/lunr/lunr.min.js?1767801774 defer></script><script src=/cs-zero/js/lunr/lunr.stemmer.support.min.js?1767801774 defer></script><script src=/cs-zero/js/lunr/lunr.multi.min.js?1767801774 defer></script><script src=/cs-zero/js/lunr/lunr.en.min.js?1767801774 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cs-zero/fonts/fontawesome/css/fontawesome-all.min.css?1767801774 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/fonts/fontawesome/css/fontawesome-all.min.css?1767801774 rel=stylesheet></noscript><link href=/cs-zero/css/perfect-scrollbar/perfect-scrollbar.min.css?1767801774 rel=stylesheet><link href=/cs-zero/css/theme.min.css?1767801774 rel=stylesheet><link href=/cs-zero/css/format-print.min.css?1767801774 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/index.html",window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cs-zero",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cs-zero/css/custom.css?1767801774 rel=stylesheet></head><body class="mobile-support embed print" data-url=/cs-zero/i-concepts/03-bits-and-boolean-algebra/07-deeper-dive/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable i-concepts" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=deeper-dive>Deeper Dive</h1><p>Let&rsquo;s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.</p><details open class="box cstyle notices tip"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-lightbulb"></i>
Don&rsquo;t sweat it!</summary><div class=box-content><p>This is a lot of conceptual information to digest at once. However, we <strong>don&rsquo;t expect you to become proficient in this right away!</strong> This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you&rsquo;ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science.</p><p>For now, we just want to introduce the topic and give you a chance to try it out in the quiz at the end of this module. If you don&rsquo;t do well on the quiz, <strong>don&rsquo;t sweat it!</strong></p><p>This material is handy if you want to review the concepts or get in some practice, but the best way to learn is to just keep doing examples and practicing as you learn to code.</p></div></details><h2 id=key-idea-truth-table--venn-diagram>Key Idea: Truth Table &lt;=> Venn Diagram</h2><p>When working with Truth Tables and Venn Diagrams, the key idea to remember is that each line in the Truth Table corresponds to exactly one space in the Venn Diagram.</p><p><a href=#R-image-fe7279b5720190bff918c2a4d7d20141 class=lightbox-link><img alt="Three Variable Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/three-variable-venn-diagram.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-fe7279b5720190bff918c2a4d7d20141><img alt="Three Variable Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/three-variable-venn-diagram.png></a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>Each labelled section in the Venn Diagram above corresponds to the variables that are <code>True</code> or <code>1</code> in the corresponding Truth Table. We can even draw arrows directly from each line in the Truth Table for Example 1 to the Venn Diagram:</p><p><a href=#R-image-84a924ab5f733e5ee2d0546add5d1c4b class=lightbox-link><img alt="Match Venn Diagram to Truth Table" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/venn_match.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-84a924ab5f733e5ee2d0546add5d1c4b><img alt="Match Venn Diagram to Truth Table" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/venn_match.png></a></p><p>So, if the &ldquo;OUT&rdquo; column in the truth table is <code>True</code> or <code>1</code>, that section of the Venn Diagram becomes shaded and is part of the desired output. Therefore, if you have a Venn Diagram or Truth Table, the conversion between the two is a direct one-to-one connection. Here&rsquo;s what that looks like for Example 1:</p><p><a href=#R-image-1cf3bfbed34281797d533e92869f83a4 class=lightbox-link><img alt="Example 1 Truth Table and Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/venn_match2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-1cf3bfbed34281797d533e92869f83a4><img alt="Example 1 Truth Table and Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/venn_match2.png></a></p><h2 id=creating-a-boolean-logic-expression>Creating a Boolean Logic Expression</h2><p>Once we understand either the Truth Table or Venn Diagram for a desired Boolean Logic expression, we can use that information to start building the Boolean Logic expression itself. This can be done in one of three ways:</p><ol><li>We can convert each line in the Truth Table or each shaded section of the Venn Diagram to a single Boolean Logic term that uses all available variables, and then use the rules of Boolean Algebra to reduce the expression to simpler terms. This is generally more comfortable for those who are already well versed in math and algebra, but others may struggle to properly reduce these terms directly on paper.</li><li>We can use a bit of intuition about the Venn Diagram or the real-world scenario we are trying to model to combine adjacent shaded sections of the Venn Diagram together into simple Boolean Logic terms and connect them together. This is what we show in the worked example video, but it does take a bit of experience to become comfortable with this process.</li><li>We can use <a href=https://en.wikipedia.org/wiki/Karnaugh_map rel=external target=_blank>Karnaugh Maps</a> to directly reduce the statement and produce a Boolean Logic expression. This is typically done in introductory logic circuit design courses in computer engineering, but we rarely teach it anymore in computer science. It is a handy method to know, especially for larger numbers of variables.</li></ol><p>So, let&rsquo;s go through these three methods and see how they relate.</p><h3 id=method-1---using-boolean-algebra>Method 1 - Using Boolean Algebra</h3><p>Let&rsquo;s start by directly converting the information in our Truth Table and Venn Diagram to individual Boolean Logic terms. To do this, look at each row in the Venn Diagram where the &ldquo;OUT&rdquo; column is 1. Then, for each variable in that row, we either include it in the term directly if it is a <code>True</code> or <code>1</code> in the input, or else we include it with a NOT symbol ($\neg$) before the variable if it is a <code>False</code> or <code>0</code> in the input. We <strong>must</strong> include these false variables in our terms, or else we would get different results (i.e. $A \wedge B$ is <strong>not</strong> the same as $A \wedge B \wedge \neg C$)</p><p>So, we would end up with these three terms from our truth table above:</p><ol><li>A is false but B and C are true: $ \neg A \wedge B \wedge C$</li><li>B is false but A and C are true: $ A \wedge \neg B \wedge C$</li><li>A and B and C are true: $ A \wedge B \wedge C$</li></ol><p>Finally, our full Boolean Expression using these three terms would combine them using the OR ($\vee$) symbol. This is because the &ldquo;OUT&rdquo; column in the Truth Table is <code>True</code> or <code>1</code> if <strong>any one or more</strong> of these terms are <code>True</code>. So, our resulting Boolean Expression at this point would be the following:</p><p>$$
(\neg A \wedge B \wedge C) \vee (A \wedge \neg B \wedge C) \vee (A \wedge B \wedge C)
$$</p><p>At this point, we can stop if we don&rsquo;t care about reducing the expression to simpler terms. So, once again, there is a direct one-to-one translation from either a Truth Table or Venn Diagram to a Boolean Logic expression that is in this form. In fact, this form is known as the <a href=https://en.wikipedia.org/wiki/Disjunctive_normal_form rel=external target=_blank>Disjunctive Normal Form</a> of a Boolean Logic expression (though it is not the reduced form). A great way to remember this form is that it is an <strong>OR</strong> of <strong>ANDs</strong> (the individual terms are all <strong>AND</strong> operators, and then the terms are combined using <strong>OR</strong> operators).</p><p>Before we go any further, we can check our work by entering this formula into <a href=https://www.wolframalpha.com/ rel=external target=_blank>Wolfram Alpha</a> and checking the Venn Diagram and Truth Table it produces and make sure they match our original setup. While it is possible to enter all of the fancy Boolean Logic symbols into Wolfram Alpha (it does understand them), it is often easiest to just convert them to their English counterparts as shown below:</p><div class=highlight dir=auto><pre tabindex=0><code>(NOT A AND B AND C) OR (A AND NOT B AND C) OR (A AND B AND C)</code></pre></div><p>You can also click <a href="https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29" rel=external target=_blank>this link</a> to go directly to Wolfram Alpha with this input provided.</p><p>First, we can check that our input is parsed correctly since it matches our Boolean Logic expression at the top:</p><p><a href=#R-image-3dc16c5607b4fc7dbba11e2ecec29cc6 class=lightbox-link><img alt="Wolfram Alpha Boolean Expression" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3dc16c5607b4fc7dbba11e2ecec29cc6><img alt="Wolfram Alpha Boolean Expression" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram1.png></a> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>We can also look at the Truth Table and Venn Diagrams further down:</p><p><a href=#R-image-f6a66bd719e2bbd96f8701a9f57cc659 class=lightbox-link><img alt="Wolfram Alpha Truth Table" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f6a66bd719e2bbd96f8701a9f57cc659><img alt="Wolfram Alpha Truth Table" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram2.png></a> <sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>
<a href=#R-image-77982f6387fd5349799bb692decef315 class=lightbox-link><img alt="Wolfram Alpha Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-77982f6387fd5349799bb692decef315><img alt="Wolfram Alpha Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram3.png></a> <sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>Notice that the Truth Table is ordered a bit differently than what we see above (it is reversed), and the Venn Diagram is rotated a bit, but hopefully it becomes pretty clear that we have a match! So, our translation from the Truth Table to a Boolean Logic Expression is valid!</p><h4 id=method-1a---reducing-expressions>Method 1A - Reducing Expressions</h4><p>Once we have a valid Boolean Logic Expression, we can use the laws of Boolean Algebra to reduce it. We cover some of these laws earlier in this chapter, but <a href=https://en.wikipedia.org/wiki/Boolean_algebra rel=external target=_blank>Wikipedia</a> has a good listing of them as well. We&rsquo;ll refer to the laws as they are described in Wikipedia as we perform these operations.</p><p>First, it is often very helpful to remember that, in many cases, <code>AND</code> ($\wedge$) can be treated similar to multiplication ($\times$), while <code>OR</code> ($\vee$) can be treated like addition ($+$). So, in some fields (such as computer engineering), it is common to rewrite the statement above like this:</p><p>$$
(\neg A B C) \vee (A \neg B C) \vee (A B C)
$$</p><p>This may make some operations more intuitive, especially where we are &ldquo;factoring out&rdquo; or &ldquo;distributing&rdquo; a term by applying the <strong>Distributivity</strong> laws. So, we&rsquo;ll use this modified notation while performing our Boolean Algebra reductions.</p><p>Unfortunately, reducing this expression is actually a bit complex, because there is not an obvious starting place. Instead, what we need to do first is duplicate a term by applying the inverse of the <strong>Idempotence of $\vee$</strong> law. This law states that $ x \vee x = x $, so we can invert it by replacing any single term $x$ with two instances of the term that are connected with the <code>OR</code> ($\vee$) operator. We&rsquo;ll do this to the last term in the expression for now:</p><p>$$
(\neg A B C) \vee (A \neg B C) \vee (A B C) \vee (A B C)
$$</p><p>Next, we want to group some similar terms together to make later operations a bit more obvious. So, we&rsquo;ll apply the <strong>Commutativity of $\vee$</strong> law to rearrange the terms, and also use the <strong>Associativity of $\vee$</strong> law to group some terms together:</p><p>$$
\Big( (\neg A B C) \vee (A B C) \Big) \vee \Big( (A \neg B C)\vee (A B C) \Big)
$$</p><p>Now we can start to simplify things a bit. In both groups of terms, we notice that they each share the variable $C$, so we can apply the inverse of the <strong>Distributivity of $\wedge$ over $\vee$</strong> law to &ldquo;factor out&rdquo; that term. Notice that this is very similar to how we can apply a similar law in ordinary algebra:</p><p>$$
\Big( C \wedge \big((\neg A B) \vee (A B) \big) \Big) \vee \Big( C \wedge \big( (A \neg B)\vee (A B) \big) \Big)
$$</p><p>After that, we&rsquo;ll see that the first pair of remaining terms shares the variable <code>B</code>, while the second pair of terms shares the variable <code>A</code>. So, we can once again apply the <strong>Distributivity of $\wedge$ over $\vee$</strong> law to &ldquo;factor out&rdquo; those shared terms in each pair:</p><p>$$
\Big( C \wedge \big(B \wedge (\neg A \vee A) \big) \Big) \vee \Big( C \wedge \big(A \wedge (\neg B \vee B) \big) \Big)
$$</p><p>Now we can start to remove some terms. The <strong>Complementation 2</strong> law in Wikipedia states that $x \vee \neg x = 1$, which means that we can replace a term and the inverse of that term connected with an OR ($\vee$) operator with the value <code>True</code> or <code>1</code>. We&rsquo;ll do this for both $A$ and $B$ terms:</p><p>$$
\Big( C \wedge \big(B \wedge 1 \big) \Big) \vee \Big( C \wedge \big(A \wedge 1 \big) \Big)
$$</p><p>Next, we can use the <strong>Identity for $\wedge$</strong> law, which states that $x \wedge 1 = x$, to effectively remove those <code>True</code> or <code>1</code> terms from the statement. Again, remember that in regular algebra, we would know that the term $1A$ would be equivalent to just $A$, so if we rewrite $A \wedge 1$ as just $1A$ and then just $A$, it feels very logical!</p><p>$$
( C B ) \vee ( C A )
$$</p><p>Finally, if desired, we can apply the <strong>Distributivity of $\wedge$ over $\vee$</strong> law one more time to &ldquo;factor out&rdquo; the $C$ variable again:</p><p>$$
C \wedge (B \vee A)
$$</p><p>There we go! Both of those reductions are valid minimal forms of the Boolean Logic Expression. Once again, we can go back to Wolfram Alpha to check our work:</p><p><a href=#R-image-3199345c6c9ab72ecb34223506fabb1b class=lightbox-link><img alt="Wolfram Alpha Minimal Forms" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram4.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3199345c6c9ab72ecb34223506fabb1b><img alt="Wolfram Alpha Minimal Forms" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram4.png></a> <sup id=fnref3:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>In that screenshot, we can see both the minimal <a href=https://en.wikipedia.org/wiki/Disjunctive_normal_form rel=external target=_blank>Disjunctive Normal Form</a> (DNF) as well as the minimal <a href=https://en.wikipedia.org/wiki/Conjunctive_normal_form rel=external target=_blank>Conjunctive Normal Form</a> (CNF) for the expression.</p><h3 id=method-2---using-intuition>Method 2 - Using Intuition</h3><p>Another great way to convert a Truth Table or Venn Diagram into a Boolean Logic Expression is to use a bit of intuition. The video earlier in this chapter showed one way to do this suing the Venn Diagram, but let&rsquo;s use another method - using a concrete example!</p><p>For this example, let&rsquo;s assume that we have been given the following rules:</p><ul><li>If Mom says yes and it is sunny outside, we can go swimming even if we don&rsquo;t have friends over.</li><li>If Mom says yes and we have friends over, we can go swimming even if it isn&rsquo;t sunny outside.</li><li>If Mom says yes, we can go swimming if it is sunny outside and we have friends over.</li></ul><p>We can build a Truth Table using these rules as shown below:</p><table><thead><tr><th style=text-align:center>Friends Over (A)</th><th style=text-align:center>Sunny Outside (B)</th><th style=text-align:center>Mom Says Yes (C)</th><th style=text-align:center>Go Swimming</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr></tbody></table><p>Ahh! Notice that this Truth Table is identical to the Truth Table given in Example 1 shown above! We have created a set of rules that immediately generate the same Boolean Logic Expression that matches our example. It may take a little bit of thinking, and we have to state the rules very clearly, but generally we can always create a set of rules that clearly describe any Truth Table. In practice, we often are starting with a set of rules like this (in our specifications document), and we are trying to build a Boolean Logic Expression that we can use in our code as we implement those specifications in our program.</p><p>Now, let&rsquo;s use a bit of intuition about those rules above to generate a Boolean Logic Expression. If we really want to go swimming, we&rsquo;ll quickly realize that there are two main things that we need to have:</p><ol><li>Mom has to say yes (C), and</li><li>It must either be sunny outside (B) or we have to have friends over (A) (or both)</li></ol><p>Look closely at those rules! Just by talking through the scenario, we have created a Boolean Logic expression. Let&rsquo;s rewrite it:</p><blockquote><p>Mom must say yes <code>AND</code> (it must be sunny outside <code>OR</code> we have to have friends over)</p></blockquote><p>If we replace each part with the corresponding variable, we can find the corresponding statement:</p><p>$$
C \wedge (B \vee A)
$$</p><p>A similar way to state the rules might be:</p><ol><li>Mom has to say yes and it has to be sunny, or</li><li>Mom has to say yes, and we have to have friends over</li></ol><p>Once again, we can rewrite that a bit to make the Boolean Logic operators more obvious:</p><blockquote><p>(Mom must say yes <code>AND</code> it must be sunny outside) <code>OR</code> (Mom must say yes <code>AND</code> we have to have friends over)</p></blockquote><p>Finally, we can replace those parts with variables to get the corresponding statement:</p><p>$$
(C \vee B) \wedge (C \vee A)
$$</p><p>So, as we can see, applying a bit of intuition to a real-world example that creates the same situation can make it pretty easy to work out a simple Boolean Logic Expression from a Truth Table or Venn Diagram.</p><h3 id=method-3---karnaugh-maps>Method 3 - Karnaugh Maps</h3><p>The third method would be to use a Karnaugh Map. We won&rsquo;t go into this method in too much depth, but we&rsquo;ll briefly show how it works. There are some great online resources to learn more about applying Karnaugh Maps in this context.</p><p>First, we&rsquo;ll start with a blank 3 variable Karnaugh map. A Karnaugh Map is essentially a different way to structure a truth table by placing similar entries next to each other in a particular way:</p><p><a href=#R-image-536d393422c74bc0f18476a9c9a2386b class=lightbox-link><img alt="Blank Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-536d393422c74bc0f18476a9c9a2386b><img alt="Blank Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh.png></a> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>Then, we&rsquo;ll input the desired outputs from the Truth Table in each square of the Karnaugh Map:</p><p><a href=#R-image-c2f0487f594df9b209a8b427f50222c7 class=lightbox-link><img alt="Filled Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh_filled.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c2f0487f594df9b209a8b427f50222c7><img alt="Filled Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh_filled.png></a></p><p>Now, we&rsquo;ll group connected terms. These groups can be either rectangular or square boxes. So, for this Karnaugh Map, there are two groups:</p><p><a href=#R-image-05beecc4e896fa2a0eb6a1afa4329084 class=lightbox-link><img alt="Grouped Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh_grouped.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-05beecc4e896fa2a0eb6a1afa4329084><img alt="Grouped Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh_grouped.png></a></p><p>Finally, for each group, we identify the variables that don&rsquo;t change within that group, and those become our terms. So, for the group in the bottom row, we see that both $A$ and $C$ are the same, but $B$ changes. So, one term we find is $AC$. For the group in the third column, we see that $B$ and $C$ are the same, but $A$ changes, so our other term is $BC$. Then, we combine those two terms together using the <code>OR</code> ($\vee$) operator to get this statement:</p><p>$$
(AC) \vee (BC)
$$</p><p>There we go! That is once again one of our minimal Boolean Logic expressions found earlier.</p><h4 id=method-3a---venn-diagrams-as-karnaugh-maps>Method 3A - Venn Diagrams as Karnaugh Maps</h4><p>Once clever things that we might notice is that there is <em>also</em> a one-to-one equivalence between Karnaugh Maps and Venn Diagrams. We know this since there is already a one-to-one equivalence between both of those and the original Truth Tables, so it is an easy assumption to make.</p><p>So, we can quickly see the arrangement of items in a Karnaugh Map and how they match up to our Venn Diagrams as shown below:</p><p><a href=#R-image-08d7457f7832d7a7791e76bd30968203 class=lightbox-link><img alt="Karnaugh Map to Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh_venn.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-08d7457f7832d7a7791e76bd30968203><img alt="Karnaugh Map to Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh_venn.png></a></p><p>Notice that the the Venn Diagram has a very similar layout to the Karnaugh Map. This is because both of them are structured in a way for similar entries to be near each other. In fact, each time you cross over a line in a Venn Diagram, only a single variable changes value. The same works for a Karnaugh Map.</p><p>So, with a little intuition and an understanding how Karnaugh Maps work, we can perform a similar analysis directly on the Venn Diagram itself.</p><h2 id=connection-to-programming>Connection to Programming</h2><p>Why does all of this matter? Well, when we are trying to convert a real-world situation to code, it is often helpful (but not necessary) to be able to reduce our Boolean Logic expressions to simpler terms.</p><p>Let&rsquo;s go back to the concrete example shown above. If we wanted to write a Python program for this, there are a few ways we could build it.</p><p>First, here&rsquo;s what it would look like if we just directly encoded the rules as written:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># bool() returns False if the input is the number 0, otherwise True</span>
</span></span><span style=display:flex><span><span style=color:#75715e># so we have to convert the string to an int first</span>
</span></span><span style=display:flex><span>sunny <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Is it sunny outside? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>friends <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Do you have friends over? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>mom <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Did Mom say yes? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34; 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Rules:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes and it is sunny outside, we can go swimming even if we don&#39;t have friends over.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes and we have friends over, we can go swimming even if it isn&#39;t sunny outside.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes, we can go swimming if it is sunny outside and we have friends over. 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (mom <span style=color:#f92672>and</span> sunny <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> friends)
</span></span><span style=display:flex><span>  <span style=color:#f92672>or</span> (mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> sunny) 
</span></span><span style=display:flex><span>  <span style=color:#f92672>or</span> (mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> sunny):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>We could also use <code>if-else</code> statements instead of the <code>or</code> operator to achieve a similar effect:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> sunny <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> friends:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> sunny:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> sunny:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>: 
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>However, in both cases, these programs are more complex than they actually need to be, and it may make things more difficult to debug down the road. So, with a little intuition and the ability to reduce Boolean Logic expressions effectively (and <em>correctly</em>), we can simplify this code quite a bit:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> (sunny <span style=color:#f92672>or</span> friends): 
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>Hopefully you can see the value in that much simpler program, both in terms of how easy it is to understand and debug, but possibly how much more efficient it is overall since it has fewer comparison to make.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Image Source: <a href=https://www.allaboutcircuits.com/textbook/digital/chpt-8/boolean-relationships-on-venn-diagrams/ rel=external target=_blank>https://www.allaboutcircuits.com/textbook/digital/chpt-8/boolean-relationships-on-venn-diagrams/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Image Source: <a href="https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29" rel=external target=_blank>https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Image source: <a href=https://www.learnelectronicswithme.com/2021/09/karnaugh-map-and-steps-to-solve.html rel=external target=_blank>https://www.learnelectronicswithme.com/2021/09/karnaugh-map-and-steps-to-solve.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cs-zero/js/mathjax/tex-mml-chtml.js?1767801774></script><script src=/cs-zero/js/clipboard/clipboard.min.js?1767801774 defer></script><script src=/cs-zero/js/perfect-scrollbar/perfect-scrollbar.min.js?1767801774 defer></script><script src=/cs-zero/js/theme.min.js?1767801774 defer></script><script src=/cs-zero/js/embed-iframe.min.js?1767801774 defer></script></body></html>