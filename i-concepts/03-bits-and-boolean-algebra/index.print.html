<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content><meta name=author content="K-State CS Faculty"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><meta name=twitter:title content="Bits and Boolean Algebra :: Intro CS Textbook"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/03-bits-and-boolean-algebra/index.html"><meta property="og:site_name" content="Intro CS Textbook"><meta property="og:title" content="Bits and Boolean Algebra :: Intro CS Textbook"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><meta itemprop=name content="Bits and Boolean Algebra :: Intro CS Textbook"><meta itemprop=datePublished content="2019-12-17T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T16:31:51-05:00"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cs-zero/images/hero.png"><title>Bits and Boolean Algebra :: Intro CS Textbook</title><link href=https://textbooks.cs.ksu.edu/cs-zero/i-concepts/03-bits-and-boolean-algebra/index.html rel=canonical type=text/html title="Bits and Boolean Algebra :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/index.xml rel=alternate type=application/rss+xml title="Bits and Boolean Algebra :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/tele.html rel=alternate type=text/html title="Bits and Boolean Algebra :: Intro CS Textbook"><link href=/cs-zero/i-concepts/03-bits-and-boolean-algebra/embed.html rel=alternate type=text/html title="Bits and Boolean Algebra :: Intro CS Textbook"><link href=/cs-zero/css/auto-complete/auto-complete.min.css?1767726213 rel=stylesheet><script src=/cs-zero/js/auto-complete/auto-complete.min.js?1767726213 defer></script><script src=/cs-zero/js/search-lunr.min.js?1767726213 defer></script><script src=/cs-zero/js/search.min.js?1767726213 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cs-zero/searchindex.en.js?1767726213"</script><script src=/cs-zero/js/lunr/lunr.min.js?1767726213 defer></script><script src=/cs-zero/js/lunr/lunr.stemmer.support.min.js?1767726213 defer></script><script src=/cs-zero/js/lunr/lunr.multi.min.js?1767726213 defer></script><script src=/cs-zero/js/lunr/lunr.en.min.js?1767726213 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cs-zero/fonts/fontawesome/css/fontawesome-all.min.css?1767726213 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/fonts/fontawesome/css/fontawesome-all.min.css?1767726213 rel=stylesheet></noscript><link href=/cs-zero/css/perfect-scrollbar/perfect-scrollbar.min.css?1767726213 rel=stylesheet><link href=/cs-zero/css/theme.min.css?1767726213 rel=stylesheet><link href=/cs-zero/css/format-print.min.css?1767726213 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/i-concepts/03-bits-and-boolean-algebra/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cs-zero",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cs-zero/css/custom.css?1767726213 rel=stylesheet></head><body class="mobile-support embed print" data-url=/cs-zero/i-concepts/03-bits-and-boolean-algebra/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable i-concepts" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=bits-and-boolean-algebra>Bits and Boolean Algebra</h1><p><a href=#R-image-c052841e8ea008f55e8a8cc14fc91585 class=lightbox-link><img alt="George Boole" class="border lazy lightbox figure-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/c/ce/George_Boole_color.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c052841e8ea008f55e8a8cc14fc91585><img alt="George Boole" class="border lazy lightbox lightbox-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/c/ce/George_Boole_color.jpg></a></p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Bits and Boolean Algebra</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><a href="https://www.youtube.com/watch?v=YYSFRGEAgdg">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><h5 id=introduction-slide-1-2>Introduction (Slide 1-2)</h5><p>For this lesson, we&rsquo;re going to be talking primarily about Boolean logic, Boolean algebra and how that plays into computer science and the foundations of how important that is and the role it plays and what we do. So before we get started, and before we can talk about things such as Boolean logic, we need to know where it came from. That leads us to Aristotle, way back in the 300 BC, as you may know, right Aristotle is one of the fathers of modern philosophy and logic among many other things. He studied under Plato, who himself was taught by Socrates and was also the teacher of Alexander the Great, so pretty much affected the entire world of Western philosophy that came after him. One of his major contributions was this idea of using formal logic to prove a point, then this form of logic, also known as Aristotelian logic, a point is proven based off of a series of premises.</p><h5 id=aristotelian-logic-slide-3>Aristotelian Logic (Slide 3)</h5><p>For example, in this form of logic, we can present a series of facts. And so our premise here in that sense, all humans are mortal. Socrates is human. Each one of these is a fact and pretty easily proven to be true. Now, under Aristotelian we can use these use this premise to then prove a new fact. So if all humans are mortal, which is true, and Socrates is a human, which is also true, we can also prove or conclude that Socrates is also a mortal.</p><h5 id=boolean-logic-slide-4>Boolean Logic (Slide 4])</h5><p>If we skip ahead a few thousand years later, we come to George Boole. In 1854, he published a book called An Investigation of The Laws of Thought, in which he tried to apply the rapidly growing field of mathematics to the laws of logic. His goal was to reduce something as complex as logic to simple mathematical equations. And with the right rules in place, even a complex logic Statement could be completely proved, or even disproved using the same algebraic techniques they used to understand other parts of the world.</p><p>And so if we take a look at an example, our same style of facts that we had before now transcribed into something that is more easily represented in algebra or mathematics, so for example, if we take are all humans are mortal and Socrates is a human, we can map that to different variables. And you can kind of imagine different kinds of facts being transcribed here where we can substitute proven facts or true facts in places of a and b and c, we can conclude new facts or new premises or new things from that. So if A and B so the upside down would be their means and we&rsquo;ll talk about that here in just a little bit. But if both A and B are true, and B and C are true, we can conclude that A and C is true. Since A and B are true, B and C are true, then A and C must also be true. But this translation is somewhat flawed but we can leave that for a later course in logic or philosophy to describe why &mldr;but let&rsquo;s take a deeper dive into what each of these mean so primarily Boolean operators Boolean values and what that means for Boolean logic.</p><h5 id=boolean-values-slide-5>Boolean Values (Slide 5)</h5><p>As you know from the reading computers operate primarily using only binary values so ones and zeros and Boolean logic and Boolean algebra operate off of true and false principles or yes no answers but that in itself is a binary decision there is no in between. So we can easily translate binary and Boolean logic back and forth. Commonly speaking, one is going to mean true and zero is going to mean false. Now, this is the same thing is translated in a variety of other contexts, like electrical systems where a on or off signals being produced one or on meaning electrical current, or off or zero. meaning no electrical current. So while these are traditional representations in many electrical and programming contexts, these values can be reversed for a variety of reasons. And really the moral of the story here is make sure you know which one you&rsquo;re working on.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=operators>Operators</h1><a href="https://www.youtube.com/watch?v=L7ibGfyWNAU">YouTube Video</a><h3 id=resources>Resources</h3><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h3 id=video-script>Video Script</h3><h4 id=boolean-operators-slide-6>Boolean Operators (Slide 6)</h4><h5 id=and>And</h5><p>Let&rsquo;s take a look at what the Boolean and operator does out in this Venn diagram here we&rsquo;re going to kind of use these to showcase where the Boolean statements that we&rsquo;re checking out with the Boolean operator where these statements are actually evaluated to be true. So if we assume that we are two facts here, A and B are both true. So let&rsquo;s say this inner circle here, this left circle here represents a and this right circle here represents B and the square on the outside represents everything else. So when a and b are not, so if A and B are both true, then the statement evaluates to true. So the left hand side and the right hand side of the operator both must be true in order for the whole statement to be true. If A is false, or B is true. false, then the whole thing would be false. Now if we introduce a third fact, see, we kind of get the same results, right. So similar kind of story with the Venn diagram. Here we have a, b, and c. But notice that this little square here where we were actually filled in over here is no longer filled in. And that&rsquo;s because all three facts must be true for the whole statement to evaluate to true. So a has to be true, B has to be true. And C has to be true in order for the whole statement to evaluate true.</p><h5 id=or>Or</h5><p>So we&rsquo;ll have similar representation here for the OR operator where the English word is the representation in Python of the OR operator the double bar symbol, so this is just the two vertical bars from your keyboard that is the OR operator in Java, C sharp and other programming languages and then a capital V is great. To be the OR operator for Boolean algebra. So let&rsquo;s take a look at how or operates. So if we have the same statement, as we have before the same two premises A and B both being true initially, and the circles are kind of the representation of the same thing here, but the OR operator will evaluate to be true if either side of the operator are true. So if the left hand side is true, or the right hand side is true, the whole thing will be true. So if A is true, or B is true, so left hand side and the right hand side, so if A or B is true, then the whole statement is also true. And so nothing on the outside will actually be filled in quite yet. And the similar kind of story is for a third fact or fifth, that one has to be true for the whole statement to be true. So if any of them are true, the whole thing is true, but things kind of get tricky when we&rsquo;re in introduce this next operator the exclusive OR exclusive or you won&rsquo;t really find normally in programming languages. The Exclusive OR can be simulated using and or and the next operator that we&rsquo;ll be covering here in just a second.</p><h5 id=xor>XOr</h5><p>But the exclusive OR works in a little bit of a different way than the regular or the exclusive OR operates very similar to what we would expect the normal or operator to be in the sense that if A is true, or B is true, the statement is true, but notice that a and b is now false. If a and b are both true, the statement is false. So the exclusive OR operator is expecting one or the other. So that means the left side or the right side must be true, but not both. That is where the exclusive portion of the exclusive OR or the X or operator actually comes out. If I introduce a third fact things get to be a little bit more difficult to understand because now I would expect it to be kind of similar pattern as we have up here just to be, or on my just with my two facts, everything in the middle would be white, but everything on the outside would be red. But you notice when when we have all three to be true, all three can be true and the exclusive OR would still be true. Now let&rsquo;s take a look at why that would be the case.</p><h5 id=xor-white-board-example>XOr White Board Example</h5><p>So let&rsquo;s take a look at the example that we saw on the slides. We have our facts a, and our XOR operator. So we have a XOR B XOR. See, now if we kind of do our substitutions here now we could substitute ones and zeros here are true and false. So let&rsquo;s go ahead and substitute our Boolean values here for our variables. So if A is true So we have a XOR B, which is also true. And C, which is also true. Now, just like most of your math problems, even when you&rsquo;re just doing multiplication and division, you&rsquo;re always going to evaluate your statement from the left to the right. So we need to first evaluates true x or true now XOR Exclusive OR exclusive right, the left or the right can be true, but not both. Since the left hand side of my operation is true, and the right hand side of my operator is true, this portion of the statement evaluates to false. Then all we need to do then is keep on working the rest of our statements. So we still have one XOR left. So we have false x or true? Now exclusive or one side or the other must be true but not both. So false x or true is actually true because both sides aren&rsquo;t true. So this statement you say a false x or true, evaluates to true. So the whole thing true x our true, false XOR true, ends up being true.</p><h5 id=not-slide-6>Not (Slide 6)</h5><p>So our last Boolean operator here is the NOT operator. The NOT operator acts pretty much like negation, as you would expect, like multiplying something by negative one not something is the opposite of what it actually is in Python as the previous Boolean operators the and and the OR operator, the NOT operator in Python is very English light not but Python is kind of weird. You will also see the exclamation point In some operations, but it doesn&rsquo;t mean the traditional knots or negation operator as in many other programming languages. So, again, you&rsquo;ll see not in Python, the exclamation point, this is going to be things like Java. And the weird sideways l here, this is going to be your Boolean algebra. So let&rsquo;s take a look at what the Boolean operator not actually looks like. As I mentioned, the NOT operator is a negation, so not something as the opposite. So not a or not true is false. So not a if I write a here, so everything in the circle is a so when A is actually true, so everything inside of the circle then everything on the outside of a is actually true because it&rsquo;s negated and similar idea for B when B is true, everything But B is true. So the whole statement is evaluated as such and similar idea if I introduce a third fact. So if I have three facts A, B and C, not B means that everything but B is true, just like in this example here.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=boolean-algebra>Boolean Algebra</h1><a href="https://www.youtube.com/watch?v=nc7OgG3BYe4">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><h5 id=demorgans-theorem-slide-7>DeMorgan&rsquo;s Theorem (Slide 7)</h5><p>So with all these new tools, we needed some new algebraic rules to really deal with them. Thankfully, most of the rules you know, apply quite well, but there&rsquo;s one rule that needed to be added. In mathematics. When you multiply by negative one, you have to change the signs. Similarly, Augustus DeMorgan came up with a way to deal with the negation of entire Boolean logic statements. So this becomes very similar to how you multiply a statement or a regular mathematical statement by a negative one. I guess system marking came up with a way to deal with the negation of entire Boolean logic statements. The DeMorgan&rsquo;s theorem essentially states to treat the NOT operator like the negative sign so you&rsquo;re going to apply the negative to each of the premises or facts and then swap the operators or basically and become or&rsquo;s and or&rsquo;s become hands. So let&rsquo;s take a look at an example. So if we invert our particular statement here where we have a and b, right, so A and B, not a and b becomes not a or not B, so we negated or applied the knot to a and the knots to b and the knot and becomes or similar idea for or not a or b becomes not a, and not B.</p><h5 id=boolean-algebraslide-8>Boolean Algebra(Slide 8)</h5><p>Now, in Boolean algebra, just like when you multiply by a negative one, a lot of the similar rules apply and Boolean algebra just like they do in mathematics. So in general, the OR operator works very much like the plus operator not works very much like negation, like we&rsquo;ve already seen, and works very much like multiplication.</p><p>The associative property, also Hold. So we have a and b, and c becomes a and b and c. So if I made the substitutions here, just based off of what we had here, if we had one, and the AND operator works like multiplication, though times two, parentheses, substitute the multiplication symbol and for the end, and then we have three. That is the same thing as saying one times two times three.</p><p>The commutative property also holds. So again, let&rsquo;s try to make some substitutions. A and B is the same thing as saying B and A. So that&rsquo;s the same thing as saying. Two times three is the same thing as Three times two.</p><p>And the distributive property also holds. So A and B or C is the same thing as saying a and b, or a and c. So let&rsquo;s make our substitutions again, let&rsquo;s substitute again, one four a, so one times to remember, or is like the addition operator plus three is the same thing as saying, we&rsquo;re going to kind of distribute right as we normally would with math, distribute the one across two plus three. So one times two plus three is the same thing as saying one times two, plus one times three. So we distributed the Want across and we&rsquo;ll end up with the same exact result. Same idea or Boolean logic if we make each one of these properties, as we seen here, and mathematics applies and works directly with Boolean algebra. So what this really helps you as when you start working with Boolean logic, even when programming you can actually use these properties to simplify a lot of your Boolean logic statements to make them easier to read and easier to program.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logic-to-switches>Logic to Switches</h1><a href="https://www.youtube.com/watch?v=YhSE19TBJAE">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><h5 id=logic-via-electrical-switches-slide-9>Logic via Electrical Switches? (Slide 9)</h5><p>With the new tools from Boole and DeMorgan, others began to see where they could be applied in the real world. In 1886, Charles Sanders Peirce noted in a letter that logical operations could be easily simulated by electrical switches. Many others worked on the idea too many to name here, but 51 years later.</p><h5 id=claude-shannon-slide-10>Claude Shannon (Slide 10)</h5><p>In 1937, something happened. In 1937, Claude Shannon, a 21 year old graduate student at MIT was working on this same idea. He wrote a master&rsquo;s thesis that some of called the most important master&rsquo;s thesis of all time, titled a symbolic analysis of relay and switching circuits. In it, he showed that you could use electrical switches in Boolean algebra to construct circuits that could show any logical OR numerical relationship that you wanted. It&rsquo;s available free online and will be linked in Canvas and linked in this video as well if you&rsquo;re interested, but this is really cool. Kind of what was the gateway to electrical circuits, all of the cell phones and computers and electronic devices that you use today, this was the initial theory behind how all of those devices actually work.</p><h5 id=logic-gates-slide-11>Logic Gates (Slide 11)</h5><p>So underneath Claude Shannon&rsquo;s representation as far as translating Boolean algebra and Boolean logic into electrical circuits, we also needed a new representation for that this new representation is called logical gates. So it&rsquo;s basically the same setup as we had with Boolean algebra and is very similar to if we have a and b, this is equivalent to this right where our two inputs are coming in on these two lines here are the AND operator it&rsquo;s like a D, and then our output is the line leaving from the operator. similar idea for or so this is a or b we have XOR a XOR B, and not so this is same thing as saying that. Now really with the knot, the really important part is this little knot or this little mini circle at the end here and also note right that all of our Boolean operators here are compound operators, meaning that we have a left hand side and a right hand side, but the NOT operator only has one input. So one fact so just keep that in mind. But we can also apply the NOT operator to all of our other operators as well. So we can have NAND, nor, and x nor a little.at. The end here on the output is really the only part that matters for negating the result of a operation and and or XOR. One of the interesting things though, that it&rsquo;s really kind of come out of the representation of Boolean logic on electrical circuits. So The work done by Claude Shannon and will continue part of this work and future lectures as well.</p><h5 id=the-universal-logic-gate-slide-12>The Universal Logic Gate (Slide 12)</h5><p>But one of the really interesting things that have kind of come out of this is the idea of a universal logic gate. The idea here is that any electrical circuit can be finished off by just using NAND gates. So all the complex Boolean logic that we could ever think of so any logical statements that we could write in Boolean algebra or Boolean logic can be redone with just using NAND gates or NAND operators, which is a pretty interesting thing and really why this is so important is that it greatly increases the speed efficiency and decreases the cost of manufacturing electrical parts.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=truth-tables>Truth Tables</h1><a href="https://www.youtube.com/watch?v=T_olVh6K6IQ">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><h5 id=overview>Overview</h5><p>Let&rsquo;s go through an example of some Boolean logic now that we&rsquo;ve covered some of the operators and some of the rules that govern the Boolean algebra behind it. A lot of times what you&rsquo;ll see in computer science, especially when you&rsquo;re dealing with Boolean logic and complex algorithms, our truth tables, truth tables showcase all the different options for each Boolean variable inside of a Boolean logic statement, as well as what output those particular facts for those variables actually produce. So let&rsquo;s take a look at an example that we&rsquo;ve already kind of done with end. So we&rsquo;ve already explored the statement A and B, and C. You&rsquo;ve already seen what the Venn diagram for that looks like, but we can also explore what that looks like again here in just a second, but let&rsquo;s take a look at all possible values that we could actually input for A, B, and C. And if you remember, we&rsquo;re only going to have two values binary values, either one, or zero or true or false. Now, both work synonymously. And you&rsquo;ll find both in truth tables. And in fact, what the examples that you&rsquo;ll be working with, we actually do use ones and zeros for true and false. So if you remember one means true, zero means false. But let&rsquo;s take a look at how we can actually fill out our truth table here with those particular values. Now, I&rsquo;m going to go ahead and use T for true and false. But as you could imagine, you could substitute one for true and zero for false and everything would be identical.</p><p>So what we would actually start with our truth table here as each of our columns here represent each of our variables or each of our facts as part of our Boolean logic statement though For a, what we&rsquo;re actually going to do here, easy way to fill this out is we&rsquo;re going to want to fill out all the different possibilities. So if we exhaustively go through each of our variables here, you may find that each one has two possible values. And then if we multiply this out, if it&rsquo;s powers of two, we have eight possible outcomes or combinations of these values. You&rsquo;ll notice that I have eight different rows in my truth table. That&rsquo;s going to represent all of the different combinations that I actually have for this Boolean logic statement. Now generally, when we try to figure out how many different combinations we have the number of options we have for our variable to the power of the number of variables that we actually have, so that in this case would be two to the power of three. So two times, two times To write two times two is four times two is eight. This is the total number of possible combinations of truths or our facts that we actually could get out of this Boolean logic statement.</p><h5 id=filling-in-the-truth-table>Filling in the Truth Table</h5><p>So let&rsquo;s elaborate on that and fill out our truth table accordingly. The easiest way to start out for our truth table is go down one column first, because there&rsquo;s kind of a general pattern that you can follow on filling this out. If we just fill half of our rows with false and then half of our rows with true we can work that out. So the column fills out pretty easily. This the pattern that you can kind of follow for the second column works as such, if you just fill in half of the falses, or half of the rows that was false of the first column with true and half of them with false and a similar pattern for the sets of trues down here. So if I make an imaginary line right here in the middle, we can try to fill out all the falses first. So, I want to fill out half of these with false and half of these with true. So let&rsquo;s start with false first. So false, false, and then True, true. Down here, I&rsquo;m going to do the same exact thing. false, false, true, true. And I&rsquo;m going to continue the same pattern where I&rsquo;m going to fill half of what I just filled in and see with falses, and half of what I just filled in with true. So for this set of falses, here, I&rsquo;m going to have false true. With the set I&rsquo;m going to have false true. Now, this pattern doesn&rsquo;t exactly always hold, especially as you start adding a fourth column But with three variables, it&rsquo;s pretty easy to fill out using this particular pattern. But if you find yourself filling out a truth table for more than three facts, all we&rsquo;re actually doing is exhaustively writing out all of the different combinations of true and false values or each set of variables. Now, let&rsquo;s go through and try to evaluate the output here, or our truth table. This particular statement is fairly easy with a and b, and c. Because we&rsquo;ve already seen that with an and statement, both sides of the operator must be true for the whole statements to evaluate to true.</p><p>So in my output here, I&rsquo;m going to write out what this set of facts this row of facts evaluates to for our Boolean logic statement up above. So I&rsquo;m just going to kind of put row numbers here 123. And then let&rsquo;s write our output. Over here, so, false and false and false, is going to evaluate to false because no sides are true and similar ID here, false and false is false. And true. is also False. False and true is False. False and False. False and true. And notice I&rsquo;m evaluating this from left to right, right, because my statement is a and b, and c, so I&rsquo;m evaluating the A and B first, and then I&rsquo;m adding that result with C. So false and true is False. False and true is false. true and false is false, false and false is false. true and false is false, false and true is false. True and true is true. But true and false is false. True and true is true, true and true is true. Now on our truth table, we have a completed evaluation of what our Boolean logic statement A and B and C can actually cover, right, so we have all the different combinations of values, or truth of A, B, and C. And then we&rsquo;ve also evaluated those truth values as part of our output. So now we know when this statement is true, and when the statement is false.</p><h5 id=venn-diagram>Venn Diagram</h5><p>In lecture in the previous video, we saw what the AND operator looked like for our Venn diagram as well. So let&rsquo;s kind of draw that over here, just so we kind of have what that looks like again, and or the statement just as we kind of had over in our truth table, we&rsquo;re only going to fill in the spot where a true B is true and C is true, where essentially that means the output of our country table is true. So if I just kind of put a, b and c here, and then we also remember, we have a square on the outside that represents everything that is not A, B, or C. I will be giving you some more examples of this or where I&rsquo;m going to actually give you the truth table, then you&rsquo;re going to try to generate the Boolean logic statement and the Venn diagram and even some logic gates.</p><h5 id=logic-gates>Logic Gates</h5><p>But let&rsquo;s try to draw the logic gates for this as well. And the examples that you&rsquo;ll be doing our logic gates are written like this. So we have our three inputs A, B, and C. Now if you remember the logic gate for and looks like this. Let&rsquo;s draw that. So what we want to do is start out by drawing the logic gate for the first part. Have the logical statement, which is a and b. So to do that, you can kind of imagine electrical wires kind of coming off of the sources of A and B, or your individual variable. So I&rsquo;m going to draw kind of a little wire out over here into my open space on the right from a and then my second input to that statement is B. So I&rsquo;m going to draw a wire out from there. And I&rsquo;m going to draw my gate. So it looks like a D, and my output there. Now I can draw the second part of the statement, which is and C. So I&rsquo;m going to draw a line from C and draw out here and it&rsquo;s okay if your wires go at a 90 degree angle or a little bit of a curved connect the logic gates together. And now that I have the output from a and b, and the output the input from C, we&rsquo;re going to join those together with another and gate. So the logic gate drawing of a and b and c can be viewed as that. Now everything that I just did apart from generating your truth table are going to be reviewed and practice in a few examples.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=boolean-logic-crash-course>Boolean Logic (Crash Course)</h1><a href="https://www.youtube.com/watch?v=gI-qXk7XojA">YouTube Video</a><h2 id=notes-about-this-selection>Notes About This Selection</h2><p>In this video, Carrie Anne shares the principals of binary numbers and how we use Boolean Algebra to work with binary values. We get to see the truth tables for the basic statements (or, and, not, xor) as well as their respective logic gates. We also get a good primer for working on more complex statements.</p><h2 id=reference>Reference</h2><p>CrashCourse. &ldquo;Boolean Logic & Logic Gates: Crash Course Computer Science #3
&ldquo;. Mar, 8, 2017. YouTube. Available: <a href="https://www.youtube.com/watch?v=gI-qXk7XojA" rel=external target=_blank>https://www.youtube.com/watch?v=gI-qXk7XojA</a></p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=worked-example>Worked Example</h1><a href="https://www.youtube.com/watch?v=KwN60GZjMlE">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/slides/03-Bits-and-Boolean-Algebra.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><h5 id=example-1-slide-13>Example 1 (Slide 13)</h5><p>So let&rsquo;s take a look at example one. And the best way to start this is where the output is actually true. So if we examine this line here, this line and this line, we can see that when B and C are true, output is True. When a and c are true, the output is True, or when all three are true, the output is also true. So a really good way to start is just by coloring in these three facts.</p><h5 id=venn-diagram>Venn Diagram</h5><p>So when B and C are true, that&rsquo;s this little square here. Then when a and c are true, that&rsquo;s this little portion of the Venn diagram. And then when a, b, and c are so when all three are true, And that&rsquo;s this little center part of the diagram. And then all other rows of the truth table are all false or zero. So we&rsquo;re not going to fill in anything else in the Venn diagram here. So this is the full output of or the full expression represented as a Venn diagram.</p><h5 id=expression>Expression</h5><p>So let&rsquo;s tackle this as a Boolean expression. And so we&rsquo;ve already talked through parts of what the Boolean expression would actually be. So this can start here with a and c, when a and c are true, the statement is true. So let&rsquo;s write a and see us as one portion of our Boolean expression. So I&rsquo;m going to write that using parentheses, and then we have B and C. So I&rsquo;m going to kind of write this over here, B and C. What that&rsquo;s the other part of the truth in our Boolean expression, but we can&rsquo;t just write them side by side, right, we need to join the middle because we also need the center portion. So it&rsquo;s either a and c are true, or either A and C or B and C. So enter a or operate in between. So if A and C are true, or B and C are true, so that&rsquo;s this portion right here. So when a and c, or B and C are true, and our expression is true, this will represent our Boolean logical statement. But there are alternative ways to write this. And these aren&rsquo;t just the only ways another way you could have wrote this would be C, right? Because in all three cases, C is always true. So C, and a or b.</p><h5 id=logic-gates>Logic Gates</h5><p>So let&rsquo;s take a look at what the logic gates look like. So the logic gates and I&rsquo;m going to write the logic gates for my top statement here. So this one right here, we need to write the left and right hand side of the OR operator first, and the OR operator is going to join these two at the end. The lines here represent the inputs of A, B and C. So I&rsquo;m going to draw out the input of a because in this case, we have a and c. And those are connected together with the AND operator. And that gives an output and we have the same thing with B and C. So we have B, C, those are both connected together with an AND operator and both of those are joined together using or. So this would be the logic gate for this particular statement here.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=deeper-dive>Deeper Dive</h1><p>Let&rsquo;s do a bit of a deeper dive into that worked example to explain some of the nuances working with Boolean Logic Expressions, Truth Tables, Venn Diagrams, and the connections between those three. Unfortunately, this is not well explained or covered elsewhere in online resources, but we find that it is really helpful to revisit these concepts here before the end of this module.</p><details open class="box cstyle notices tip"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-lightbulb"></i>
Don&rsquo;t sweat it!</summary><div class=box-content><p>This is a lot of conceptual information to digest at once. However, we <strong>don&rsquo;t expect you to become proficient in this right away!</strong> This is just meant to be an introduction to the concept of Boolean Logic and Boolean Algebra, which you&rsquo;ll become more comfortable with over time as you practice your programming skills and take later classes in Computer Science.</p><p>For now, we just want to introduce the topic and give you a chance to try it out in the quiz at the end of this module. If you don&rsquo;t do well on the quiz, <strong>don&rsquo;t sweat it!</strong></p><p>This material is handy if you want to review the concepts or get in some practice, but the best way to learn is to just keep doing examples and practicing as you learn to code.</p></div></details><h2 id=key-idea-truth-table--venn-diagram>Key Idea: Truth Table &lt;=> Venn Diagram</h2><p>When working with Truth Tables and Venn Diagrams, the key idea to remember is that each line in the Truth Table corresponds to exactly one space in the Venn Diagram.</p><p><a href=#R-image-3b60fec76bbedbdf6fa7fbac7503d340 class=lightbox-link><img alt="Three Variable Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/three-variable-venn-diagram.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3b60fec76bbedbdf6fa7fbac7503d340><img alt="Three Variable Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/three-variable-venn-diagram.png></a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>Each labelled section in the Venn Diagram above corresponds to the variables that are <code>True</code> or <code>1</code> in the corresponding Truth Table. We can even draw arrows directly from each line in the Truth Table for Example 1 to the Venn Diagram:</p><p><a href=#R-image-6f3f541ef76895639aa2f0deb8a1ab8b class=lightbox-link><img alt="Match Venn Diagram to Truth Table" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/venn_match.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6f3f541ef76895639aa2f0deb8a1ab8b><img alt="Match Venn Diagram to Truth Table" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/venn_match.png></a></p><p>So, if the &ldquo;OUT&rdquo; column in the truth table is <code>True</code> or <code>1</code>, that section of the Venn Diagram becomes shaded and is part of the desired output. Therefore, if you have a Venn Diagram or Truth Table, the conversion between the two is a direct one-to-one connection. Here&rsquo;s what that looks like for Example 1:</p><p><a href=#R-image-933f101aa5781e29c0502cd7b9fda224 class=lightbox-link><img alt="Example 1 Truth Table and Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/venn_match2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-933f101aa5781e29c0502cd7b9fda224><img alt="Example 1 Truth Table and Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/venn_match2.png></a></p><h2 id=creating-a-boolean-logic-expression>Creating a Boolean Logic Expression</h2><p>Once we understand either the Truth Table or Venn Diagram for a desired Boolean Logic expression, we can use that information to start building the Boolean Logic expression itself. This can be done in one of three ways:</p><ol><li>We can convert each line in the Truth Table or each shaded section of the Venn Diagram to a single Boolean Logic term that uses all available variables, and then use the rules of Boolean Algebra to reduce the expression to simpler terms. This is generally more comfortable for those who are already well versed in math and algebra, but others may struggle to properly reduce these terms directly on paper.</li><li>We can use a bit of intuition about the Venn Diagram or the real-world scenario we are trying to model to combine adjacent shaded sections of the Venn Diagram together into simple Boolean Logic terms and connect them together. This is what we show in the worked example video, but it does take a bit of experience to become comfortable with this process.</li><li>We can use <a href=https://en.wikipedia.org/wiki/Karnaugh_map rel=external target=_blank>Karnaugh Maps</a> to directly reduce the statement and produce a Boolean Logic expression. This is typically done in introductory logic circuit design courses in computer engineering, but we rarely teach it anymore in computer science. It is a handy method to know, especially for larger numbers of variables.</li></ol><p>So, let&rsquo;s go through these three methods and see how they relate.</p><h3 id=method-1---using-boolean-algebra>Method 1 - Using Boolean Algebra</h3><p>Let&rsquo;s start by directly converting the information in our Truth Table and Venn Diagram to individual Boolean Logic terms. To do this, look at each row in the Venn Diagram where the &ldquo;OUT&rdquo; column is 1. Then, for each variable in that row, we either include it in the term directly if it is a <code>True</code> or <code>1</code> in the input, or else we include it with a NOT symbol ($\neg$) before the variable if it is a <code>False</code> or <code>0</code> in the input. We <strong>must</strong> include these false variables in our terms, or else we would get different results (i.e. $A \wedge B$ is <strong>not</strong> the same as $A \wedge B \wedge \neg C$)</p><p>So, we would end up with these three terms from our truth table above:</p><ol><li>A is false but B and C are true: $ \neg A \wedge B \wedge C$</li><li>B is false but A and C are true: $ A \wedge \neg B \wedge C$</li><li>A and B and C are true: $ A \wedge B \wedge C$</li></ol><p>Finally, our full Boolean Expression using these three terms would combine them using the OR ($\vee$) symbol. This is because the &ldquo;OUT&rdquo; column in the Truth Table is <code>True</code> or <code>1</code> if <strong>any one or more</strong> of these terms are <code>True</code>. So, our resulting Boolean Expression at this point would be the following:</p><p>$$
(\neg A \wedge B \wedge C) \vee (A \wedge \neg B \wedge C) \vee (A \wedge B \wedge C)
$$</p><p>At this point, we can stop if we don&rsquo;t care about reducing the expression to simpler terms. So, once again, there is a direct one-to-one translation from either a Truth Table or Venn Diagram to a Boolean Logic expression that is in this form. In fact, this form is known as the <a href=https://en.wikipedia.org/wiki/Disjunctive_normal_form rel=external target=_blank>Disjunctive Normal Form</a> of a Boolean Logic expression (though it is not the reduced form). A great way to remember this form is that it is an <strong>OR</strong> of <strong>ANDs</strong> (the individual terms are all <strong>AND</strong> operators, and then the terms are combined using <strong>OR</strong> operators).</p><p>Before we go any further, we can check our work by entering this formula into <a href=https://www.wolframalpha.com/ rel=external target=_blank>Wolfram Alpha</a> and checking the Venn Diagram and Truth Table it produces and make sure they match our original setup. While it is possible to enter all of the fancy Boolean Logic symbols into Wolfram Alpha (it does understand them), it is often easiest to just convert them to their English counterparts as shown below:</p><div class=highlight dir=auto><pre tabindex=0><code>(NOT A AND B AND C) OR (A AND NOT B AND C) OR (A AND B AND C)</code></pre></div><p>You can also click <a href="https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29" rel=external target=_blank>this link</a> to go directly to Wolfram Alpha with this input provided.</p><p>First, we can check that our input is parsed correctly since it matches our Boolean Logic expression at the top:</p><p><a href=#R-image-73b552dc02fdcd032c336bcc0a94d09e class=lightbox-link><img alt="Wolfram Alpha Boolean Expression" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-73b552dc02fdcd032c336bcc0a94d09e><img alt="Wolfram Alpha Boolean Expression" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram1.png></a> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>We can also look at the Truth Table and Venn Diagrams further down:</p><p><a href=#R-image-08c99d59ae253e0afae007298ea93065 class=lightbox-link><img alt="Wolfram Alpha Truth Table" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-08c99d59ae253e0afae007298ea93065><img alt="Wolfram Alpha Truth Table" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram2.png></a> <sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>
<a href=#R-image-d1d477168e98cd940fc2284d3ae5be83 class=lightbox-link><img alt="Wolfram Alpha Venn Diagram" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-d1d477168e98cd940fc2284d3ae5be83><img alt="Wolfram Alpha Venn Diagram" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram3.png></a> <sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>Notice that the Truth Table is ordered a bit differently than what we see above (it is reversed), and the Venn Diagram is rotated a bit, but hopefully it becomes pretty clear that we have a match! So, our translation from the Truth Table to a Boolean Logic Expression is valid!</p><h4 id=method-1a---reducing-expressions>Method 1A - Reducing Expressions</h4><p>Once we have a valid Boolean Logic Expression, we can use the laws of Boolean Algebra to reduce it. We cover some of these laws earlier in this chapter, but <a href=https://en.wikipedia.org/wiki/Boolean_algebra rel=external target=_blank>Wikipedia</a> has a good listing of them as well. We&rsquo;ll refer to the laws as they are described in Wikipedia as we perform these operations.</p><p>First, it is often very helpful to remember that, in many cases, <code>AND</code> ($\wedge$) can be treated similar to multiplication ($\times$), while <code>OR</code> ($\vee$) can be treated like addition ($+$). So, in some fields (such as computer engineering), it is common to rewrite the statement above like this:</p><p>$$
(\neg A B C) \vee (A \neg B C) \vee (A B C)
$$</p><p>This may make some operations more intuitive, especially where we are &ldquo;factoring out&rdquo; or &ldquo;distributing&rdquo; a term by applying the <strong>Distributivity</strong> laws. So, we&rsquo;ll use this modified notation while performing our Boolean Algebra reductions.</p><p>Unfortunately, reducing this expression is actually a bit complex, because there is not an obvious starting place. Instead, what we need to do first is duplicate a term by applying the inverse of the <strong>Idempotence of $\vee$</strong> law. This law states that $ x \vee x = x $, so we can invert it by replacing any single term $x$ with two instances of the term that are connected with the <code>OR</code> ($\vee$) operator. We&rsquo;ll do this to the last term in the expression for now:</p><p>$$
(\neg A B C) \vee (A \neg B C) \vee (A B C) \vee (A B C)
$$</p><p>Next, we want to group some similar terms together to make later operations a bit more obvious. So, we&rsquo;ll apply the <strong>Commutativity of $\vee$</strong> law to rearrange the terms, and also use the <strong>Associativity of $\vee$</strong> law to group some terms together:</p><p>$$
\Big( (\neg A B C) \vee (A B C) \Big) \vee \Big( (A \neg B C)\vee (A B C) \Big)
$$</p><p>Now we can start to simplify things a bit. In both groups of terms, we notice that they each share the variable $C$, so we can apply the inverse of the <strong>Distributivity of $\wedge$ over $\vee$</strong> law to &ldquo;factor out&rdquo; that term. Notice that this is very similar to how we can apply a similar law in ordinary algebra:</p><p>$$
\Big( C \wedge \big((\neg A B) \vee (A B) \big) \Big) \vee \Big( C \wedge \big( (A \neg B)\vee (A B) \big) \Big)
$$</p><p>After that, we&rsquo;ll see that the first pair of remaining terms shares the variable <code>B</code>, while the second pair of terms shares the variable <code>A</code>. So, we can once again apply the <strong>Distributivity of $\wedge$ over $\vee$</strong> law to &ldquo;factor out&rdquo; those shared terms in each pair:</p><p>$$
\Big( C \wedge \big(B \wedge (\neg A \vee A) \big) \Big) \vee \Big( C \wedge \big(A \wedge (\neg B \vee B) \big) \Big)
$$</p><p>Now we can start to remove some terms. The <strong>Complementation 2</strong> law in Wikipedia states that $x \vee \neg x = 1$, which means that we can replace a term and the inverse of that term connected with an OR ($\vee$) operator with the value <code>True</code> or <code>1</code>. We&rsquo;ll do this for both $A$ and $B$ terms:</p><p>$$
\Big( C \wedge \big(B \wedge 1 \big) \Big) \vee \Big( C \wedge \big(A \wedge 1 \big) \Big)
$$</p><p>Next, we can use the <strong>Identity for $\wedge$</strong> law, which states that $x \wedge 1 = x$, to effectively remove those <code>True</code> or <code>1</code> terms from the statement. Again, remember that in regular algebra, we would know that the term $1A$ would be equivalent to just $A$, so if we rewrite $A \wedge 1$ as just $1A$ and then just $A$, it feels very logical!</p><p>$$
( C B ) \vee ( C A )
$$</p><p>Finally, if desired, we can apply the <strong>Distributivity of $\wedge$ over $\vee$</strong> law one more time to &ldquo;factor out&rdquo; the $C$ variable again:</p><p>$$
C \wedge (B \vee A)
$$</p><p>There we go! Both of those reductions are valid minimal forms of the Boolean Logic Expression. Once again, we can go back to Wolfram Alpha to check our work:</p><p><a href=#R-image-bd7f82d7adc99729b382f245cca8b3a8 class=lightbox-link><img alt="Wolfram Alpha Minimal Forms" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/wolfram4.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-bd7f82d7adc99729b382f245cca8b3a8><img alt="Wolfram Alpha Minimal Forms" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/wolfram4.png></a> <sup id=fnref3:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>In that screenshot, we can see both the minimal <a href=https://en.wikipedia.org/wiki/Disjunctive_normal_form rel=external target=_blank>Disjunctive Normal Form</a> (DNF) as well as the minimal <a href=https://en.wikipedia.org/wiki/Conjunctive_normal_form rel=external target=_blank>Conjunctive Normal Form</a> (CNF) for the expression.</p><h3 id=method-2---using-intuition>Method 2 - Using Intuition</h3><p>Another great way to convert a Truth Table or Venn Diagram into a Boolean Logic Expression is to use a bit of intuition. The video earlier in this chapter showed one way to do this suing the Venn Diagram, but let&rsquo;s use another method - using a concrete example!</p><p>For this example, let&rsquo;s assume that we have been given the following rules:</p><ul><li>If Mom says yes and it is sunny outside, we can go swimming even if we don&rsquo;t have friends over.</li><li>If Mom says yes and we have friends over, we can go swimming even if it isn&rsquo;t sunny outside.</li><li>If Mom says yes, we can go swimming if it is sunny outside and we have friends over.</li></ul><p>We can build a Truth Table using these rules as shown below:</p><table><thead><tr><th style=text-align:center>Friends Over (A)</th><th style=text-align:center>Sunny Outside (B)</th><th style=text-align:center>Mom Says Yes (C)</th><th style=text-align:center>Go Swimming</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr></tbody></table><p>Ahh! Notice that this Truth Table is identical to the Truth Table given in Example 1 shown above! We have created a set of rules that immediately generate the same Boolean Logic Expression that matches our example. It may take a little bit of thinking, and we have to state the rules very clearly, but generally we can always create a set of rules that clearly describe any Truth Table. In practice, we often are starting with a set of rules like this (in our specifications document), and we are trying to build a Boolean Logic Expression that we can use in our code as we implement those specifications in our program.</p><p>Now, let&rsquo;s use a bit of intuition about those rules above to generate a Boolean Logic Expression. If we really want to go swimming, we&rsquo;ll quickly realize that there are two main things that we need to have:</p><ol><li>Mom has to say yes (C), and</li><li>It must either be sunny outside (B) or we have to have friends over (A) (or both)</li></ol><p>Look closely at those rules! Just by talking through the scenario, we have created a Boolean Logic expression. Let&rsquo;s rewrite it:</p><blockquote><p>Mom must say yes <code>AND</code> (it must be sunny outside <code>OR</code> we have to have friends over)</p></blockquote><p>If we replace each part with the corresponding variable, we can find the corresponding statement:</p><p>$$
C \wedge (B \vee A)
$$</p><p>A similar way to state the rules might be:</p><ol><li>Mom has to say yes and it has to be sunny, or</li><li>Mom has to say yes, and we have to have friends over</li></ol><p>Once again, we can rewrite that a bit to make the Boolean Logic operators more obvious:</p><blockquote><p>(Mom must say yes <code>AND</code> it must be sunny outside) <code>OR</code> (Mom must say yes <code>AND</code> we have to have friends over)</p></blockquote><p>Finally, we can replace those parts with variables to get the corresponding statement:</p><p>$$
(C \vee B) \wedge (C \vee A)
$$</p><p>So, as we can see, applying a bit of intuition to a real-world example that creates the same situation can make it pretty easy to work out a simple Boolean Logic Expression from a Truth Table or Venn Diagram.</p><h3 id=method-3---karnaugh-maps>Method 3 - Karnaugh Maps</h3><p>The third method would be to use a Karnaugh Map. We won&rsquo;t go into this method in too much depth, but we&rsquo;ll briefly show how it works. There are some great online resources to learn more about applying Karnaugh Maps in this context.</p><p>First, we&rsquo;ll start with a blank 3 variable Karnaugh map:</p><p><a href=#R-image-91e174601d55d39884ff865ba9812f74 class=lightbox-link><img alt="Blank Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-91e174601d55d39884ff865ba9812f74><img alt="Blank Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh.png></a> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>Then, we&rsquo;ll input the desired outputs from the Truth Table in each square of the Karnaugh Map:</p><p><a href=#R-image-eab737acc54499e627602b4fa1b08bb4 class=lightbox-link><img alt="Filled Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh_filled.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-eab737acc54499e627602b4fa1b08bb4><img alt="Filled Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh_filled.png></a></p><p>Now, we&rsquo;ll group connected terms. These groups can be either rectangular or square boxes. So, for this Karnaugh Map, there are two groups:</p><p><a href=#R-image-06ea4408ef3a97e70b01d2a46180d259 class=lightbox-link><img alt="Grouped Karnaugh Map" class="border lazy lightbox figure-image" loading=lazy src=/cs-zero/images/3/karnaugh_grouped.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-06ea4408ef3a97e70b01d2a46180d259><img alt="Grouped Karnaugh Map" class="border lazy lightbox lightbox-image" loading=lazy src=/cs-zero/images/3/karnaugh_grouped.png></a></p><p>Finally, for each group, we identify the variables that don&rsquo;t change within that group, and those become our terms. So, for the group in the bottom row, we see that both $A$ and $C$ are the same, but $B$ changes. So, one term we find is $AC$. For the group in the third column, we see that $B$ and $C$ are the same, but $A$ changes, so our other term is $BC$. Then, we combine those two terms together using the <code>OR</code> ($\vee$) operator to get this statement:</p><p>$$
(AC) \vee (BC)
$$</p><p>There we go! That is once again one of our minimal Boolean Logic expressions found earlier.</p><h2 id=connection-to-programming>Connection to Programming</h2><p>Why does all of this matter? Well, when we are trying to convert a real-world situation to code, it is often helpful (but not necessary) to be able to reduce our Boolean Logic expressions to simpler terms.</p><p>Let&rsquo;s go back to the concrete example shown above. If we wanted to write a Python program for this, there are a few ways we could build it.</p><p>First, here&rsquo;s what it would look like if we just directly encoded the rules as written:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># bool() returns False if the input is the number 0, otherwise True</span>
</span></span><span style=display:flex><span><span style=color:#75715e># so we have to convert the string to an int first</span>
</span></span><span style=display:flex><span>sunny <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Is it sunny outside? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>friends <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Do you have friends over? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>mom <span style=color:#f92672>=</span> bool(int(input(<span style=color:#e6db74>&#34;Did Mom say yes? (1 = yes, 0 = no)&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34; 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Rules:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes and it is sunny outside, we can go swimming even if we don&#39;t have friends over.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes and we have friends over, we can go swimming even if it isn&#39;t sunny outside.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>* If Mom says yes, we can go swimming if it is sunny outside and we have friends over. 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (mom <span style=color:#f92672>and</span> sunny <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> friends)
</span></span><span style=display:flex><span>  <span style=color:#f92672>or</span> (mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> sunny) 
</span></span><span style=display:flex><span>  <span style=color:#f92672>or</span> (mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> sunny):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>We could also use <code>if-else</code> statements instead of the <code>or</code> operator to achieve a similar effect:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> sunny <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> friends:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> sunny:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> friends <span style=color:#f92672>and</span> sunny:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>: 
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>However, in both cases, these programs are more complex than they actually need to be, and it may make things more difficult to debug down the road. So, with a little intuition and the ability to reduce Boolean Logic expressions effectively (and <em>correctly</em>), we can simplify this code quite a bit:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> mom <span style=color:#f92672>and</span> (sunny <span style=color:#f92672>or</span> friends): 
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We can go swimming&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;We cannot go swimming&#34;</span>)</span></span></code></pre></div><p>Hopefully you can see the value in that much simpler program, both in terms of how easy it is to understand and debug, but possibly how much more efficient it is overall since it has fewer comparison to make.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Image Source: <a href=https://www.allaboutcircuits.com/textbook/digital/chpt-8/boolean-relationships-on-venn-diagrams/ rel=external target=_blank>https://www.allaboutcircuits.com/textbook/digital/chpt-8/boolean-relationships-on-venn-diagrams/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Image Source: <a href="https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29" rel=external target=_blank>https://www.wolframalpha.com/input?i=%28NOT+A+AND+B+AND+C%29+OR+%28A+AND+NOT+B+AND+C%29+OR+%28A+AND+B+AND+C%29</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Image source: <a href=https://www.learnelectronicswithme.com/2021/09/karnaugh-map-and-steps-to-solve.html rel=external target=_blank>https://www.learnelectronicswithme.com/2021/09/karnaugh-map-and-steps-to-solve.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pattern-on-the-stone-reading>Pattern on the Stone Reading</h1><p>Read Pattern on the Stone, Chapter 2.</p><p>The Pattern on the Stone: The Simple Ideas that Make Computers Work by W. Daniel Hillis. <strong>ISBN 046502596X</strong>, newer version is also available and will work fine</p><footer class=footline></footer></article></section></div></main></div><script src=/cs-zero/js/clipboard/clipboard.min.js?1767726213 defer></script><script src=/cs-zero/js/perfect-scrollbar/perfect-scrollbar.min.js?1767726213 defer></script><script src=/cs-zero/js/theme.min.js?1767726213 defer></script><script src=/cs-zero/js/embed-iframe.min.js?1767726213 defer></script></body></html>