<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Engineering :: Intro CS Textbook</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/index.html</link><description/><generator>Hugo</generator><language>en-us</language><managingEditor>altcs@ksu.edu (K-State CS Faculty)</managingEditor><webMaster>altcs@ksu.edu (K-State CS Faculty)</webMaster><lastBuildDate>Thu, 27 Jun 2024 12:25:42 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/01-introduction/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/01-introduction/index.html</guid><description>Resources Slides Video Script Welcome back everyone. In this video we’re gonna be talking about software engineering. Now you should remember this particular machine the ENIAC, which was the first electronic computer in the United States. Programming the ENIAC was a really slow and laborious process though. To load a program, ENIAC’s programmers Pictured here is Gloria Ruth Gordon, and, well, later Bolotsky, and Esther Gordon would physically rewire the hardware and a new configuration corresponding to the calculations indicated by the programmers. And so you can see them here moving actually the wires from different plug boards for the computer to actually make different calculations and operations work. So the task was made even more difficult by the secrecy involved with the machine. Initially, programmers weren’t even able to see the schematics of the machine and had to pass their wiring instructions belong to the technicians. So the programmers didn’t weren’t even instructed on how the actual machine was built or how it worked. And they couldn’t even actually run their program themselves. So you could imagine that that would be a really difficult task to actually accomplish writing successful programs for a computer that you didn’t even know how it worked.</description></item><item><title>Margaret Hamilton - 2017 CHM Fellow</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/02-margaret-hamilton/index.html</link><pubDate>Wed, 27 May 2020 10:53:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/02-margaret-hamilton/index.html</guid><description/></item><item><title>Software Development Life Cycle Part 1</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/03-sdlc-1/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/03-sdlc-1/index.html</guid><description>Resources Slides Video Script Now that we’ve talked a bit a little bit about the history of software development and software engineering and how it’s evolved over the years, what are some of the key activities that we actually engage with in this process. Now, you’ve already used and worked with a lot of these already, even if you haven’t really made the connection to them yet. Software Engineering overall will come with quite a few different processes along with it. But overall, you can kind of expect these six different stages.</description></item><item><title>Software Development Life Cycle Part 2</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/04-sdlc-2/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/04-sdlc-2/index.html</guid><description>Resources Slides Video Script Let’s take a look into a few other different methodologies in software development. So this one is in complete contrast to the waterfall model of software development and pretty much all other development methodologies. Because this methodology, there really isn’t anything to it. It’s generally known as cowboy coding or code and fix. Now, this in many ways, is the anti software engineering approach, where planning, testing documentation at pretty much everything, all of that is ignored, or immediately writing code. And predictably, this leads to a lot of what we refer to as spaghetti code. And so it’s just mangled structure that has really no clear way to it at sprinkled with sub optimal algorithms memory leaks, structural issues is just a mess, right? Imagine getting out a box of Christmas lights that were just thrown into a box and in January, and you go back in December, try to put those Christmas lights up. And magically, they’ve aimed together into this big ball that takes hours upon hours to actually unravel. And sometimes it’s just easier to throw it away and start from scratch.</description></item><item><title>Software Development Life Cycle Part 3</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/05-sdlc-3/index.html</link><pubDate>Fri, 28 Aug 2020 16:27:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/05-sdlc-3/index.html</guid><description>Resources Slides Video Script The iterative development process, or the iterative development model breaks down software development into much smaller segments. This allows for a lot more change and variation to the development cycle. So the iterative development process works by working through many waterfalls. And so if you look at each one of these chunks here, each one of these stages, they’re pretty much the waterfall process. And so overall requirements are gathered, then we analyze those requirements develop, implement test, and this is a cycle right? In this case, our waterfall is circular so we can keep on trying Go Go, go, go go. And then we’re going to release a prototype or a version of our product. As we go through this each time a release, we demonstrate that to our customer. And get feedback and then we’ll work that back into our next cycle. And so we just keep on iterating this until we are doing our final release to our customer.</description></item><item><title>Software Engineering (Crash Course)</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/06-se-crash-course/index.html</link><pubDate>Wed, 27 May 2020 10:53:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/06-se-crash-course/index.html</guid><description/></item><item><title>Pattern on the Stone Reading</title><link>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/07-pots-reading/index.html</link><pubDate>Wed, 27 May 2020 10:53:26 -0500</pubDate><author>altcs@ksu.edu (K-State CS Faculty)</author><guid>https://textbooks.cs.ksu.edu/cs-zero/i-concepts/09-software-engineering/07-pots-reading/index.html</guid><description>Read Pattern on the Stone, Chapter 8.</description></item></channel></rss>