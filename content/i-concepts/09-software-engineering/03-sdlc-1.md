---
title: "Software Development Life Cycle Part 1"
pre: "9.3 "
weight: 15
date: 2020-08-28T16:27:26-05:00
---

{{< youtube KXHfIKWltGc >}}

#### Resources
* [Slides](slides/9-SoftwareEngineering.pdf)

#### Video Script

Now that we've talked a bit a little bit about the history of software development and software engineering and how it's evolved over the years, what are some of the key activities that we actually engage with in this process. Now, you've already used and worked with a lot of these already, even if you haven't really made the connection to them yet. Software Engineering overall will come with quite a few different processes along with it. But overall, you can kind of expect these six different stages. 

Now, to begin the process off, we're going to start with requirements gathering are going to actually go around and collect information about the software that we're actually being tasked with to develop. So this involves with going and meeting with clients meeting with users meeting with business folks meeting with just about Anybody and everybody that might be a stakeholder or involved with actually using that software or funding that particular kind of project. 

Now, once we have gathered all of the requirements for the software, then we can make the jump into the software design. So here we're going to start to architect the project and lay it out overall, but we haven't actually even done any programming yet. That doesn't actually typically happen until the design has been actually completed. So once we actually start the implementation, then after the code has been finished, or at least a stage of the code has been finished, that code is then split off into the testing phase. Sometimes the implementation and testing phase, you might see done as one as if you're on a small team or depending on the kind of approach you're actually taking to the development lifecycle. 

But after the software has been fully tested, then it gets deployed or installed. And then it goes into like a maintenance mode, right. So a lot of times you get the first Windows updates and various other software updates on mobile apps and games and everything in between. So that's the maintenance phase, right, where we're trying to update patch, fix anything that may actually been broken, or things that we didn't catch during the testing phase. But you see that now I'm back at the requirements gathering. 

Most of the software development life cycles that we actually see an encounter are a never ending cycle. Software is never perfect the first time around that we actually build it. So more often than not after creating what we refer to as a prototype. We're going to end up going back to the requirements gathering stage, talk to our customers, talk to our consumers, talk to our stakeholders, and give another shot at it. Whether or not whether it's just a, a simple update, or feature addition, or even a complete rewrite in some cases if we didn't get it right the first time. But let's take a look at some of the early software development life cycles that were developed. Now, you'll notice that these each of the activities that we just talked about before lend themselves very well to a systematic step by step approach, where each activity is followed by the next and we kind of loop back onto this. 

This is essentially the approach that was developed as a standard strategy for software engineering after the work by Margaret Hamilton in the early 1960s. And over the next few decades, an approach that we call the waterfall model of software development for reasons obvious from the graphic, where each phase flows from the next into a highly linear fashion now In the waterfall development, as I mentioned, right, this is a very linear process. This isn't like the software development lifecycle that we've showcased earlier, where we start with the requirements gathering. And we cycle through each phase. And we end back up at the beginning of the waterfall method assumes that each phase is done in one shot, so there's no reduce. 

So we gather the requirements and design the software, implement it, test it, so verification, and then we go into the maintenance mode. So of course, we install and deploy the software in between there. But once we've deployed the software and enter maintenance mode, we're not going to actually be going back and doing more requirements gathering or redesigning anything, it's just some simple bug fixes at that point. So, it emphasizes the waterfall model emphasizes that the actions are arranged as discrete phases in sequential order, although depending on the model that you actually look at some splashback is acceptable. So if you imagine an actual waterfall, some water gets splashed back up and falls back down. So maybe we get to the implementation phase, but we recognize that our design is severely flawed. So we may bump back up, change the design a little bit, and go back down into the actual coding phase. 

But here, the entire system, and the waterfall model is implemented, designed and deployed all at once. So planning, scheduling, target dates, budgets, all of those things are set in advance. Most of the time, these are often set by contracts. So there's really no flexibility there with as far as funding and deployment dates go. A lot of times with the waterfall model, there's a lot of extensive documentation and very tight control. So this is a very heavily managed process. So this is really useful for processes that require a little A lot of structure. And we'll talk about some other models here in a little bit that have a lot less structure, and that offer a much more flexible approach to software design. 

Additionally, during this time, scientific management techniques were adapted for use in the management of software developments. One of the landmark books capturing this evolution was Barry Boehm's Software Engineering Economics book, where he argued for considering trade offs between adapting existing software and creating new software on economic terms. And so we use statistical analyses to develop equations like this one, seeking to equate development time in main years to the metric of software lines of code, or SLOC. Now, there are there's a lot of debate around measuring the productivity of let's say, developers and cost of software based off of the number of lines of code that are actually produced. And there's a lot of fallacies behind that metric as well. But a lot some people actually some fall into that trap. 

Another book from that particular time period refutes some of those both some of those arguments as I mentioned, they were very controversial. But this book, the mythical man month, details many software engineering management fallacies. Like, for example, adding more programmers to a late project will absolutely right help it finish sooner, but not so much. In practice, bringing new developers up to speed consumes much of the current team's time, and overall slows the development. So let's say you've been working on this really big important project for nine months. But you are a couple, maybe a month or two behind schedule. So management comes in brings in new developers to try to help get you back on track. But it actually ends up putting you back farther in your time schedule because you had to stop your productivity to get the new people caught back up to speed. 

Another fallacy here that is discussed in the mythical man month is the use of crunch time. Crunch Time is typically portrayed as an increase in productivity, right. So, you know, spending, you know, 60 to 80 hours a week to meet that deadline. So, pulling 18-20 hour days, programming all night, I'm sure you have probably done this when studying for a really big exam. Crunch Time doesn't necessarily increase productivity. Studies have actually shown that a breakeven point for let's say software development lies around about 35 hours. There's been research that shows about 30 a year your average limit for a software developer is about 30. 35 hours of programming per week. Beyond that, a fatigue programmers introduce more bugs into their code at a faster rate than they're actually removed. So that ends up costing a lot more money and time because they're, you know, fatigued. Developers that have just been coding for too long or going to be more prone to produce bad code. I'm sure some of you some some of us have experienced this as a student, as I mentioned, as you're studying, you know, when you're really exhausted, or have had way too much caffeine are way too much coffee. You may not be studying as efficiently or or productive. Your productivity may not increase proportionally to the amount of time that you're you're actually spending versus the amount of time you're spending when you weren't exhausted. 

