<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content=" "><meta name=author content="K-State CS Faculty"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cryptography :: Intro CS Textbook"><meta name=twitter:description content=" "><meta property="og:url" content="https://textbooks.cs.ksu.edu/cs-zero/iii-topics/16-cryptography/"><meta property="og:site_name" content="Intro CS Textbook"><meta property="og:title" content="Cryptography :: Intro CS Textbook"><meta property="og:description" content=" "><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Cryptography :: Intro CS Textbook"><meta itemprop=description content=" "><meta itemprop=datePublished content="2020-10-24T00:23:05-05:00"><meta itemprop=dateModified content="2023-09-12T16:09:31-05:00"><title>Cryptography :: Intro CS Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cs-zero/iii-topics/16-cryptography/ rel=canonical type=text/html title="Cryptography :: Intro CS Textbook"><link href=/cs-zero/iii-topics/16-cryptography/index.xml rel=alternate type=application/rss+xml title="Cryptography :: Intro CS Textbook"><link href=/cs-zero/iii-topics/16-cryptography/tele.html rel=alternate type=text/html title="Cryptography :: Intro CS Textbook"><link href=/cs-zero/iii-topics/16-cryptography/embed.html rel=alternate type=text/html title="Cryptography :: Intro CS Textbook"><link href=/cs-zero/css/fontawesome-all.min.css?1756074760 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/fontawesome-all.min.css?1756074760 rel=stylesheet></noscript><link href=/cs-zero/css/nucleus.css?1756074760 rel=stylesheet><link href=/cs-zero/css/auto-complete.css?1756074760 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/auto-complete.css?1756074760 rel=stylesheet></noscript><link href=/cs-zero/css/perfect-scrollbar.min.css?1756074760 rel=stylesheet><link href=/cs-zero/css/fonts.css?1756074760 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cs-zero/css/fonts.css?1756074760 rel=stylesheet></noscript><link href=/cs-zero/css/theme.css?1756074760 rel=stylesheet><link href=/cs-zero/css/theme-auto.css?1756074760 rel=stylesheet id=R-variant-style><link href=/cs-zero/css/chroma-auto.css?1756074760 rel=stylesheet id=R-variant-chroma-style><link href=/cs-zero/css/variant.css?1756074760 rel=stylesheet><link href=/cs-zero/css/print.css?1756074760 rel=stylesheet media=print><link href=/cs-zero/css/format-print.css?1756074760 rel=stylesheet><script src=/cs-zero/js/variant.js?1756074760></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cs-zero",window.index_js_url="/cs-zero/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cs-zero/css/custom.css?1756074760 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cs-zero/iii-topics/16-cryptography/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cs-zero/iii-topics/><span itemprop=name>CS Topics</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Cryptography</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cs-zero/iii-topics/15-compression-error-checking/08-9algs-ch7/ title="Nine Algorithms that Changed the Future Ch 7 - Data Compression (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cs-zero/iii-topics/16-cryptography/01-intro/ title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 16</div><h1 id=cryptography>Cryptography</h1><p><a href=#R-image-b217c43f63a730508e64dd54394034fc class=lightbox-link><img alt=Scytale class="border lazy lightbox noshadow figure-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/b/b2/Skytala%26EmptyStrip-Shaded.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b217c43f63a730508e64dd54394034fc><img alt=Scytale class="border lazy lightbox noshadow lightbox-image" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/b/b2/Skytala%26EmptyStrip-Shaded.png></a></p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Cryptography</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><a href="https://www.youtube.com/watch?v=s5JfNLk74Oc">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>In this module, we&rsquo;re going to take a look at one of the most important applications of computer science and modern technology- the field of cryptography. Cryptography is the study of ways to communicate securely and privately in the presence of third parties. If you think about it, cryptography is very important today with the rise of the Internet and modern technology. Any data that&rsquo;s transmitted over the internet can be intercepted by just about anyone from your internet service provider all the way to the website that you&rsquo;re communicating with, and anybody in between. Remember, the internet is built upon open standards, and so anybody can understand the packet formats and deconstruct them very quickly. So we need a way that we can encrypt and secure the data inside of those packets. So they can only be opened by the intended recipients, and that&rsquo;s where the field of cryptography comes in. There were lots of historical Computer Science professionals interested in cryptography. Charles Babbage was very fascinated by it. Alan Turing was especially involved in cryptography, and Claude Shannon, were all involved in the field of cryptography. Also, surprisingly, the author Edgar Allan Poe was one of the people that was really excited about cryptography outside of computer scientists, and in fact, helped popularize cryptography as a word game that you might see in your newspaper.</p><p>So let&rsquo;s take a look at an example of what cryptography might look like. When I used to teach this in a classroom, I would usually start by having strips of paper with this particular message printed out and laid all over the tables, and I would encourage students to see if they could decrypt this particular message. So on the slide here, you see the same text that I have written on the strip of paper, but it can be kind of hard to decrypt this message. So take a look at it and see if you can come up with what this message should say. I&rsquo;ll give you a hint. If you have a marker nearby, or something that&rsquo;s about this big and round kind of dowel shaped, that might help. Still need a hint? Well, what happens if I take this piece of paper, and I wrap it around the marker like so. Take it and wrap it. Just like that. So now I&rsquo;ve taken this message, and I&rsquo;ve wrapped it around the marker. And you&rsquo;ll notice that when you do this, the text kind of starts to line up, you can see that there are characters that start to line up. That&rsquo;s what this is. This message is actually an example of one of the earliest forms of cryptography called a Scytale. A Scytale was round dowel rod, kind of like this marker that you could use to encrypt and send messages. And it was used all the way back in ancient Roman and Greek times. For example, if you wanted to send a message to somebody, you could take a strip of leather and wrap it around the Scytale, and then you would impress the characters of the message across the strip of leather on the Scytale. Then you would unwrap it, and you&rsquo;d end up with a string of random characters that look something like this on the paper, and you could send that piece of leather out into the field. And of course, the only way to decrypt it would be to know how to decrypt it, and to have a Scytale that was the same size as the one that was used to encode that message. And so if you were very careful, you can use Scytale of different sizes to encode different messages using the same technique. So if we start with this message in the class, you realize that a Scytale is really just an iterative cipher, where we start with about every six letters. So we have this is a Scytale example. That&rsquo;s what that message would say. Now, of course, you&rsquo;ll notice I&rsquo;ve added the letter Q in there a couple of times. And that&rsquo;s actually very commonly done in the field of cryptography. As long as the message is understandable to the person receiving it when they decrypt it, you can add some random characters in there that don&rsquo;t make any sense once you have decrypted the message, but it can really help foul up people trying to decrypt the message and use every single character in the message. It&rsquo;s a neat little trick to make your encryption just that much more unbreakable.</p><p>There are lots of examples of early ciphers that have been used throughout history, we looked at one called the Scytale. There are also things such as substitution ciphers. A substitution cipher is where you take the letters in your text and you simply replace them one for the other. For example, all B&rsquo;s become Q&rsquo;s. All K&rsquo;s become G&rsquo;s, and so on and so forth. If you read the newspaper or do puzzle books, you might have seen a puzzle called a crypto quip. That is actually an example of a substitution cipher, and it&rsquo;s one that was made popular by Edgar Allan Poe. Of course, putting your crypto equipment in newspaper might lead you to think that it&rsquo;s easily breakable, and it totally is. One of the best ways that you can break things that are substitution ciphers is by frequency analysis. You look for the most frequent characters, and then you assume that those would be probably the most frequent characters in the English language. For example, in English were helped out a lot by the game show Wheel of Fortune. We know that the letters R S T L N E are some of the most frequently used characters in the English language. So if we find the most frequent substituted letters in our substitution cipher, we can try those characters and see what works. Also things such as short words, two letter words, things like that really helped break a crypto crypt very, very easily.</p><p>So then you get to more advanced ciphers called polyalphabetic ciphers. And these are like substitution ciphers, but much, much more advanced. For example, you would substitute letters not only based on the previous letter, but the position and all sorts of other things. Polyalphabetic ciphers were first described all the way back in the ninth century AD by the Islamic mathematician al-Kindi, but they were later explained in a lot more detail by French mathematician Leon Battista Alberti in 1467. So of course, once again, polyalphabetic ciphers can seem very complicated. But once you really discover how many different substitution ciphers there are in a polyalphabetic cipher, then it reduces the problem to simply breaking each of those individual substitution ciphers one at a time. So while they&rsquo;re still powerful, they&rsquo;re not nearly unbreakable, like we might think today.</p><p>Another example of an early cipher would be the tabula recta. A tabula recta, like you see here is all of the letters of the alphabet are arranged in a grid. And you can see that each grid shifts by one letter. Then with a table such as this, there are a lot of different algorithms you can use to encrypt data. For example, you could use the previous letter in the data to encrypt the next letter that you want to encrypt. So if we want to encrypt the word HELLO, we would start by using H to encrypt H. So we get H, but then the next letter E would be encrypted using the H line and it becomes L, then we use the next L to encrypt L. So we would encrypt L, which would be W, then we use W to encrypt another L, which becomes H. And then we use H to encrypt O, which becomes V. And so by following that process through, we can use the tabula recta to create a very, very hard to break cipher just by following an algorithm. And of course, you can do all sorts of different things with this and it creates a pretty powerful cipher, not one that is completely undecipherable. But it&rsquo;s a very powerful way to do something using a very simple table such as this. And this is actually the same basis of things like the decoder rings that you might have heard about that were sold in cereal boxes years ago, they use the same basic idea. If you have the table or the decoder ring or whatever the ciphers key is, then it becomes very easy to break but without the key, you have to discover the key in order to break it easily.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=enigma-machine-part-1>Enigma Machine (Part 1)</h1><a href="https://www.youtube.com/watch?v=g2effYN7WNg">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>In this module, we&rsquo;re going to take a look at one great example of the use of cryptography in computer science. And to do that we have to go all the way back in history to look at World War Two. This slide right here shows the height of German occupation of Europe during World War Two. And during that time, the Germans were sending encrypted messages to all of their field commanders using a system that was very, very much thought to be uncrackable at that time. So we&rsquo;re going to take a look at what that system is, how it works, and how the Allies were actually able to crack it by taking advantage of some of the knowledge that they had about such a system. Oh, and of course, some of this information would have been very much top secret, and a lot of it was classified up until just a few decades ago. So it&rsquo;s really an interesting time to take a look back at what was going on during World War Two, and take a look at how the Germans were able to build a very interesting encryption system that was then later broken by the allies. So let&rsquo;s start by taking a look at a quick video demonstrating the German&rsquo;s Enigma machine and how it worked.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=enigma-machine---numberphile>Enigma Machine - Numberphile</h1><a href="https://www.youtube.com/watch?v=G2_Q9FoD-oQ">YouTube Video</a><p>Watch through 5:50</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=enigma-machine-part-2>Enigma Machine (Part 2)</h1><a href="https://www.youtube.com/watch?v=BCusLaoEQmE">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>I present to you the German Enigma machine. The Enigma machine was used to encode messages during World War Two. And it was a really interesting piece of equipment. It used several different rotors that were rotated to create a key for the encryption, and used a plug board and a keyboard for inputs. And so as we saw in the video with the Enigma machine, you would set the rotors to a particular key. And then when you press the key on the keyboard, and electrical current would go from that key, through the plug board, through the rotors, back out through the rotors, and then light up a lamp above. And so by pressing that key and holding it down, it would show you the letter that that letter should be encrypted to. Then, you would press the next key, another letter would light up, you press another key, another letter would light up. And each time you press a key, the rotors would advance one click changing the way that things were encrypted. And so of course, if you sat there and kept pressing the same key on the keyboard, you would notice that every single time you did that the letters that it would light up would be different every single time making you think that this is a very, very hard to break cipher. And indeed it was.</p><p>So as we saw, the Enigma machine consists of several rotors. Each rotor has 26 letters engraved around the outside, and it has 26 pins, each pin representing the input for one letter. And so you&rsquo;d have a pin on one side, a whole scramble of wires on the inside, and then on the outside, you would have another contact that would go out. And so each pin was paired to one contact, but they were shuffled around randomly, so you really didn&rsquo;t know how it was set up. And so of course, with just three rotors in the Enigma machine, that means there are over 17,000 possible combinations of three character positions of the Enigma machine rotors. So here&rsquo;s an exploded view of showing the between the rotors where you have the pins on one side, making contact with the contacts on the other side. And so by sending an electrical current through one of the rotors, it would eventually go through the pins and contacts through each rotor until it would come back out the other side. And then of course, like we talked about, the Enigma machine uses a ratcheting system, very similar to an old analog odometer in an old car. Every single time you press a key, the ratcheting system would advance the outermost rotor, one click. And then of course, once that rotor has made a full cycle, it would advance the second rotor, one click, and then once that outside rotor has made 26 cycles, and the inner rotor has made 26 cycles as well, then the first rotor will be incremented one click. And so like it works just like an odometer, it&rsquo;s very, very interesting the way they set this up.</p><p>But probably the most interesting fact is the way that the reflector works. So for example, let&rsquo;s say you press the letter A on your keyboard. Then, it would go through the right rotor, the middle rotor the left rotor, and it would hit this special plate on the other end called a reflector, which would take that input on one pin and it would output it on another pin. Then it would go back through the rotors using a different path, and then it would hit the letter G and light up that light. But this right most rotor would then advance one position. So the next time you press the letter A, you would get an entirely different combination. You would have A which would go through this path, hit the reflector, come out this path, and then it would light up the letter C. So this makes decrypting messages really, really impossible. You never know what letter you&rsquo;re going to get out based on the inputs unless you really know everything about how the position is set up. Finally, on the front of the Enigma machine, they included what&rsquo;s called a plug board. And so what the plug board could do is you could swap the positions of two letters using these little wires. So for example, this system is set up to swap the letter S with the letter O and the letter J with the letter A. And so with this plug board, you can have up to 13 swaps, which gives you 10 million different combinations of keys that you might have to worry about. Of course, it&rsquo;s interesting to note that the swaps are reflexive, so if J gets swapped with A, then A also gets swapped with J, so the same happens for both letters.</p><p>So all told, you have all sorts of different ways to set the key for the Enigma machine. You have the choice of the rotors and the ordering of the rotors. We saw three rotors, but toward the end of the war, there might have been as many as eight different rotors available that they could use. Then you have the initial position of the rotors. So the initial three letter key that the rotors were set to. You have the ring setting on the rotors, which shows where the rings go on the rotors, that way, it kind of changes the position a little bit more. And then you&rsquo;d have the plugboard connections on the front, which are swapping different letters around. And so in theory, to understand how an Enigma machine is encrypting data, you would need to know all four of these things for each Enigma machine that you want to try and decrypt. And that&rsquo;s a lot of information to keep in mind. Now of course, the other thing that they did is they had a specific operational pattern that they use when they were encrypting data using an Enigma machine. So the first thing they would do is they would set the wheels on the Enigma machine to the key from today&rsquo;s codebook. The Germans carried around these code books that gave the keys for each day. And unfortunately, throughout the entire war, to my knowledge, not a single codebook was lost. In addition to the key settings, there was a particular way that the Enigma machines were operated. To operate an Enigma machine. First, they would set the wheels to the key from today&rsquo;s codebook, the Germans used a paper codebook that gave different keys for each day of the year. And to my knowledge, those code books were not ever compromised during the war, they would always be burned or destroyed before any German camps were taken over. Secondly, the operator of the Enigma machine would then choose a unique key for the message. So they would choose a different key consisting of three characters for that message. So then they would use the daily key to encode the message key twice to avoid errors. So the first six characters of the message would be the message key encoded twice, then you would set the wheels to the message key, and start en crypting and sending the message. So not only did each day have a different daily key, but then each individual message used its own message key to send the data, so everything was really scrambled.</p><p>So if we look at this process, how do you think you&rsquo;d go about cracking an Enigma machine? Take a minute to think about that. So obviously, the Enigma machine had many strengths. There were many different factors to the encryption, as we saw earlier. There were eight different wheels to choose from by the end of the war. And so depending on how you calculate it, there could be as many as 150 trillion different setups just from the plugboard itself. So altogether, it&rsquo;s estimated there were 158 quintillion possible keys that you could use to decode an Enigma machine.</p><p>However, the Enigma machine came with very, very important weaknesses. The first and most important weakness was a letter would never encrypt to itself, because of the way the reflector worked on the plug boards and on the wheels. If you press the key A, you could press that key 26 times, and never once would the light for a light up because they were on the same circuit. And so with the reflector through the wheels, there was no way the current could come back through the circuit that it was sent out, which means that A would never light up for itself. Secondly, of course, the plug boards were reciprocal. And so by swapping two letters, you&rsquo;re really just adding a substitution cipher on top of a really complex polyalphabetic cipher so the plug boards really didn&rsquo;t do a whole lot in terms of making the combinations more complex, it just scrambled the letters a little bit. Another big problem they had was the wheels themselves were not similar enough, the wheels were so different, in fact that using some advanced mathematics, you could determine roughly which wheels were being used, just by the way the letters were distributed in the message that you received. And then of course, there were some poor policies and procedures around the Enigma machine. And one of the worst parts was the fact that they allowed message operators to choose the key. If your message operator in a foxhole during a war, and you&rsquo;re asked to come up with three random letters all the time, every time you want to send a message, are those letters going to be truly random? Or are you more likely to pick some letters that have specific meaning to you like the initials of your loved one back home or your hometown, and they actually found out that that was a problem. A lot of German message operators were not picking truly random letters for the message keys. And then of course, they were encoding those same letters twice at the beginning of the message. So if you could decrypt the first three letters of the message, you had the message key that you could then use to decrypt the rest of the code. So that was not really that useful. So now let&rsquo;s take a look at a second part of this video about how to decrypt a message that&rsquo;s encoded with Enigma machine.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=flaw-in-the-enigma-code---numberphile>Flaw in the Enigma Code - Numberphile</h1><a href="https://www.youtube.com/watch?v=V4V2bpZlqx8">YouTube Video</a><p>Watch through 2:40</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cracking-enigma>Cracking Enigma</h1><a href="https://www.youtube.com/watch?v=Pl_3MaDEtqk">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>The success for cracking the Enigma machine really comes down to the work of this man, Marian Rejewski. Marian Rejewski was a Polish mathematician who worked on the Enigma machine in the early days of the 1920s and 1930s. The Enigma machine was actually originally available as a corporate machine; you could go out and buy it as a corporation, and use it to encrypt and store data. And so it wasn&rsquo;t until much later that was taken over by the German Nazi Party and used in their war efforts. And so public Enigma machines were available and could be studied. And so Marian Rejewski was able to study some of the early Enigma machines and try and predict the adaptations that Germany made as they move closer to war in the late 1920s and 30s. So based on his work, he was able to determine what the Germans were doing and was even able to eventually replicate some of the German machines that they had created. But of course, that was just part of the story. So to crack the Enigma machine, it was really first cracked by Marian Rejewski of Poland. He was able to use some of those publicly available Enigma machines to crack some of the earliest things that they did. By 1938, as Germany was getting closer to war, they added two new wheels of their own making it much much harder to crack if you didn&rsquo;t know the wheels existed. And so Marian Rejewski of Poland contacted folks in England and gave them a lot of his research and ask them for assistance. And so by 1939, Alan Turing, working together with the folks at Bletchley Park, created what he called the Bombe, which was a machine that could decrypt the Enigma machine. And so work on the Bombe progressed pretty much throughout the entire war. And by 1945, almost every single message that the German sent using the Enigma machine, could be deciphered by the allies within two days. So what is the Bombe? The Bombe is a machine developed by Alan Turing to simulate hundreds of Enigma machines side by side. You can see that it has all of these sets of three wheels, simulating the three wheels that might be present in an Enigma machine. And it was designed to explore many of the weaknesses and other facts about the Enigma machine that were known to the Allies based on the work of Marian Rejewski and Alan Turing at that particular time. So let&rsquo;s take a look at a quick video of a Bombe in action just to see what it looks like.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=bombe-demonstration-at-bletchley-park>Bombe Demonstration at Bletchley Park</h1><a href="https://www.youtube.com/watch?v=Dr1U7Bva6Sw">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=modern-cryptography>Modern Cryptography</h1><a href="https://www.youtube.com/watch?v=gV4QtW1IBCw">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li></ul><h4 id=video-script>Video Script</h4><p>Of course, the impact of cracking the Enigma machine cannot be understated. It&rsquo;s probably best put by Sir Harry Hensley, who is a British intelligence historian. And he wrote, &ldquo;My own conclusion is that it shortened the war by not less than two years and probably by four years &mldr; we wouldn&rsquo;t have in fact been able to do the Normandy landings, even if we had left the Mediterranean aside, until at the earliest 1946, probably a bit later.&rdquo; So really, the ability of the Allies to decrypt and decode the German messages sent via the Enigma machine was really important toward ending the war effort. And it&rsquo;s almost unfathomable to imagine how bad World War Two had been, had it gone on for two or even four more years. And, of course, this is just focusing on the work in the European Theater. There was also another program called Ultra. It was based in the Pacific Theater, focused on decrypting some of the Japanese messages that were sent during World War Two. And so later on, we may add some videos to this module discussing that program, as well.</p><p>But let&rsquo;s move into modern days and talk a little bit about Claude Shannon again. We&rsquo;ve talked about Claude Shannon several times in this class before, but one of his most lasting claims to fame is as The Father of Modern Information Theory. And his work after the war really helped build the modern cryptography systems that we use today. He realized that there was a very mathematical way that you can encrypt data so that it could be very, very difficult to decrypt that data without understanding the keys used to build it. So because of a lot of his work in the 1950s, we refer to Claude Shannon as The Father of Modern Information Theory.</p><p>So one of the modern forms of encryption is called symmetric key encryption. And in symmetric key encryption, we take some sort of data such as the plain text hello world, and we encrypt it using a very particular algorithm and a key. And so the algorithm uses the data that we want to encrypt and the key, and it will produce what&rsquo;s called ciphertext. And so the ciphertext is the encrypted form of the data that we can send and receive and do everything we want. And then to decrypt it, we would use the same key and sometimes a similar algorithm or a slightly different algorithm to get back to the plain text. So symmetric key encryption does have some advantages and disadvantages. One of the biggest things to remember with symmetric key encryption is that it uses a shared secret key. Both the person encrypting the message and decrypting the message need to have a copy of the key. And so that creates this interesting problem of how do we share the key without knowing that someone else got ahold of the key. And likewise, if we encrypt something with a shared key, and the other person has lost that key, then we may not know who has access to that data, making it really kind of complex. However, shared key encryption and symmetric key encryption does still get used from time to time. Most of the time, it&rsquo;s used for file encryption, things like encrypted zip files, usually use symmetric key encryption. You use the same password to encrypt them as you use to decrypt them.</p><p>The other form of modern encryption that we&rsquo;ll talk about is public key encryption. And public key encryption is a little bit more complex because it uses two different keys. So we start by generating two keys, a public key and a private key. The private key we keep for ourselves; we don&rsquo;t give that to anybody else. A lot of times the private key is unique to a particular computer itself. Then we would give our public key to anybody; it&rsquo;s public. We could tattoo it on our forehead. We really don&rsquo;t care because that&rsquo;s the public key. Then, anybody that wants to send us encrypted data, could take their data and lock it using the public key that we have made public available. And as soon as they lock it with that public key, the only person that can unlock it is the person with the matching private key. And so if they want to send something that only we can read, they lock it with our public key, and then we can unlock it with our private key. Likewise, we can go the other way, if we want to send something out to the world and have the world know that it came from us, we can lock it with our private key and post it out on the web along with our public key. And so anybody that wants to can look at that data, unlock it with our public key. And as long as they trust that that&rsquo;s our public key, they know that we are the only person that could have sent that message. This is how things such as email signatures, the actual like signed signatures work. You can also do this on websites. If you look at your websites, they&rsquo;ll have a lock that usually says it&rsquo;s encrypted. And part of that is that the data is encrypted, but also part of that is that it&rsquo;s verified that we know where that data is coming from using a process based on public key encryption. And then of course, we can combine the two. For example, if we&rsquo;re sending our credit card data back and forth with a website, we can use their public key, and they can use our public key in very unique ways. For example, if we want to send our credit card data, what we could do is we could lock it using their public key so that they are the only person that can read it. But we can also sign it with our private key so that they know that the only person that could have sent that data is us. And so by combining the two, we can get both protected data, and we can get it signed and verified so we know where it came from. So let&rsquo;s take a look at a quick video on Diffie-Hellman key exchange, which is how we can actually share keys back and forth and make sure that both users have a key that they can use to encrypt data.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=public-key-cryptography-diffie-hellman-key-exchange-short-version>Public Key Cryptography: Diffie-Hellman Key Exchange (short version)</h1><a href="https://www.youtube.com/watch?v=YEBfamv-_do">YouTube Video</a><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=rsa-encryption>RSA Encryption</h1><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Error in Video</div><div class=box-content><p>In the video, the values of <code>d</code> and <code>e</code> are swapped at one point. Thankfully, this doesn&rsquo;t matter since they are commutative and can be used in any order, but it is a bit confusing. We&rsquo;ll correct this video in the future!</p></div></div><a href="https://www.youtube.com/watch?v=CbafXZ8ymIY">YouTube Video</a><h4 id=resources>Resources</h4><ul><li><a href=/cs-zero/iii-topics/16-cryptography/slides/22-Cryptography.pdf>Slides</a></li><li><a href=https://www.cs.drexel.edu/~jpopyack/Courses/CSP/Wi18/notes/10.1_Cryptography/RSAWorksheetv4e.html rel=external target=_blank>RSA Calculator Worksheet</a></li></ul><h4 id=video-script>Video Script</h4><p>Let&rsquo;s take a look at one modern form of encryption called RSA encryption. RSA was developed in 1977, and it was named for the three creators- Ron Rivest, Adi Shamir, and Leonard Adelman. RSA encryption uses the product of two large prime numbers to generate a key that&rsquo;s used to encrypt data, and the strength of the key really depends on the difficulty of factoring that large number back into its two prime numbers. So for example, if we say our key number is 1071. Can we factor that into the two prime numbers? We could do it eventually, but we&rsquo;d have to check a lot of different numbers to see what it was. So now imagine that 1071, instead of being a number with just four digits, was a number that had 64 digits in it. That&rsquo;s really the size of the prime number products that we&rsquo;re talking about when we do RSA encryption. And so really, the key to RSA encryption is the fact that it&rsquo;s very, very difficult to factor a large number like that into the two unique prime numbers that are used to create it. So let&rsquo;s take a look at how RSA encryption works to see why that&rsquo;s important and why it can create a system that is easily broken if that rule doesn&rsquo;t hold.</p><p>So for RSA, we start with two numbers, p and q. So I&rsquo;m going to start out with p is five, and q is 17. So we&rsquo;ve created two distinct prime numbers five and 17. Next, we will compute their products. So the product is n, which is qual to p times q, which is five times 17, which is 85. The other thing we&rsquo;ll need to compute is Euler&rsquo;s totient. And the totient of two prime numbers is actually just the number minus one. So to calculate Euler&rsquo;s totient t, we would do p minus one times q minus one, which is going to be four times 16, which is 64. So we have p is five, q is 17, n is 85, and our totient t is 64. So let&rsquo;s write that here. Again, we have p is five, q is 17, n is 85, and t is 64.</p><p>Now, here&rsquo;s the really complicated part. We need to choose the number e less than t that is coprime to t so that they share no common factors. Then, we calculate d as the modular multiplicative inverse of e. So that e times x is equal to one mod t. This is really complex mathematics, but what it really means is we need to pick a multiple that is one more than a multiple of t. So if t is 64, we&rsquo;re looking at 65 129 193, etc. So we&rsquo;re finding multiples of t, 64, an adding 1, 65. 64 times two is 28, so 129. 64 times three is 193. 64 times four is 256. So we&rsquo;d look at 257, etcetera. And then we choose one of these that we can factor. So let&rsquo;s look at 65. Can we factor 65 into two numbers? It turns out we can. So if we set d equal to five, and e equal to 13, we get 65. And e is less than t, and it&rsquo;s coprime to t. Specifically, e is prime, which is great. Two number are coprime if they don&rsquo;t share any common factors other than one. And since 13 is prime, it&rsquo;s also coprime to any other number, which is what we want.</p><p>So now we found d and e, which are the keys that we actually need to send and receive our ata. So let&rsquo;s look at our RSA keys. We have two keys, our public key, which is going to be n and remember and n is 85 and e is five. And then we can encode using this, and we have our private key, which is 85 and 13. So let&rsquo;s take a look at an example to see how this would work. If we want to encrypt the message 42, what we would do is we would take 42 to the power of five, and then we would do mod 85. So remember, the modulo operation means we divide by 85 and we keep the remainder. So if we actually do this on a calculator, you&rsquo;ll find that this is equal to 77. And if you have a calculator handy, you can try this yourself. So 77 is the message that we can send as an encoded message. On the receiving end, we would take our encoded message 77, raise it to the power of 13, mod 85. And sure enough, if you calculate 77 to the power of 13, and you might need Wolfram Alpha to do this, then mod 85, you will get back the original message 42. That&rsquo;s how RSA encryption works. It&rsquo;s really, really simple. It&rsquo;s mathematics with a little bit of flavor on top of it to make the keys.</p><p>Now, here&rsquo;s the really tricky part. How do we break RSA encryption? Well, let&rsquo;s take a look at our keys. Right here in both our public key and our private key, one part of that key is 85. What was 85? Remember that 85 is equal to our two prime numbers, p and q multiplied together. And since p and q are both prime, there is only one way that 85 could be factored. There are no other possible factors. And we know that we use five and 17. So if anybody can factor 85, into five and 17, then they can create t, because t is going to be four times 16, which is 64. And then using t if they have either e or d, they know that e times d would be one more than a multiple of t. And once they have that they could deduce the other half of the key. That&rsquo;s what&rsquo;s really important here. So RSA only works if this particular operation is very, very expensive. So to do RSA encryption, we choose numbers p and q, such that they are very, very large. And like I said, we&rsquo;re talking hundreds of bits, we&rsquo;re talking multiple digits long, and that&rsquo;s why there&rsquo;s so much computing power spent on the search for larger and larger prime numbers. Because for RSA encryption to work, we need those larger and larger prime numbers in order to construct RSA keys that we can use to send and receive data.</p><p>This is also really important later on when we talk about concepts such as computability. For example, we&rsquo;re making an assumption here that the only way to factor a very, very large product of prime numbers is trying all possible prime numbers less than that number. So it&rsquo;s simply brute force. Now, if we wake up tomorrow, and some mathematician has devised a better algorithm for factoring large products of prime numbers into their two primes, then all of the RSA encryption on the internet isn&rsquo;t as secure anymore, because now there&rsquo;s an algorithm that can do that quickly. Another fear would be that quantum computers could do this. And so if a quantum computer discovers a way to factor large products of prime numbers very quickly, it could have the same effect on RSA encryption. Now, of course, this is just one example of one encryption algorithm, but it gives you an idea of the fact that modern encryption is really built upon these ideas that there are very difficult calculations for somebody else to make if they don&rsquo;t know the original numbers, but those calculations can be made very quickly for us if we know the original numbers that we used to build that key. So I hope this has been really informative. I really encourage you to try RSA encryption for yourself. It is very fun to do the math behind this. And just to see that it works exactly like you&rsquo;d expect. You can go back and pick any two prime numbers for p and q, and go through this process. The hardest part is finding e and d. But there&rsquo;s some really great helpers online that you can use, and I&rsquo;ll link to one of those after this video so you can play around with RSA encryption yourself.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=nine-algorithms-that-changed-the-future-ch-4---public-key-cryptography>Nine Algorithms that Changed the Future Ch 4 - Public Key Cryptography</h1><p>Nine Algorithms that Changed the Future Ch 4 - Public Key Cryptography</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=nine-algorithms-that-changed-the-future-ch-9---digital-signatures>Nine Algorithms that Changed the Future Ch 9 - Digital Signatures</h1><p>Nine Algorithms that Changed the Future Ch 9 - Digital Signatures</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cs-zero/commit/60c42fb940e7bedf80464668fdcb137012a58d94>Sep 12, 2023</a></p></div></div><script src=/cs-zero/js/clipboard.min.js?1756074760 defer></script><script src=/cs-zero/js/perfect-scrollbar.min.js?1756074760 defer></script><script src=/cs-zero/js/theme.js?1756074760 defer></script></body></html>